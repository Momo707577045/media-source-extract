<!DOCTYPE html>
<html>

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <meta name="author" content="毛静文,Momo">
  <meta name="keywords" content="无差别提取视频的工具,毛静文的博客,Momo's Blog">
  <meta name="description" content="无差别提取视频的工具,网页上能播放的视频,绝大部分都可以通过本工具进行提取,无视媒体加密技术,直接从底层捕获视频资源">
  <title>Media Source Player</title>
  <style>
    /*全局设置*/
    html,
    body,
    #m-app {
      margin: 0;
      padding: 0;
    }

    body::-webkit-scrollbar {
      display: none
    }

    p {
      margin: 0;
    }

    [v-cloak] {
      display: none;
    }

    .background {
      position: fixed;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      background-image: url(data:image/webp;base64,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);
      background-position: center center;
      background-size: cover;
      filter: blur(1px);
      z-index: -1;
    }

    /*工具栏*/
    .m-p-action {
      margin: 20px auto;
      max-width: 1100px;
      width: 100%;
      font-size: 35px;
      text-align: center;
      font-weight: bold;
    }

    .m-p-other,
    .m-p-github,
    .rate-group {
      position: fixed;
      right: 50px;
      background-color: #eff3f6;
      background-image: linear-gradient(-180deg, #fafbfc, #eff3f6 90%);
      color: #24292e;
      border: 1px solid rgba(27, 31, 35, .2);
      border-radius: 3px;
      cursor: pointer;
      display: inline-block;
      font-size: 14px;
      font-weight: 600;
      line-height: 20px;
      padding: 6px 12px;
      z-index: 99;
      box-shadow: 0 5px 18px 0 rgba(0, 0, 0, 0.3);
    }

    .m-p-help {
      position: fixed;
      right: 50px;
      top: 50px;
      width: 30px;
      height: 30px;
      color: #666666;
      z-index: 2;
      text-align: center;
      line-height: 30px;
      font-weight: bolder;
      border-radius: 50%;
      border: 1px solid rgba(27, 31, 35, .2);
      cursor: pointer;
      box-shadow: 0 5px 18px 0 rgba(0, 0, 0, 0.3);
      background-color: #eff3f6;
      background-image: linear-gradient(-180deg, #fafbfc, #eff3f6 90%);
    }

    .m-p-github:hover,
    .m-p-help:hover {
      opacity: 0.9;
    }

    .m-p-github {
      bottom: 30px;
    }

    .rate-group {
      top: 100px;
      right: 0;
      width: 40px;
    }

    .rate-group .select {
      color: white;
      text-align: center;
      border-radius: 2px;
      background-color: #27ae60;
    }

    /*输入框*/
    #input-box {
      position: absolute;
      top: 40%;
      left: 50%;
      width: 450px;
      transform: translate(-50%, -50%);

    }

    #input-box input {
      position: fixed;
      left: -4000px;
      z-index: -2;
      border-radius: 4px;

    }

    #input-box label {
      margin-bottom: 10px;
      padding: 0 20px;
      display: block;
      width: 100%;
      height: 40px;
      color: white;
      font-size: 20px;
      text-align: center;
      line-height: 40px;
      border-radius: 4px;
      background-color: #3D8AC7;
      opacity: 1;
      user-select: none;
      cursor: pointer;
      transition: 0.3s all;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
      box-sizing: border-box;
      transition-duration: .4s;
      transition-property: background, box-shadow;
    }

    #input-box label:hover {
      opacity: 0.7 !important;
      border-color: transparent;
      box-shadow: 0 5px 18px 0 rgba(0, 0, 0, 0.3);
    }

    #input-box .finish {
      background-color: #27ae60;
      cursor: auto;
    }

    #input-box .finish:hover {
      opacity: 1;
    }

    #input-box .disable {
      background-color: #bdc3c7;
      cursor: auto;
    }

    #input-box .disable:hover {
      opacity: 1;
    }

    #input-box div {
      cursor: pointer;
      color: #666666;
    }

    /*视频区*/
    video {
      position: absolute;
      top: 100px;
      left: 50%;
      width: calc(100% - 130px);
      transform: translateX(-50%);
    }
  </style>
</head>

<body>
  <section id="m-app" v-cloak>
    <div class="background"></div>
    <section class="m-p-action g-box">{{ isPlay ? videoFileName : 'Media Source 播放器' }}</section>
    <template v-if="!isPlay">
      <a v-if="!isPlay" class="m-p-help" target="_blank" href="https://github.com/Momo707577045/media-source-extract">?</a>
      <a class="m-p-github" target="_blank" href="https://github.com/Momo707577045/media-source-extract">github</a>
    </template>

    <!--倍速设置器-->
    <div class="rate-group" v-if="isPlay">
      <div v-for="(rate, index) in playbackRateList" @click="setRate(index)" :class="[ playbackRateIndex === index ? 'select' : '']">{{rate}}</div>
    </div>

    <!--文件上传-->
    <section id="input-box" v-show="!isPlay">
      <label for="video" :title="videoFileName" :class="[videoFileName ? 'finish' : '']">{{ videoFileName ? `视频已上传(${videoFileName})` : '点击，上传视频文件' }}</label>
      <label for="audio" :title="audioFileName" :class="[audioFileName ? 'finish' : '']">{{ audioFileName ? `音频已上传(${audioFileName})` : '点击，上传音频文件' }}</label>
      <input v-if="!videoFileName" id="video" accept="video/*" type="file" value="点击，上传视频文件" @change="!videoFileName && loadSource($event, 'video')">
      <input v-if="!audioFileName" id="audio" accept="audio/*" type="file" value="点击，上传音频文件" @change="!audioFileName && loadSource($event, 'audio')">
      <label @click="(audioFileName || videoFileName) && play()" :class="[audioFileName || videoFileName ? '' : 'disable']">播放</label>
    </section>

    <!--播放视频-->
    <video controls v-show="isPlay" ref="player"></video>

    <div v-if="isPlay" style="height: 100vh"></div>

  </section>
</body>
<script>
  var _hmt = _hmt || [];
  (function () {
    var hm = document.createElement("script");
    hm.src = "https://hm.baidu.com/hm.js?1f12b0865d866ae1b93514870d93ce89";
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(hm, s);
  })();
</script>
<script>
  /*! mp4box 19-03-2022 */

  var Log = function () { var i = new Date, r = 4; return { setLogLevel: function (t) { r = t == this.debug ? 1 : t == this.info ? 2 : t == this.warn ? 3 : (this.error, 4) }, debug: function (t, e) { void 0 === console.debug && (console.debug = console.log), r <= 1 && console.debug("[" + Log.getDurationString(new Date - i, 1e3) + "]", "[" + t + "]", e) }, log: function (t, e) { this.debug(t.msg) }, info: function (t, e) { r <= 2 && console.info("[" + Log.getDurationString(new Date - i, 1e3) + "]", "[" + t + "]", e) }, warn: function (t, e) { r <= 3 && console.warn("[" + Log.getDurationString(new Date - i, 1e3) + "]", "[" + t + "]", e) }, error: function (t, e) { r <= 4 && console.error("[" + Log.getDurationString(new Date - i, 1e3) + "]", "[" + t + "]", e) } } }(); Log.getDurationString = function (t, e) { var i; function r(t, e) { for (var i = ("" + t).split("."); i[0].length < e;)i[0] = "0" + i[0]; return i.join(".") } t < 0 ? (i = !0, t = -t) : i = !1; var s = t / (e || 1), a = Math.floor(s / 3600); s -= 3600 * a; t = Math.floor(s / 60), e = 1e3 * (s -= 60 * t); return e -= 1e3 * (s = Math.floor(s)), e = Math.floor(e), (i ? "-" : "") + a + ":" + r(t, 2) + ":" + r(s, 2) + "." + r(e, 3) }, Log.printRanges = function (t) { var e = t.length; if (0 < e) { for (var i = "", r = 0; r < e; r++)0 < r && (i += ","), i += "[" + Log.getDurationString(t.start(r)) + "," + Log.getDurationString(t.end(r)) + "]"; return i } return "(empty)" }, "undefined" != typeof exports && (exports.Log = Log); var MP4BoxStream = function (t) { if (!(t instanceof ArrayBuffer)) throw "Needs an array buffer"; this.buffer = t, this.dataview = new DataView(t), this.position = 0 }; MP4BoxStream.prototype.getPosition = function () { return this.position }, MP4BoxStream.prototype.getEndPosition = function () { return this.buffer.byteLength }, MP4BoxStream.prototype.getLength = function () { return this.buffer.byteLength }, MP4BoxStream.prototype.seek = function (t) { t = Math.max(0, Math.min(this.buffer.byteLength, t)); return this.position = isNaN(t) || !isFinite(t) ? 0 : t, !0 }, MP4BoxStream.prototype.isEos = function () { return this.getPosition() >= this.getEndPosition() }, MP4BoxStream.prototype.readAnyInt = function (t, e) { var i = 0; if (this.position + t <= this.buffer.byteLength) { switch (t) { case 1: i = e ? this.dataview.getInt8(this.position) : this.dataview.getUint8(this.position); break; case 2: i = e ? this.dataview.getInt16(this.position) : this.dataview.getUint16(this.position); break; case 3: if (e) throw "No method for reading signed 24 bits values"; i = this.dataview.getUint8(this.position) << 16, i |= this.dataview.getUint8(this.position + 1) << 8, i |= this.dataview.getUint8(this.position + 2); break; case 4: i = e ? this.dataview.getInt32(this.position) : this.dataview.getUint32(this.position); break; case 8: if (e) throw "No method for reading signed 64 bits values"; i = this.dataview.getUint32(this.position) << 32, i |= this.dataview.getUint32(this.position + 4); break; default: throw "readInt method not implemented for size: " + t }return this.position += t, i } throw "Not enough bytes in buffer" }, MP4BoxStream.prototype.readUint8 = function () { return this.readAnyInt(1, !1) }, MP4BoxStream.prototype.readUint16 = function () { return this.readAnyInt(2, !1) }, MP4BoxStream.prototype.readUint24 = function () { return this.readAnyInt(3, !1) }, MP4BoxStream.prototype.readUint32 = function () { return this.readAnyInt(4, !1) }, MP4BoxStream.prototype.readUint64 = function () { return this.readAnyInt(8, !1) }, MP4BoxStream.prototype.readString = function (t) { if (this.position + t <= this.buffer.byteLength) { for (var e = "", i = 0; i < t; i++)e += String.fromCharCode(this.readUint8()); return e } throw "Not enough bytes in buffer" }, MP4BoxStream.prototype.readCString = function () { for (var t = []; ;) { var e = this.readUint8(); if (0 === e) break; t.push(e) } return String.fromCharCode.apply(null, t) }, MP4BoxStream.prototype.readInt8 = function () { return this.readAnyInt(1, !0) }, MP4BoxStream.prototype.readInt16 = function () { return this.readAnyInt(2, !0) }, MP4BoxStream.prototype.readInt32 = function () { return this.readAnyInt(4, !0) }, MP4BoxStream.prototype.readInt64 = function () { return this.readAnyInt(8, !1) }, MP4BoxStream.prototype.readUint8Array = function (t) { for (var e = new Uint8Array(t), i = 0; i < t; i++)e[i] = this.readUint8(); return e }, MP4BoxStream.prototype.readInt16Array = function (t) { for (var e = new Int16Array(t), i = 0; i < t; i++)e[i] = this.readInt16(); return e }, MP4BoxStream.prototype.readUint16Array = function (t) { for (var e = new Int16Array(t), i = 0; i < t; i++)e[i] = this.readUint16(); return e }, MP4BoxStream.prototype.readUint32Array = function (t) { for (var e = new Uint32Array(t), i = 0; i < t; i++)e[i] = this.readUint32(); return e }, MP4BoxStream.prototype.readInt32Array = function (t) { for (var e = new Int32Array(t), i = 0; i < t; i++)e[i] = this.readInt32(); return e }, "undefined" != typeof exports && (exports.MP4BoxStream = MP4BoxStream); var DataStream = function (t, e, i) { this._byteOffset = e || 0, t instanceof ArrayBuffer ? this.buffer = t : "object" == typeof t ? (this.dataView = t, e && (this._byteOffset += e)) : this.buffer = new ArrayBuffer(t || 0), this.position = 0, this.endianness = null == i ? DataStream.LITTLE_ENDIAN : i }; DataStream.prototype = {}, DataStream.prototype.getPosition = function () { return this.position }, DataStream.prototype._realloc = function (t) { if (this._dynamicSize) { var e = this._byteOffset + this.position + t, i = this._buffer.byteLength; if (e <= i) e > this._byteLength && (this._byteLength = e); else { for (i < 1 && (i = 1); i < e;)i *= 2; var r = new ArrayBuffer(i), t = new Uint8Array(this._buffer); new Uint8Array(r, 0, t.length).set(t), this.buffer = r, this._byteLength = e } } }, DataStream.prototype._trimAlloc = function () { var t, e, i; this._byteLength != this._buffer.byteLength && (t = new ArrayBuffer(this._byteLength), e = new Uint8Array(t), i = new Uint8Array(this._buffer, 0, e.length), e.set(i), this.buffer = t) }, DataStream.BIG_ENDIAN = !1, DataStream.LITTLE_ENDIAN = !0, DataStream.prototype._byteLength = 0, Object.defineProperty(DataStream.prototype, "byteLength", { get: function () { return this._byteLength - this._byteOffset } }), Object.defineProperty(DataStream.prototype, "buffer", { get: function () { return this._trimAlloc(), this._buffer }, set: function (t) { this._buffer = t, this._dataView = new DataView(this._buffer, this._byteOffset), this._byteLength = this._buffer.byteLength } }), Object.defineProperty(DataStream.prototype, "byteOffset", { get: function () { return this._byteOffset }, set: function (t) { this._byteOffset = t, this._dataView = new DataView(this._buffer, this._byteOffset), this._byteLength = this._buffer.byteLength } }), Object.defineProperty(DataStream.prototype, "dataView", { get: function () { return this._dataView }, set: function (t) { this._byteOffset = t.byteOffset, this._buffer = t.buffer, this._dataView = new DataView(this._buffer, this._byteOffset), this._byteLength = this._byteOffset + t.byteLength } }), DataStream.prototype.seek = function (t) { t = Math.max(0, Math.min(this.byteLength, t)); this.position = isNaN(t) || !isFinite(t) ? 0 : t }, DataStream.prototype.isEof = function () { return this.position >= this._byteLength }, DataStream.prototype.mapUint8Array = function (t) { this._realloc(+t); var e = new Uint8Array(this._buffer, this.byteOffset + this.position, t); return this.position += +t, e }, DataStream.prototype.readInt32Array = function (t, e) { t = null == t ? this.byteLength - this.position / 4 : t; var i = new Int32Array(t); return DataStream.memcpy(i.buffer, 0, this.buffer, this.byteOffset + this.position, t * i.BYTES_PER_ELEMENT), DataStream.arrayToNative(i, null == e ? this.endianness : e), this.position += i.byteLength, i }, DataStream.prototype.readInt16Array = function (t, e) { t = null == t ? this.byteLength - this.position / 2 : t; var i = new Int16Array(t); return DataStream.memcpy(i.buffer, 0, this.buffer, this.byteOffset + this.position, t * i.BYTES_PER_ELEMENT), DataStream.arrayToNative(i, null == e ? this.endianness : e), this.position += i.byteLength, i }, DataStream.prototype.readInt8Array = function (t) { t = null == t ? this.byteLength - this.position : t; var e = new Int8Array(t); return DataStream.memcpy(e.buffer, 0, this.buffer, this.byteOffset + this.position, t * e.BYTES_PER_ELEMENT), this.position += e.byteLength, e }, DataStream.prototype.readUint32Array = function (t, e) { t = null == t ? this.byteLength - this.position / 4 : t; var i = new Uint32Array(t); return DataStream.memcpy(i.buffer, 0, this.buffer, this.byteOffset + this.position, t * i.BYTES_PER_ELEMENT), DataStream.arrayToNative(i, null == e ? this.endianness : e), this.position += i.byteLength, i }, DataStream.prototype.readUint16Array = function (t, e) { t = null == t ? this.byteLength - this.position / 2 : t; var i = new Uint16Array(t); return DataStream.memcpy(i.buffer, 0, this.buffer, this.byteOffset + this.position, t * i.BYTES_PER_ELEMENT), DataStream.arrayToNative(i, null == e ? this.endianness : e), this.position += i.byteLength, i }, DataStream.prototype.readUint8Array = function (t) { t = null == t ? this.byteLength - this.position : t; var e = new Uint8Array(t); return DataStream.memcpy(e.buffer, 0, this.buffer, this.byteOffset + this.position, t * e.BYTES_PER_ELEMENT), this.position += e.byteLength, e }, DataStream.prototype.readFloat64Array = function (t, e) { t = null == t ? this.byteLength - this.position / 8 : t; var i = new Float64Array(t); return DataStream.memcpy(i.buffer, 0, this.buffer, this.byteOffset + this.position, t * i.BYTES_PER_ELEMENT), DataStream.arrayToNative(i, null == e ? this.endianness : e), this.position += i.byteLength, i }, DataStream.prototype.readFloat32Array = function (t, e) { t = null == t ? this.byteLength - this.position / 4 : t; var i = new Float32Array(t); return DataStream.memcpy(i.buffer, 0, this.buffer, this.byteOffset + this.position, t * i.BYTES_PER_ELEMENT), DataStream.arrayToNative(i, null == e ? this.endianness : e), this.position += i.byteLength, i }, DataStream.prototype.readInt32 = function (t) { t = this._dataView.getInt32(this.position, null == t ? this.endianness : t); return this.position += 4, t }, DataStream.prototype.readInt16 = function (t) { t = this._dataView.getInt16(this.position, null == t ? this.endianness : t); return this.position += 2, t }, DataStream.prototype.readInt8 = function () { var t = this._dataView.getInt8(this.position); return this.position += 1, t }, DataStream.prototype.readUint32 = function (t) { t = this._dataView.getUint32(this.position, null == t ? this.endianness : t); return this.position += 4, t }, DataStream.prototype.readUint16 = function (t) { t = this._dataView.getUint16(this.position, null == t ? this.endianness : t); return this.position += 2, t }, DataStream.prototype.readUint8 = function () { var t = this._dataView.getUint8(this.position); return this.position += 1, t }, DataStream.prototype.readFloat32 = function (t) { t = this._dataView.getFloat32(this.position, null == t ? this.endianness : t); return this.position += 4, t }, DataStream.prototype.readFloat64 = function (t) { t = this._dataView.getFloat64(this.position, null == t ? this.endianness : t); return this.position += 8, t }, DataStream.endianness = 0 < new Int8Array(new Int16Array([1]).buffer)[0], DataStream.memcpy = function (t, e, i, r, s) { e = new Uint8Array(t, e, s), s = new Uint8Array(i, r, s); e.set(s) }, DataStream.arrayToNative = function (t, e) { return e == this.endianness ? t : this.flipArrayEndianness(t) }, DataStream.nativeToEndian = function (t, e) { return this.endianness == e ? t : this.flipArrayEndianness(t) }, DataStream.flipArrayEndianness = function (t) { for (var e = new Uint8Array(t.buffer, t.byteOffset, t.byteLength), i = 0; i < t.byteLength; i += t.BYTES_PER_ELEMENT)for (var r = i + t.BYTES_PER_ELEMENT - 1, s = i; s < r; r--, s++) { var a = e[s]; e[s] = e[r], e[r] = a } return t }, DataStream.prototype.failurePosition = 0, String.fromCharCodeUint8 = function (t) { for (var e = [], i = 0; i < t.length; i++)e[i] = t[i]; return String.fromCharCode.apply(null, e) }, DataStream.prototype.readString = function (t, e) { return null == e || "ASCII" == e ? String.fromCharCodeUint8.apply(null, [this.mapUint8Array(null == t ? this.byteLength - this.position : t)]) : new TextDecoder(e).decode(this.mapUint8Array(t)) }, DataStream.prototype.readCString = function (t) { var e = this.byteLength - this.position, i = new Uint8Array(this._buffer, this._byteOffset + this.position), r = e; null != t && (r = Math.min(t, e)); for (var s = 0; s < r && 0 !== i[s]; s++); var a = String.fromCharCodeUint8.apply(null, [this.mapUint8Array(s)]); return null != t ? this.position += r - s : s != e && (this.position += 1), a }; var MAX_SIZE = Math.pow(2, 32); DataStream.prototype.readInt64 = function () { return this.readInt32() * MAX_SIZE + this.readUint32() }, DataStream.prototype.readUint64 = function () { return this.readUint32() * MAX_SIZE + this.readUint32() }, DataStream.prototype.readInt64 = function () { return this.readUint32() * MAX_SIZE + this.readUint32() }, DataStream.prototype.readUint24 = function () { return (this.readUint8() << 16) + (this.readUint8() << 8) + this.readUint8() }, "undefined" != typeof exports && (exports.DataStream = DataStream), DataStream.prototype.save = function (t) { var e = new Blob([this.buffer]); if (!window.URL || !URL.createObjectURL) throw "DataStream.save: Can't create object URL."; var i = window.URL.createObjectURL(e), e = document.createElement("a"); document.body.appendChild(e), e.setAttribute("href", i), e.setAttribute("download", t), e.setAttribute("target", "_self"), e.click(), window.URL.revokeObjectURL(i) }, DataStream.prototype._dynamicSize = !0, Object.defineProperty(DataStream.prototype, "dynamicSize", { get: function () { return this._dynamicSize }, set: function (t) { t || this._trimAlloc(), this._dynamicSize = t } }), DataStream.prototype.shift = function (t) { var e = new ArrayBuffer(this._byteLength - t), i = new Uint8Array(e), r = new Uint8Array(this._buffer, t, i.length); i.set(r), this.buffer = e, this.position -= t }, DataStream.prototype.writeInt32Array = function (t, e) { if (this._realloc(4 * t.length), t instanceof Int32Array && this.byteOffset + this.position % t.BYTES_PER_ELEMENT === 0) DataStream.memcpy(this._buffer, this.byteOffset + this.position, t.buffer, 0, t.byteLength), this.mapInt32Array(t.length, e); else for (var i = 0; i < t.length; i++)this.writeInt32(t[i], e) }, DataStream.prototype.writeInt16Array = function (t, e) { if (this._realloc(2 * t.length), t instanceof Int16Array && this.byteOffset + this.position % t.BYTES_PER_ELEMENT === 0) DataStream.memcpy(this._buffer, this.byteOffset + this.position, t.buffer, 0, t.byteLength), this.mapInt16Array(t.length, e); else for (var i = 0; i < t.length; i++)this.writeInt16(t[i], e) }, DataStream.prototype.writeInt8Array = function (t) { if (this._realloc(+t.length), t instanceof Int8Array && this.byteOffset + this.position % t.BYTES_PER_ELEMENT === 0) DataStream.memcpy(this._buffer, this.byteOffset + this.position, t.buffer, 0, t.byteLength), this.mapInt8Array(t.length); else for (var e = 0; e < t.length; e++)this.writeInt8(t[e]) }, DataStream.prototype.writeUint32Array = function (t, e) { if (this._realloc(4 * t.length), t instanceof Uint32Array && this.byteOffset + this.position % t.BYTES_PER_ELEMENT === 0) DataStream.memcpy(this._buffer, this.byteOffset + this.position, t.buffer, 0, t.byteLength), this.mapUint32Array(t.length, e); else for (var i = 0; i < t.length; i++)this.writeUint32(t[i], e) }, DataStream.prototype.writeUint16Array = function (t, e) { if (this._realloc(2 * t.length), t instanceof Uint16Array && this.byteOffset + this.position % t.BYTES_PER_ELEMENT === 0) DataStream.memcpy(this._buffer, this.byteOffset + this.position, t.buffer, 0, t.byteLength), this.mapUint16Array(t.length, e); else for (var i = 0; i < t.length; i++)this.writeUint16(t[i], e) }, DataStream.prototype.writeUint8Array = function (t) { if (this._realloc(+t.length), t instanceof Uint8Array && this.byteOffset + this.position % t.BYTES_PER_ELEMENT === 0) DataStream.memcpy(this._buffer, this.byteOffset + this.position, t.buffer, 0, t.byteLength), this.mapUint8Array(t.length); else for (var e = 0; e < t.length; e++)this.writeUint8(t[e]) }, DataStream.prototype.writeFloat64Array = function (t, e) { if (this._realloc(8 * t.length), t instanceof Float64Array && this.byteOffset + this.position % t.BYTES_PER_ELEMENT === 0) DataStream.memcpy(this._buffer, this.byteOffset + this.position, t.buffer, 0, t.byteLength), this.mapFloat64Array(t.length, e); else for (var i = 0; i < t.length; i++)this.writeFloat64(t[i], e) }, DataStream.prototype.writeFloat32Array = function (t, e) { if (this._realloc(4 * t.length), t instanceof Float32Array && this.byteOffset + this.position % t.BYTES_PER_ELEMENT === 0) DataStream.memcpy(this._buffer, this.byteOffset + this.position, t.buffer, 0, t.byteLength), this.mapFloat32Array(t.length, e); else for (var i = 0; i < t.length; i++)this.writeFloat32(t[i], e) }, DataStream.prototype.writeInt32 = function (t, e) { this._realloc(4), this._dataView.setInt32(this.position, t, null == e ? this.endianness : e), this.position += 4 }, DataStream.prototype.writeInt16 = function (t, e) { this._realloc(2), this._dataView.setInt16(this.position, t, null == e ? this.endianness : e), this.position += 2 }, DataStream.prototype.writeInt8 = function (t) { this._realloc(1), this._dataView.setInt8(this.position, t), this.position += 1 }, DataStream.prototype.writeUint32 = function (t, e) { this._realloc(4), this._dataView.setUint32(this.position, t, null == e ? this.endianness : e), this.position += 4 }, DataStream.prototype.writeUint16 = function (t, e) { this._realloc(2), this._dataView.setUint16(this.position, t, null == e ? this.endianness : e), this.position += 2 }, DataStream.prototype.writeUint8 = function (t) { this._realloc(1), this._dataView.setUint8(this.position, t), this.position += 1 }, DataStream.prototype.writeFloat32 = function (t, e) { this._realloc(4), this._dataView.setFloat32(this.position, t, null == e ? this.endianness : e), this.position += 4 }, DataStream.prototype.writeFloat64 = function (t, e) { this._realloc(8), this._dataView.setFloat64(this.position, t, null == e ? this.endianness : e), this.position += 8 }, DataStream.prototype.writeUCS2String = function (t, e, i) { null == i && (i = t.length); for (var r = 0; r < t.length && r < i; r++)this.writeUint16(t.charCodeAt(r), e); for (; r < i; r++)this.writeUint16(0) }, DataStream.prototype.writeString = function (t, e, i) { var r = 0; if (null == e || "ASCII" == e) if (null != i) { for (var s = Math.min(t.length, i), r = 0; r < s; r++)this.writeUint8(t.charCodeAt(r)); for (; r < i; r++)this.writeUint8(0) } else for (r = 0; r < t.length; r++)this.writeUint8(t.charCodeAt(r)); else this.writeUint8Array(new TextEncoder(e).encode(t.substring(0, i))) }, DataStream.prototype.writeCString = function (t, e) { var i = 0; if (null != e) { for (var r = Math.min(t.length, e), i = 0; i < r; i++)this.writeUint8(t.charCodeAt(i)); for (; i < e; i++)this.writeUint8(0) } else { for (i = 0; i < t.length; i++)this.writeUint8(t.charCodeAt(i)); this.writeUint8(0) } }, DataStream.prototype.writeStruct = function (t, e) { for (var i = 0; i < t.length; i += 2) { var r = t[i + 1]; this.writeType(r, e[t[i]], e) } }, DataStream.prototype.writeType = function (t, e, i) { var r; if ("function" == typeof t) return t(this, e); if ("object" == typeof t && !(t instanceof Array)) return t.set(this, e, i); var s = null, a = "ASCII", i = this.position; switch ("string" == typeof t && /:/.test(t) && (t = (r = t.split(":"))[0], s = parseInt(r[1])), "string" == typeof t && /,/.test(t) && (t = (r = t.split(","))[0], a = parseInt(r[1])), t) { case "uint8": this.writeUint8(e); break; case "int8": this.writeInt8(e); break; case "uint16": this.writeUint16(e, this.endianness); break; case "int16": this.writeInt16(e, this.endianness); break; case "uint32": this.writeUint32(e, this.endianness); break; case "int32": this.writeInt32(e, this.endianness); break; case "float32": this.writeFloat32(e, this.endianness); break; case "float64": this.writeFloat64(e, this.endianness); break; case "uint16be": this.writeUint16(e, DataStream.BIG_ENDIAN); break; case "int16be": this.writeInt16(e, DataStream.BIG_ENDIAN); break; case "uint32be": this.writeUint32(e, DataStream.BIG_ENDIAN); break; case "int32be": this.writeInt32(e, DataStream.BIG_ENDIAN); break; case "float32be": this.writeFloat32(e, DataStream.BIG_ENDIAN); break; case "float64be": this.writeFloat64(e, DataStream.BIG_ENDIAN); break; case "uint16le": this.writeUint16(e, DataStream.LITTLE_ENDIAN); break; case "int16le": this.writeInt16(e, DataStream.LITTLE_ENDIAN); break; case "uint32le": this.writeUint32(e, DataStream.LITTLE_ENDIAN); break; case "int32le": this.writeInt32(e, DataStream.LITTLE_ENDIAN); break; case "float32le": this.writeFloat32(e, DataStream.LITTLE_ENDIAN); break; case "float64le": this.writeFloat64(e, DataStream.LITTLE_ENDIAN); break; case "cstring": this.writeCString(e, s); break; case "string": this.writeString(e, a, s); break; case "u16string": this.writeUCS2String(e, this.endianness, s); break; case "u16stringle": this.writeUCS2String(e, DataStream.LITTLE_ENDIAN, s); break; case "u16stringbe": this.writeUCS2String(e, DataStream.BIG_ENDIAN, s); break; default: if (3 == t.length) { for (var n = t[1], o = 0; o < e.length; o++)this.writeType(n, e[o]); break } this.writeStruct(t, e) }null != s && (this.position = i, this._realloc(s), this.position = i + s) }, DataStream.prototype.writeUint64 = function (t) { var e = Math.floor(t / MAX_SIZE); this.writeUint32(e), this.writeUint32(4294967295 & t) }, DataStream.prototype.writeUint24 = function (t) { this.writeUint8((16711680 & t) >> 16), this.writeUint8((65280 & t) >> 8), this.writeUint8(255 & t) }, DataStream.prototype.adjustUint32 = function (t, e) { var i = this.position; this.seek(t), this.writeUint32(e), this.seek(i) }, DataStream.prototype.mapInt32Array = function (t, e) { this._realloc(4 * t); var i = new Int32Array(this._buffer, this.byteOffset + this.position, t); return DataStream.arrayToNative(i, null == e ? this.endianness : e), this.position += 4 * t, i }, DataStream.prototype.mapInt16Array = function (t, e) { this._realloc(2 * t); var i = new Int16Array(this._buffer, this.byteOffset + this.position, t); return DataStream.arrayToNative(i, null == e ? this.endianness : e), this.position += 2 * t, i }, DataStream.prototype.mapInt8Array = function (t) { this._realloc(+t); var e = new Int8Array(this._buffer, this.byteOffset + this.position, t); return this.position += +t, e }, DataStream.prototype.mapUint32Array = function (t, e) { this._realloc(4 * t); var i = new Uint32Array(this._buffer, this.byteOffset + this.position, t); return DataStream.arrayToNative(i, null == e ? this.endianness : e), this.position += 4 * t, i }, DataStream.prototype.mapUint16Array = function (t, e) { this._realloc(2 * t); var i = new Uint16Array(this._buffer, this.byteOffset + this.position, t); return DataStream.arrayToNative(i, null == e ? this.endianness : e), this.position += 2 * t, i }, DataStream.prototype.mapFloat64Array = function (t, e) { this._realloc(8 * t); var i = new Float64Array(this._buffer, this.byteOffset + this.position, t); return DataStream.arrayToNative(i, null == e ? this.endianness : e), this.position += 8 * t, i }, DataStream.prototype.mapFloat32Array = function (t, e) { this._realloc(4 * t); var i = new Float32Array(this._buffer, this.byteOffset + this.position, t); return DataStream.arrayToNative(i, null == e ? this.endianness : e), this.position += 4 * t, i }; var MultiBufferStream = function (t) { this.buffers = [], this.bufferIndex = -1, t && (this.insertBuffer(t), this.bufferIndex = 0) }; MultiBufferStream.prototype = new DataStream(new ArrayBuffer, 0, DataStream.BIG_ENDIAN), MultiBufferStream.prototype.initialized = function () { var t; return -1 < this.bufferIndex || (0 < this.buffers.length ? 0 === (t = this.buffers[0]).fileStart ? (this.buffer = t, this.bufferIndex = 0, Log.debug("MultiBufferStream", "Stream ready for parsing"), !0) : (Log.warn("MultiBufferStream", "The first buffer should have a fileStart of 0"), this.logBufferLevel(), !1) : (Log.warn("MultiBufferStream", "No buffer to start parsing from"), this.logBufferLevel(), !1)) }, ArrayBuffer.concat = function (t, e) { Log.debug("ArrayBuffer", "Trying to create a new buffer of size: " + (t.byteLength + e.byteLength)); var i = new Uint8Array(t.byteLength + e.byteLength); return i.set(new Uint8Array(t), 0), i.set(new Uint8Array(e), t.byteLength), i.buffer }, MultiBufferStream.prototype.reduceBuffer = function (t, e, i) { var r = new Uint8Array(i); return r.set(new Uint8Array(t, e, i)), r.buffer.fileStart = t.fileStart + e, r.buffer.usedBytes = 0, r.buffer }, MultiBufferStream.prototype.insertBuffer = function (t) { for (var e = !0, i = 0; i < this.buffers.length; i++) { var r = this.buffers[i]; if (t.fileStart <= r.fileStart) { if (t.fileStart === r.fileStart) { if (t.byteLength > r.byteLength) { this.buffers.splice(i, 1), i--; continue } Log.warn("MultiBufferStream", "Buffer (fileStart: " + t.fileStart + " - Length: " + t.byteLength + ") already appended, ignoring") } else t.fileStart + t.byteLength <= r.fileStart || (t = this.reduceBuffer(t, 0, r.fileStart - t.fileStart)), Log.debug("MultiBufferStream", "Appending new buffer (fileStart: " + t.fileStart + " - Length: " + t.byteLength + ")"), this.buffers.splice(i, 0, t), 0 === i && (this.buffer = t); e = !1; break } if (t.fileStart < r.fileStart + r.byteLength) { var s = r.fileStart + r.byteLength - t.fileStart, r = t.byteLength - s; if (!(0 < r)) { e = !1; break } t = this.reduceBuffer(t, s, r) } } e && (Log.debug("MultiBufferStream", "Appending new buffer (fileStart: " + t.fileStart + " - Length: " + t.byteLength + ")"), this.buffers.push(t), 0 === i && (this.buffer = t)) }, MultiBufferStream.prototype.logBufferLevel = function (t) { for (var e, i, r = [], s = "", a = 0, n = 0, o = 0; o < this.buffers.length; o++)e = this.buffers[o], 0 === o ? (i = {}, r.push(i), i.start = e.fileStart, i.end = e.fileStart + e.byteLength, s += "[" + i.start + "-") : i.end === e.fileStart ? i.end = e.fileStart + e.byteLength : ((i = {}).start = e.fileStart, s += r[r.length - 1].end - 1 + "], [" + i.start + "-", i.end = e.fileStart + e.byteLength, r.push(i)), a += e.usedBytes, n += e.byteLength; 0 < r.length && (s += i.end - 1 + "]"); t = t ? Log.info : Log.debug; 0 === this.buffers.length ? t("MultiBufferStream", "No more buffer in memory") : t("MultiBufferStream", this.buffers.length + " stored buffer(s) (" + a + "/" + n + " bytes), continuous ranges: " + s) }, MultiBufferStream.prototype.cleanBuffers = function () { for (var t, e = 0; e < this.buffers.length; e++)(t = this.buffers[e]).usedBytes === t.byteLength && (Log.debug("MultiBufferStream", "Removing buffer #" + e), this.buffers.splice(e, 1), e--) }, MultiBufferStream.prototype.mergeNextBuffer = function () { var t; if (this.bufferIndex + 1 < this.buffers.length) { if ((t = this.buffers[this.bufferIndex + 1]).fileStart !== this.buffer.fileStart + this.buffer.byteLength) return !1; var e = this.buffer.byteLength, i = this.buffer.usedBytes, r = this.buffer.fileStart; return this.buffers[this.bufferIndex] = ArrayBuffer.concat(this.buffer, t), this.buffer = this.buffers[this.bufferIndex], this.buffers.splice(this.bufferIndex + 1, 1), this.buffer.usedBytes = i, this.buffer.fileStart = r, Log.debug("ISOFile", "Concatenating buffer for box parsing (length: " + e + "->" + this.buffer.byteLength + ")"), !0 } return !1 }, MultiBufferStream.prototype.findPosition = function (t, e, i) { for (var r = null, s = -1, a = !0 === t ? 0 : this.bufferIndex; a < this.buffers.length && (r = this.buffers[a]).fileStart <= e;)s = a, i && (r.fileStart + r.byteLength <= e ? r.usedBytes = r.byteLength : r.usedBytes = e - r.fileStart, this.logBufferLevel()), a++; return -1 !== s && (r = this.buffers[s]).fileStart + r.byteLength >= e ? (Log.debug("MultiBufferStream", "Found position in existing buffer #" + s), s) : -1 }, MultiBufferStream.prototype.findEndContiguousBuf = function (t) { var e, i, t = void 0 !== t ? t : this.bufferIndex, r = this.buffers[t]; if (this.buffers.length > t + 1) for (e = t + 1; e < this.buffers.length && (i = this.buffers[e]).fileStart === r.fileStart + r.byteLength; e++)r = i; return r.fileStart + r.byteLength }, MultiBufferStream.prototype.getEndFilePositionAfter = function (t) { var e = this.findPosition(!0, t, !1); return -1 !== e ? this.findEndContiguousBuf(e) : t }, MultiBufferStream.prototype.addUsedBytes = function (t) { this.buffer.usedBytes += t, this.logBufferLevel() }, MultiBufferStream.prototype.setAllUsedBytes = function () { this.buffer.usedBytes = this.buffer.byteLength, this.logBufferLevel() }, MultiBufferStream.prototype.seek = function (t, e, i) { i = this.findPosition(e, t, i); return -1 !== i ? (this.buffer = this.buffers[i], this.bufferIndex = i, this.position = t - this.buffer.fileStart, Log.debug("MultiBufferStream", "Repositioning parser at buffer position: " + this.position), !0) : (Log.debug("MultiBufferStream", "Position " + t + " not found in buffered data"), !1) }, MultiBufferStream.prototype.getPosition = function () { if (-1 === this.bufferIndex || null === this.buffers[this.bufferIndex]) throw "Error accessing position in the MultiBufferStream"; return this.buffers[this.bufferIndex].fileStart + this.position }, MultiBufferStream.prototype.getLength = function () { return this.byteLength }, MultiBufferStream.prototype.getEndPosition = function () { if (-1 === this.bufferIndex || null === this.buffers[this.bufferIndex]) throw "Error accessing position in the MultiBufferStream"; return this.buffers[this.bufferIndex].fileStart + this.byteLength }, "undefined" != typeof exports && (exports.MultiBufferStream = MultiBufferStream); var MPEG4DescriptorParser = function () { var s = []; s[3] = "ES_Descriptor", s[4] = "DecoderConfigDescriptor", s[5] = "DecoderSpecificInfo", s[6] = "SLConfigDescriptor", this.getDescriptorName = function (t) { return s[t] }; var r = this, a = {}; return this.parseOneDescriptor = function (t) { var e, i = 0, r = t.readUint8(); for (e = t.readUint8(), 0; 128 & e;)i = (127 & e) << 7, e = t.readUint8(), 0; return i += 127 & e, Log.debug("MPEG4DescriptorParser", "Found " + (s[r] || "Descriptor " + r) + ", size " + i + " at position " + t.getPosition()), (r = new (s[r] ? a[s[r]] : a.Descriptor)(i)).parse(t), r }, a.Descriptor = function (t, e) { this.tag = t, this.size = e, this.descs = [] }, a.Descriptor.prototype.parse = function (t) { this.data = t.readUint8Array(this.size) }, a.Descriptor.prototype.findDescriptor = function (t) { for (var e = 0; e < this.descs.length; e++)if (this.descs[e].tag == t) return this.descs[e]; return null }, a.Descriptor.prototype.parseRemainingDescriptors = function (t) { for (var e = t.position; t.position < e + this.size;) { var i = r.parseOneDescriptor(t); this.descs.push(i) } }, a.ES_Descriptor = function (t) { a.Descriptor.call(this, 3, t) }, a.ES_Descriptor.prototype = new a.Descriptor, a.ES_Descriptor.prototype.parse = function (t) { var e; this.ES_ID = t.readUint16(), this.flags = t.readUint8(), this.size -= 3, 128 & this.flags ? (this.dependsOn_ES_ID = t.readUint16(), this.size -= 2) : this.dependsOn_ES_ID = 0, 64 & this.flags ? (e = t.readUint8(), this.URL = t.readString(e), this.size -= e + 1) : this.URL = "", 32 & this.flags ? (this.OCR_ES_ID = t.readUint16(), this.size -= 2) : this.OCR_ES_ID = 0, this.parseRemainingDescriptors(t) }, a.ES_Descriptor.prototype.getOTI = function (t) { var e = this.findDescriptor(4); return e ? e.oti : 0 }, a.ES_Descriptor.prototype.getAudioConfig = function (t) { var e = this.findDescriptor(4); if (!e) return null; var i = e.findDescriptor(5); if (i && i.data) { e = (248 & i.data[0]) >> 3; return 31 === e && 2 <= i.data.length && (e = 32 + ((7 & i.data[0]) << 3) + ((224 & i.data[1]) >> 5)), e } return null }, a.DecoderConfigDescriptor = function (t) { a.Descriptor.call(this, 4, t) }, a.DecoderConfigDescriptor.prototype = new a.Descriptor, a.DecoderConfigDescriptor.prototype.parse = function (t) { this.oti = t.readUint8(), this.streamType = t.readUint8(), this.bufferSize = t.readUint24(), this.maxBitrate = t.readUint32(), this.avgBitrate = t.readUint32(), this.size -= 13, this.parseRemainingDescriptors(t) }, a.DecoderSpecificInfo = function (t) { a.Descriptor.call(this, 5, t) }, a.DecoderSpecificInfo.prototype = new a.Descriptor, a.SLConfigDescriptor = function (t) { a.Descriptor.call(this, 6, t) }, a.SLConfigDescriptor.prototype = new a.Descriptor, this }; "undefined" != typeof exports && (exports.MPEG4DescriptorParser = MPEG4DescriptorParser); var BoxParser = { ERR_INVALID_DATA: -1, ERR_NOT_ENOUGH_DATA: 0, OK: 1, BASIC_BOXES: ["mdat", "idat", "free", "skip", "meco", "strk"], FULL_BOXES: ["hmhd", "nmhd", "iods", "xml ", "bxml", "ipro", "mere"], CONTAINER_BOXES: [["moov", ["trak", "pssh"]], ["trak"], ["edts"], ["mdia"], ["minf"], ["dinf"], ["stbl", ["sgpd", "sbgp"]], ["mvex", ["trex"]], ["moof", ["traf"]], ["traf", ["trun", "sgpd", "sbgp"]], ["vttc"], ["tref"], ["iref"], ["mfra", ["tfra"]], ["meco"], ["hnti"], ["hinf"], ["strk"], ["strd"], ["sinf"], ["rinf"], ["schi"], ["trgr"], ["udta", ["kind"]], ["iprp", ["ipma"]], ["ipco"]], boxCodes: [], fullBoxCodes: [], containerBoxCodes: [], sampleEntryCodes: {}, sampleGroupEntryCodes: [], trackGroupTypes: [], UUIDBoxes: {}, UUIDs: [], initialize: function () { BoxParser.FullBox.prototype = new BoxParser.Box, BoxParser.ContainerBox.prototype = new BoxParser.Box, BoxParser.SampleEntry.prototype = new BoxParser.Box, BoxParser.TrackGroupTypeBox.prototype = new BoxParser.FullBox, BoxParser.BASIC_BOXES.forEach(function (t) { BoxParser.createBoxCtor(t) }), BoxParser.FULL_BOXES.forEach(function (t) { BoxParser.createFullBoxCtor(t) }), BoxParser.CONTAINER_BOXES.forEach(function (t) { BoxParser.createContainerBoxCtor(t[0], null, t[1]) }) }, Box: function (t, e, i) { this.type = t, this.size = e, this.uuid = i }, FullBox: function (t, e, i) { BoxParser.Box.call(this, t, e, i), this.flags = 0, this.version = 0 }, ContainerBox: function (t, e, i) { BoxParser.Box.call(this, t, e, i), this.boxes = [] }, SampleEntry: function (t, e, i, r) { BoxParser.ContainerBox.call(this, t, e), this.hdr_size = i, this.start = r }, SampleGroupEntry: function (t) { this.grouping_type = t }, TrackGroupTypeBox: function (t, e) { BoxParser.FullBox.call(this, t, e) }, createBoxCtor: function (e, t) { BoxParser.boxCodes.push(e), BoxParser[e + "Box"] = function (t) { BoxParser.Box.call(this, e, t) }, BoxParser[e + "Box"].prototype = new BoxParser.Box, t && (BoxParser[e + "Box"].prototype.parse = t) }, createFullBoxCtor: function (e, i) { BoxParser[e + "Box"] = function (t) { BoxParser.FullBox.call(this, e, t) }, BoxParser[e + "Box"].prototype = new BoxParser.FullBox, BoxParser[e + "Box"].prototype.parse = function (t) { this.parseFullHeader(t), i && i.call(this, t) } }, addSubBoxArrays: function (t) { if (t) for (var e = (this.subBoxNames = t).length, i = 0; i < e; i++)this[t[i] + "s"] = [] }, createContainerBoxCtor: function (e, t, i) { BoxParser[e + "Box"] = function (t) { BoxParser.ContainerBox.call(this, e, t), BoxParser.addSubBoxArrays.call(this, i) }, BoxParser[e + "Box"].prototype = new BoxParser.ContainerBox, t && (BoxParser[e + "Box"].prototype.parse = t) }, createMediaSampleEntryCtor: function (t, e, i) { BoxParser.sampleEntryCodes[t] = [], BoxParser[t + "SampleEntry"] = function (t, e) { BoxParser.SampleEntry.call(this, t, e), BoxParser.addSubBoxArrays.call(this, i) }, BoxParser[t + "SampleEntry"].prototype = new BoxParser.SampleEntry, e && (BoxParser[t + "SampleEntry"].prototype.parse = e) }, createSampleEntryCtor: function (e, i, t, r) { BoxParser.sampleEntryCodes[e].push(i), BoxParser[i + "SampleEntry"] = function (t) { BoxParser[e + "SampleEntry"].call(this, i, t), BoxParser.addSubBoxArrays.call(this, r) }, BoxParser[i + "SampleEntry"].prototype = new BoxParser[e + "SampleEntry"], t && (BoxParser[i + "SampleEntry"].prototype.parse = t) }, createEncryptedSampleEntryCtor: function (t, e, i) { BoxParser.createSampleEntryCtor.call(this, t, e, i, ["sinf"]) }, createSampleGroupCtor: function (e, t) { BoxParser[e + "SampleGroupEntry"] = function (t) { BoxParser.SampleGroupEntry.call(this, e, t) }, BoxParser[e + "SampleGroupEntry"].prototype = new BoxParser.SampleGroupEntry, t && (BoxParser[e + "SampleGroupEntry"].prototype.parse = t) }, createTrackGroupCtor: function (e, t) { BoxParser[e + "TrackGroupTypeBox"] = function (t) { BoxParser.TrackGroupTypeBox.call(this, e, t) }, BoxParser[e + "TrackGroupTypeBox"].prototype = new BoxParser.TrackGroupTypeBox, t && (BoxParser[e + "TrackGroupTypeBox"].prototype.parse = t) }, createUUIDBox: function (e, i, r, s) { BoxParser.UUIDs.push(e), BoxParser.UUIDBoxes[e] = function (t) { (i ? BoxParser.FullBox : r ? BoxParser.ContainerBox : BoxParser.Box).call(this, "uuid", t, e) }, BoxParser.UUIDBoxes[e].prototype = new (i ? BoxParser.FullBox : r ? BoxParser.ContainerBox : BoxParser.Box), s && (BoxParser.UUIDBoxes[e].prototype.parse = i ? function (t) { this.parseFullHeader(t), s && s.call(this, t) } : s) } }; BoxParser.initialize(), BoxParser.TKHD_FLAG_ENABLED = 1, BoxParser.TKHD_FLAG_IN_MOVIE = 2, BoxParser.TKHD_FLAG_IN_PREVIEW = 4, BoxParser.TFHD_FLAG_BASE_DATA_OFFSET = 1, BoxParser.TFHD_FLAG_SAMPLE_DESC = 2, BoxParser.TFHD_FLAG_SAMPLE_DUR = 8, BoxParser.TFHD_FLAG_SAMPLE_SIZE = 16, BoxParser.TFHD_FLAG_SAMPLE_FLAGS = 32, BoxParser.TFHD_FLAG_DUR_EMPTY = 65536, BoxParser.TFHD_FLAG_DEFAULT_BASE_IS_MOOF = 131072, BoxParser.TRUN_FLAGS_DATA_OFFSET = 1, BoxParser.TRUN_FLAGS_FIRST_FLAG = 4, BoxParser.TRUN_FLAGS_DURATION = 256, BoxParser.TRUN_FLAGS_SIZE = 512, BoxParser.TRUN_FLAGS_FLAGS = 1024, BoxParser.TRUN_FLAGS_CTS_OFFSET = 2048, BoxParser.Box.prototype.add = function (t) { return this.addBox(new BoxParser[t + "Box"]) }, BoxParser.Box.prototype.addBox = function (t) { return this.boxes.push(t), this[t.type + "s"] ? this[t.type + "s"].push(t) : this[t.type] = t, t }, BoxParser.Box.prototype.set = function (t, e) { return this[t] = e, this }, BoxParser.Box.prototype.addEntry = function (t, e) { e = e || "entries"; return this[e] || (this[e] = []), this[e].push(t), this }, "undefined" != typeof exports && (exports.BoxParser = BoxParser), BoxParser.parseUUID = function (t) { return BoxParser.parseHex16(t) }, BoxParser.parseHex16 = function (t) { for (var e = "", i = 0; i < 16; i++) { var r = t.readUint8().toString(16); e += 1 === r.length ? "0" + r : r } return e }, BoxParser.parseOneBox = function (t, e, i) { var r, s, a = t.getPosition(), n = 0; if (t.getEndPosition() - a < 8) return Log.debug("BoxParser", "Not enough data in stream to parse the type and size of the box"), { code: BoxParser.ERR_NOT_ENOUGH_DATA }; if (i && i < 8) return Log.debug("BoxParser", "Not enough bytes left in the parent box to parse a new box"), { code: BoxParser.ERR_NOT_ENOUGH_DATA }; var o = t.readUint32(), h = t.readString(4), d = h; if (Log.debug("BoxParser", "Found box of type '" + h + "' and size " + o + " at position " + a), n = 8, "uuid" == h) { if (t.getEndPosition() - t.getPosition() < 16 || i - n < 16) return t.seek(a), Log.debug("BoxParser", "Not enough bytes left in the parent box to parse a UUID box"), { code: BoxParser.ERR_NOT_ENOUGH_DATA }; n += 16, d = s = BoxParser.parseUUID(t) } if (1 == o) { if (t.getEndPosition() - t.getPosition() < 8 || i && i - n < 8) return t.seek(a), Log.warn("BoxParser", 'Not enough data in stream to parse the extended size of the "' + h + '" box'), { code: BoxParser.ERR_NOT_ENOUGH_DATA }; o = t.readUint64(), n += 8 } else if (0 === o) if (i) o = i; else if ("mdat" !== h) return Log.error("BoxParser", "Unlimited box size not supported for type: '" + h + "'"), r = new BoxParser.Box(h, o), { code: BoxParser.OK, box: r, size: r.size }; return 0 !== o && o < n ? (Log.error("BoxParser", "Box of type " + h + " has an invalid size " + o + " (too small to be a box)"), { code: BoxParser.ERR_NOT_ENOUGH_DATA, type: h, size: o, hdr_size: n, start: a }) : 0 !== o && i && i < o ? (Log.error("BoxParser", "Box of type '" + h + "' has a size " + o + " greater than its container size " + i), { code: BoxParser.ERR_NOT_ENOUGH_DATA, type: h, size: o, hdr_size: n, start: a }) : 0 !== o && a + o > t.getEndPosition() ? (t.seek(a), Log.info("BoxParser", "Not enough data in stream to parse the entire '" + h + "' box"), { code: BoxParser.ERR_NOT_ENOUGH_DATA, type: h, size: o, hdr_size: n, start: a }) : e ? { code: BoxParser.OK, type: h, size: o, hdr_size: n, start: a } : (BoxParser[h + "Box"] ? r = new BoxParser[h + "Box"](o) : "uuid" !== h ? (Log.warn("BoxParser", "Unknown box type: '" + h + "'"), (r = new BoxParser.Box(h, o)).has_unparsed_data = !0) : BoxParser.UUIDBoxes[s] ? r = new BoxParser.UUIDBoxes[s](o) : (Log.warn("BoxParser", "Unknown uuid type: '" + s + "'"), (r = new BoxParser.Box(h, o)).uuid = s, r.has_unparsed_data = !0), r.hdr_size = n, r.start = a, r.write === BoxParser.Box.prototype.write && "mdat" !== r.type && (Log.info("BoxParser", "'" + d + "' box writing not yet implemented, keeping unparsed data in memory for later write"), r.parseDataAndRewind(t)), r.parse(t), (a = t.getPosition() - (r.start + r.size)) < 0 ? (Log.warn("BoxParser", "Parsing of box '" + d + "' did not read the entire indicated box data size (missing " + -a + " bytes), seeking forward"), t.seek(r.start + r.size)) : 0 < a && (Log.error("BoxParser", "Parsing of box '" + d + "' read " + a + " more bytes than the indicated box data size, seeking backwards"), 0 !== r.size && t.seek(r.start + r.size)), { code: BoxParser.OK, box: r, size: r.size }) }, BoxParser.Box.prototype.parse = function (t) { "mdat" != this.type ? this.data = t.readUint8Array(this.size - this.hdr_size) : 0 === this.size ? t.seek(t.getEndPosition()) : t.seek(this.start + this.size) }, BoxParser.Box.prototype.parseDataAndRewind = function (t) { this.data = t.readUint8Array(this.size - this.hdr_size), t.position -= this.size - this.hdr_size }, BoxParser.FullBox.prototype.parseDataAndRewind = function (t) { this.parseFullHeader(t), this.data = t.readUint8Array(this.size - this.hdr_size), this.hdr_size -= 4, t.position -= this.size - this.hdr_size }, BoxParser.FullBox.prototype.parseFullHeader = function (t) { this.version = t.readUint8(), this.flags = t.readUint24(), this.hdr_size += 4 }, BoxParser.FullBox.prototype.parse = function (t) { this.parseFullHeader(t), this.data = t.readUint8Array(this.size - this.hdr_size) }, BoxParser.ContainerBox.prototype.parse = function (t) { for (; t.getPosition() < this.start + this.size;) { if ((e = BoxParser.parseOneBox(t, !1, this.size - (t.getPosition() - this.start))).code !== BoxParser.OK) return; var e, i = e.box; this.boxes.push(i), this.subBoxNames && -1 != this.subBoxNames.indexOf(i.type) ? this[this.subBoxNames[this.subBoxNames.indexOf(i.type)] + "s"].push(i) : this[e = "uuid" !== i.type ? i.type : i.uuid] ? Log.warn("Box of type " + e + " already stored in field of this type") : this[e] = i } }, BoxParser.Box.prototype.parseLanguage = function (t) { this.language = t.readUint16(); t = []; t[0] = this.language >> 10 & 31, t[1] = this.language >> 5 & 31, t[2] = 31 & this.language, this.languageString = String.fromCharCode(t[0] + 96, t[1] + 96, t[2] + 96) }, BoxParser.SAMPLE_ENTRY_TYPE_VISUAL = "Visual", BoxParser.SAMPLE_ENTRY_TYPE_AUDIO = "Audio", BoxParser.SAMPLE_ENTRY_TYPE_HINT = "Hint", BoxParser.SAMPLE_ENTRY_TYPE_METADATA = "Metadata", BoxParser.SAMPLE_ENTRY_TYPE_SUBTITLE = "Subtitle", BoxParser.SAMPLE_ENTRY_TYPE_SYSTEM = "System", BoxParser.SAMPLE_ENTRY_TYPE_TEXT = "Text", BoxParser.SampleEntry.prototype.parseHeader = function (t) { t.readUint8Array(6), this.data_reference_index = t.readUint16(), this.hdr_size += 8 }, BoxParser.SampleEntry.prototype.parse = function (t) { this.parseHeader(t), this.data = t.readUint8Array(this.size - this.hdr_size) }, BoxParser.SampleEntry.prototype.parseDataAndRewind = function (t) { this.parseHeader(t), this.data = t.readUint8Array(this.size - this.hdr_size), this.hdr_size -= 8, t.position -= this.size - this.hdr_size }, BoxParser.SampleEntry.prototype.parseFooter = function (t) { BoxParser.ContainerBox.prototype.parse.call(this, t) }, BoxParser.createMediaSampleEntryCtor(BoxParser.SAMPLE_ENTRY_TYPE_HINT), BoxParser.createMediaSampleEntryCtor(BoxParser.SAMPLE_ENTRY_TYPE_METADATA), BoxParser.createMediaSampleEntryCtor(BoxParser.SAMPLE_ENTRY_TYPE_SUBTITLE), BoxParser.createMediaSampleEntryCtor(BoxParser.SAMPLE_ENTRY_TYPE_SYSTEM), BoxParser.createMediaSampleEntryCtor(BoxParser.SAMPLE_ENTRY_TYPE_TEXT), BoxParser.createMediaSampleEntryCtor(BoxParser.SAMPLE_ENTRY_TYPE_VISUAL, function (t) { var e; this.parseHeader(t), t.readUint16(), t.readUint16(), t.readUint32Array(3), this.width = t.readUint16(), this.height = t.readUint16(), this.horizresolution = t.readUint32(), this.vertresolution = t.readUint32(), t.readUint32(), this.frame_count = t.readUint16(), e = Math.min(31, t.readUint8()), this.compressorname = t.readString(e), e < 31 && t.readString(31 - e), this.depth = t.readUint16(), t.readUint16(), this.parseFooter(t) }), BoxParser.createMediaSampleEntryCtor(BoxParser.SAMPLE_ENTRY_TYPE_AUDIO, function (t) { this.parseHeader(t), t.readUint32Array(2), this.channel_count = t.readUint16(), this.samplesize = t.readUint16(), t.readUint16(), t.readUint16(), this.samplerate = t.readUint32() / 65536, this.parseFooter(t) }), BoxParser.createSampleEntryCtor(BoxParser.SAMPLE_ENTRY_TYPE_VISUAL, "avc1"), BoxParser.createSampleEntryCtor(BoxParser.SAMPLE_ENTRY_TYPE_VISUAL, "avc2"), BoxParser.createSampleEntryCtor(BoxParser.SAMPLE_ENTRY_TYPE_VISUAL, "avc3"), BoxParser.createSampleEntryCtor(BoxParser.SAMPLE_ENTRY_TYPE_VISUAL, "avc4"), BoxParser.createSampleEntryCtor(BoxParser.SAMPLE_ENTRY_TYPE_VISUAL, "av01"), BoxParser.createSampleEntryCtor(BoxParser.SAMPLE_ENTRY_TYPE_VISUAL, "hvc1"), BoxParser.createSampleEntryCtor(BoxParser.SAMPLE_ENTRY_TYPE_VISUAL, "hev1"), BoxParser.createSampleEntryCtor(BoxParser.SAMPLE_ENTRY_TYPE_VISUAL, "vvc1"), BoxParser.createSampleEntryCtor(BoxParser.SAMPLE_ENTRY_TYPE_VISUAL, "vvi1"), BoxParser.createSampleEntryCtor(BoxParser.SAMPLE_ENTRY_TYPE_VISUAL, "vvs1"), BoxParser.createSampleEntryCtor(BoxParser.SAMPLE_ENTRY_TYPE_VISUAL, "vvcN"), BoxParser.createSampleEntryCtor(BoxParser.SAMPLE_ENTRY_TYPE_VISUAL, "vp08"), BoxParser.createSampleEntryCtor(BoxParser.SAMPLE_ENTRY_TYPE_VISUAL, "vp09"), BoxParser.createSampleEntryCtor(BoxParser.SAMPLE_ENTRY_TYPE_AUDIO, "mp4a"), BoxParser.createSampleEntryCtor(BoxParser.SAMPLE_ENTRY_TYPE_AUDIO, "ac-3"), BoxParser.createSampleEntryCtor(BoxParser.SAMPLE_ENTRY_TYPE_AUDIO, "ec-3"), BoxParser.createSampleEntryCtor(BoxParser.SAMPLE_ENTRY_TYPE_AUDIO, "Opus"), BoxParser.createEncryptedSampleEntryCtor(BoxParser.SAMPLE_ENTRY_TYPE_VISUAL, "encv"), BoxParser.createEncryptedSampleEntryCtor(BoxParser.SAMPLE_ENTRY_TYPE_AUDIO, "enca"), BoxParser.createEncryptedSampleEntryCtor(BoxParser.SAMPLE_ENTRY_TYPE_SUBTITLE, "encu"), BoxParser.createEncryptedSampleEntryCtor(BoxParser.SAMPLE_ENTRY_TYPE_SYSTEM, "encs"), BoxParser.createEncryptedSampleEntryCtor(BoxParser.SAMPLE_ENTRY_TYPE_TEXT, "enct"), BoxParser.createEncryptedSampleEntryCtor(BoxParser.SAMPLE_ENTRY_TYPE_METADATA, "encm"), BoxParser.createBoxCtor("a1lx", function (t) { var e = 16 * (1 + (1 & (1 & t.readUint8()))); this.layer_size = []; for (var i = 0; i < 3; i++)this.layer_size[i] = 16 == e ? t.readUint16() : t.readUint32() }), BoxParser.createBoxCtor("a1op", function (t) { this.op_index = t.readUint8() }), BoxParser.createFullBoxCtor("auxC", function (t) { this.aux_type = t.readCString(); var e = this.size - this.hdr_size - (this.aux_type.length + 1); this.aux_subtype = t.readUint8Array(e) }), BoxParser.createBoxCtor("av1C", function (t) { var e = t.readUint8(); if (e >> 7 & !1) Log.error("av1C marker problem"); else if (this.version = 127 & e, 1 === this.version) if (e = t.readUint8(), this.seq_profile = e >> 5 & 7, this.seq_level_idx_0 = 31 & e, e = t.readUint8(), this.seq_tier_0 = e >> 7 & 1, this.high_bitdepth = e >> 6 & 1, this.twelve_bit = e >> 5 & 1, this.monochrome = e >> 4 & 1, this.chroma_subsampling_x = e >> 3 & 1, this.chroma_subsampling_y = e >> 2 & 1, this.chroma_sample_position = 3 & e, e = t.readUint8(), this.reserved_1 = e >> 5 & 7, 0 === this.reserved_1) { if (this.initial_presentation_delay_present = e >> 4 & 1, 1 === this.initial_presentation_delay_present) this.initial_presentation_delay_minus_one = 15 & e; else if (this.reserved_2 = 15 & e, 0 !== this.reserved_2) return void Log.error("av1C reserved_2 parsing problem"); e = this.size - this.hdr_size - 4; this.configOBUs = t.readUint8Array(e) } else Log.error("av1C reserved_1 parsing problem"); else Log.error("av1C version " + this.version + " not supported") }), BoxParser.createBoxCtor("avcC", function (t) { var e, i; for (this.configurationVersion = t.readUint8(), this.AVCProfileIndication = t.readUint8(), this.profile_compatibility = t.readUint8(), this.AVCLevelIndication = t.readUint8(), this.lengthSizeMinusOne = 3 & t.readUint8(), this.nb_SPS_nalus = 31 & t.readUint8(), i = this.size - this.hdr_size - 6, this.SPS = [], e = 0; e < this.nb_SPS_nalus; e++)this.SPS[e] = {}, this.SPS[e].length = t.readUint16(), this.SPS[e].nalu = t.readUint8Array(this.SPS[e].length), i -= 2 + this.SPS[e].length; for (this.nb_PPS_nalus = t.readUint8(), i--, this.PPS = [], e = 0; e < this.nb_PPS_nalus; e++)this.PPS[e] = {}, this.PPS[e].length = t.readUint16(), this.PPS[e].nalu = t.readUint8Array(this.PPS[e].length), i -= 2 + this.PPS[e].length; 0 < i && (this.ext = t.readUint8Array(i)) }), BoxParser.createBoxCtor("btrt", function (t) { this.bufferSizeDB = t.readUint32(), this.maxBitrate = t.readUint32(), this.avgBitrate = t.readUint32() }), BoxParser.createBoxCtor("clap", function (t) { this.cleanApertureWidthN = t.readUint32(), this.cleanApertureWidthD = t.readUint32(), this.cleanApertureHeightN = t.readUint32(), this.cleanApertureHeightD = t.readUint32(), this.horizOffN = t.readUint32(), this.horizOffD = t.readUint32(), this.vertOffN = t.readUint32(), this.vertOffD = t.readUint32() }), BoxParser.createBoxCtor("clli", function (t) { this.max_content_light_level = t.readUint16(), this.max_pic_average_light_level = t.readUint16() }), BoxParser.createFullBoxCtor("co64", function (t) { var e, i = t.readUint32(); if (this.chunk_offsets = [], 0 === this.version) for (e = 0; e < i; e++)this.chunk_offsets.push(t.readUint64()) }), BoxParser.createFullBoxCtor("CoLL", function (t) { this.maxCLL = t.readUint16(), this.maxFALL = t.readUint16() }), BoxParser.createBoxCtor("colr", function (t) { var e; this.colour_type = t.readString(4), "nclx" === this.colour_type ? (this.colour_primaries = t.readUint16(), this.transfer_characteristics = t.readUint16(), this.matrix_coefficients = t.readUint16(), e = t.readUint8(), this.full_range_flag = e >> 7) : "rICC" !== this.colour_type && "prof" !== this.colour_type || (this.ICC_profile = t.readUint8Array(this.size - 4)) }), BoxParser.createFullBoxCtor("cprt", function (t) { this.parseLanguage(t), this.notice = t.readCString() }), BoxParser.createFullBoxCtor("cslg", function (t) { 0 === this.version && (this.compositionToDTSShift = t.readInt32(), this.leastDecodeToDisplayDelta = t.readInt32(), this.greatestDecodeToDisplayDelta = t.readInt32(), this.compositionStartTime = t.readInt32(), this.compositionEndTime = t.readInt32()) }), BoxParser.createFullBoxCtor("ctts", function (t) { var e, i = t.readUint32(); if (this.sample_counts = [], this.sample_offsets = [], 0 === this.version) for (e = 0; e < i; e++) { this.sample_counts.push(t.readUint32()); var r = t.readInt32(); r < 0 && Log.warn("BoxParser", "ctts box uses negative values without using version 1"), this.sample_offsets.push(r) } else if (1 == this.version) for (e = 0; e < i; e++)this.sample_counts.push(t.readUint32()), this.sample_offsets.push(t.readInt32()) }), BoxParser.createBoxCtor("dac3", function (t) { var e = t.readUint8(), i = t.readUint8(), t = t.readUint8(); this.fscod = e >> 6, this.bsid = e >> 1 & 31, this.bsmod = (1 & e) << 2 | i >> 6 & 3, this.acmod = i >> 3 & 7, this.lfeon = i >> 2 & 1, this.bit_rate_code = 3 & i | t >> 5 & 7 }), BoxParser.createBoxCtor("dec3", function (t) { var e = t.readUint16(); this.data_rate = e >> 3, this.num_ind_sub = 7 & e, this.ind_subs = []; for (var i = 0; i < this.num_ind_sub + 1; i++) { var r = {}; this.ind_subs.push(r); var s = t.readUint8(), a = t.readUint8(), n = t.readUint8(); r.fscod = s >> 6, r.bsid = s >> 1 & 31, r.bsmod = (1 & s) << 4 | a >> 4 & 15, r.acmod = a >> 1 & 7, r.lfeon = 1 & a, r.num_dep_sub = n >> 1 & 15, 0 < r.num_dep_sub && (r.chan_loc = (1 & n) << 8 | t.readUint8()) } }), BoxParser.createFullBoxCtor("dfLa", function (t) { var e = [], i = ["STREAMINFO", "PADDING", "APPLICATION", "SEEKTABLE", "VORBIS_COMMENT", "CUESHEET", "PICTURE", "RESERVED"]; for (this.parseFullHeader(t); ;) { var r = t.readUint8(), s = Math.min(127 & r, i.length - 1); if (s ? t.readUint8Array(t.readUint24()) : (t.readUint8Array(13), this.samplerate = t.readUint32() >> 12, t.readUint8Array(20)), e.push(i[s]), 128 & r) break } this.numMetadataBlocks = e.length + " (" + e.join(", ") + ")" }), BoxParser.createBoxCtor("dimm", function (t) { this.bytessent = t.readUint64() }), BoxParser.createBoxCtor("dmax", function (t) { this.time = t.readUint32() }), BoxParser.createBoxCtor("dmed", function (t) { this.bytessent = t.readUint64() }), BoxParser.createBoxCtor("dOps", function (t) { if (this.Version = t.readUint8(), this.OutputChannelCount = t.readUint8(), this.PreSkip = t.readUint16(), this.InputSampleRate = t.readUint32(), this.OutputGain = t.readInt16(), this.ChannelMappingFamily = t.readUint8(), 0 !== this.ChannelMappingFamily) { this.StreamCount = t.readUint8(), this.CoupledCount = t.readUint8(), this.ChannelMapping = []; for (var e = 0; e < this.OutputChannelCount; e++)this.ChannelMapping[e] = t.readUint8() } }), BoxParser.createFullBoxCtor("dref", function (t) { var e; this.entries = []; for (var i = t.readUint32(), r = 0; r < i; r++) { if ((e = BoxParser.parseOneBox(t, !1, this.size - (t.getPosition() - this.start))).code !== BoxParser.OK) return; e = e.box, this.entries.push(e) } }), BoxParser.createBoxCtor("drep", function (t) { this.bytessent = t.readUint64() }), BoxParser.createFullBoxCtor("elng", function (t) { this.extended_language = t.readString(this.size - this.hdr_size) }), BoxParser.createFullBoxCtor("elst", function (t) { this.entries = []; for (var e = t.readUint32(), i = 0; i < e; i++) { var r = {}; this.entries.push(r), 1 === this.version ? (r.segment_duration = t.readUint64(), r.media_time = t.readInt64()) : (r.segment_duration = t.readUint32(), r.media_time = t.readInt32()), r.media_rate_integer = t.readInt16(), r.media_rate_fraction = t.readInt16() } }), BoxParser.createFullBoxCtor("emsg", function (t) { 1 == this.version ? (this.timescale = t.readUint32(), this.presentation_time = t.readUint64(), this.event_duration = t.readUint32(), this.id = t.readUint32(), this.scheme_id_uri = t.readCString(), this.value = t.readCString()) : (this.scheme_id_uri = t.readCString(), this.value = t.readCString(), this.timescale = t.readUint32(), this.presentation_time_delta = t.readUint32(), this.event_duration = t.readUint32(), this.id = t.readUint32()); var e = this.size - this.hdr_size - (16 + (this.scheme_id_uri.length + 1) + (this.value.length + 1)); 1 == this.version && (e -= 4), this.message_data = t.readUint8Array(e) }), BoxParser.createFullBoxCtor("esds", function (t) { var e = t.readUint8Array(this.size - this.hdr_size); void 0 !== MPEG4DescriptorParser && (t = new MPEG4DescriptorParser, this.esd = t.parseOneDescriptor(new DataStream(e.buffer, 0, DataStream.BIG_ENDIAN))) }), BoxParser.createBoxCtor("fiel", function (t) { this.fieldCount = t.readUint8(), this.fieldOrdering = t.readUint8() }), BoxParser.createBoxCtor("frma", function (t) { this.data_format = t.readString(4) }), BoxParser.createBoxCtor("ftyp", function (t) { var e = this.size - this.hdr_size; this.major_brand = t.readString(4), this.minor_version = t.readUint32(), e -= 8, this.compatible_brands = []; for (var i = 0; 4 <= e;)this.compatible_brands[i] = t.readString(4), e -= 4, i++ }), BoxParser.createFullBoxCtor("hdlr", function (t) { 0 === this.version && (t.readUint32(), this.handler = t.readString(4), t.readUint32Array(3), this.name = t.readString(this.size - this.hdr_size - 20), "\0" === this.name[this.name.length - 1] && (this.name = this.name.slice(0, -1))) }), BoxParser.createBoxCtor("hvcC", function (t) { var e, i; this.configurationVersion = t.readUint8(), i = t.readUint8(), this.general_profile_space = i >> 6, this.general_tier_flag = (32 & i) >> 5, this.general_profile_idc = 31 & i, this.general_profile_compatibility = t.readUint32(), this.general_constraint_indicator = t.readUint8Array(6), this.general_level_idc = t.readUint8(), this.min_spatial_segmentation_idc = 4095 & t.readUint16(), this.parallelismType = 3 & t.readUint8(), this.chroma_format_idc = 3 & t.readUint8(), this.bit_depth_luma_minus8 = 7 & t.readUint8(), this.bit_depth_chroma_minus8 = 7 & t.readUint8(), this.avgFrameRate = t.readUint16(), i = t.readUint8(), this.constantFrameRate = i >> 6, this.numTemporalLayers = (13 & i) >> 3, this.temporalIdNested = (4 & i) >> 2, this.lengthSizeMinusOne = 3 & i, this.nalu_arrays = []; for (var r = t.readUint8(), s = 0; s < r; s++) { var a = []; this.nalu_arrays.push(a), i = t.readUint8(), a.completeness = (128 & i) >> 7, a.nalu_type = 63 & i; for (var n = t.readUint16(), o = 0; o < n; o++) { var h = {}; a.push(h), e = t.readUint16(), h.data = t.readUint8Array(e) } } }), BoxParser.createFullBoxCtor("iinf", function (t) { var e; 0 === this.version ? this.entry_count = t.readUint16() : this.entry_count = t.readUint32(), this.item_infos = []; for (var i = 0; i < this.entry_count; i++) { if ((e = BoxParser.parseOneBox(t, !1, this.size - (t.getPosition() - this.start))).code !== BoxParser.OK) return; "infe" !== e.box.type && Log.error("BoxParser", "Expected 'infe' box, got " + e.box.type), this.item_infos[i] = e.box } }), BoxParser.createFullBoxCtor("iloc", function (t) { var e = t.readUint8(); this.offset_size = e >> 4 & 15, this.length_size = 15 & e, e = t.readUint8(), this.base_offset_size = e >> 4 & 15, 1 === this.version || 2 === this.version ? this.index_size = 15 & e : this.index_size = 0, this.items = []; var i = 0; if (this.version < 2) i = t.readUint16(); else { if (2 !== this.version) throw "version of iloc box not supported"; i = t.readUint32() } for (var r = 0; r < i; r++) { var s = {}; if (this.items.push(s), this.version < 2) s.item_ID = t.readUint16(); else { if (2 !== this.version) throw "version of iloc box not supported"; s.item_ID = t.readUint16() } switch (1 === this.version || 2 === this.version ? s.construction_method = 15 & t.readUint16() : s.construction_method = 0, s.data_reference_index = t.readUint16(), this.base_offset_size) { case 0: s.base_offset = 0; break; case 4: s.base_offset = t.readUint32(); break; case 8: s.base_offset = t.readUint64(); break; default: throw "Error reading base offset size" }var a = t.readUint16(); s.extents = []; for (var n = 0; n < a; n++) { var o = {}; if (s.extents.push(o), 1 === this.version || 2 === this.version) switch (this.index_size) { case 0: o.extent_index = 0; break; case 4: o.extent_index = t.readUint32(); break; case 8: o.extent_index = t.readUint64(); break; default: throw "Error reading extent index" }switch (this.offset_size) { case 0: o.extent_offset = 0; break; case 4: o.extent_offset = t.readUint32(); break; case 8: o.extent_offset = t.readUint64(); break; default: throw "Error reading extent index" }switch (this.length_size) { case 0: o.extent_length = 0; break; case 4: o.extent_length = t.readUint32(); break; case 8: o.extent_length = t.readUint64(); break; default: throw "Error reading extent index" } } } }), BoxParser.createBoxCtor("imir", function (t) { t = t.readUint8(); this.reserved = t >> 7, this.axis = 1 & t }), BoxParser.createFullBoxCtor("infe", function (t) { return 0 !== this.version && 1 !== this.version || (this.item_ID = t.readUint16(), this.item_protection_index = t.readUint16(), this.item_name = t.readCString(), this.content_type = t.readCString(), this.content_encoding = t.readCString()), 1 === this.version ? (this.extension_type = t.readString(4), Log.warn("BoxParser", "Cannot parse extension type"), void t.seek(this.start + this.size)) : void (2 <= this.version && (2 === this.version ? this.item_ID = t.readUint16() : 3 === this.version && (this.item_ID = t.readUint32()), this.item_protection_index = t.readUint16(), this.item_type = t.readString(4), this.item_name = t.readCString(), "mime" === this.item_type ? (this.content_type = t.readCString(), this.content_encoding = t.readCString()) : "uri " === this.item_type && (this.item_uri_type = t.readCString()))) }), BoxParser.createFullBoxCtor("ipma", function (t) { var e, i; for (entry_count = t.readUint32(), this.associations = [], e = 0; e < entry_count; e++) { var r = {}; this.associations.push(r), this.version < 1 ? r.id = t.readUint16() : r.id = t.readUint32(); var s = t.readUint8(); for (r.props = [], i = 0; i < s; i++) { var a = t.readUint8(), n = {}; r.props.push(n), n.essential = (128 & a) >> 7 == 1, 1 & this.flags ? n.property_index = (127 & a) << 8 | t.readUint8() : n.property_index = 127 & a } } }), BoxParser.createFullBoxCtor("iref", function (t) { var e; for (this.references = []; t.getPosition() < this.start + this.size;) { if ((e = BoxParser.parseOneBox(t, !0, this.size - (t.getPosition() - this.start))).code !== BoxParser.OK) return; (e = new (0 === this.version ? BoxParser.SingleItemTypeReferenceBox : BoxParser.SingleItemTypeReferenceBoxLarge)(e.type, e.size, e.hdr_size, e.start)).write === BoxParser.Box.prototype.write && "mdat" !== e.type && (Log.warn("BoxParser", e.type + " box writing not yet implemented, keeping unparsed data in memory for later write"), e.parseDataAndRewind(t)), e.parse(t), this.references.push(e) } }), BoxParser.createBoxCtor("irot", function (t) { this.angle = 3 & t.readUint8() }), BoxParser.createFullBoxCtor("ispe", function (t) { this.image_width = t.readUint32(), this.image_height = t.readUint32() }), BoxParser.createFullBoxCtor("kind", function (t) { this.schemeURI = t.readCString(), this.value = t.readCString() }), BoxParser.createFullBoxCtor("leva", function (t) { var e = t.readUint8(); this.levels = []; for (var i = 0; i < e; i++) { var r = {}; (this.levels[i] = r).track_ID = t.readUint32(); var s = t.readUint8(); switch (r.padding_flag = s >> 7, r.assignment_type = 127 & s, r.assignment_type) { case 0: r.grouping_type = t.readString(4); break; case 1: r.grouping_type = t.readString(4), r.grouping_type_parameter = t.readUint32(); break; case 2: case 3: break; case 4: r.sub_track_id = t.readUint32(); break; default: Log.warn("BoxParser", "Unknown leva assignement type") } } }), BoxParser.createBoxCtor("lsel", function (t) { this.layer_id = t.readUint16() }), BoxParser.createBoxCtor("maxr", function (t) { this.period = t.readUint32(), this.bytes = t.readUint32() }), BoxParser.createBoxCtor("mdcv", function (t) { this.display_primaries = [], this.display_primaries[0] = {}, this.display_primaries[0].x = t.readUint16(), this.display_primaries[0].y = t.readUint16(), this.display_primaries[1] = {}, this.display_primaries[1].x = t.readUint16(), this.display_primaries[1].y = t.readUint16(), this.display_primaries[2] = {}, this.display_primaries[2].x = t.readUint16(), this.display_primaries[2].y = t.readUint16(), this.white_point = {}, this.white_point.x = t.readUint16(), this.white_point.y = t.readUint16(), this.max_display_mastering_luminance = t.readUint32(), this.min_display_mastering_luminance = t.readUint32() }), BoxParser.createFullBoxCtor("mdhd", function (t) { 1 == this.version ? (this.creation_time = t.readUint64(), this.modification_time = t.readUint64(), this.timescale = t.readUint32(), this.duration = t.readUint64()) : (this.creation_time = t.readUint32(), this.modification_time = t.readUint32(), this.timescale = t.readUint32(), this.duration = t.readUint32()), this.parseLanguage(t), t.readUint16() }), BoxParser.createFullBoxCtor("mehd", function (t) { 1 & this.flags && (Log.warn("BoxParser", "mehd box incorrectly uses flags set to 1, converting version to 1"), this.version = 1), 1 == this.version ? this.fragment_duration = t.readUint64() : this.fragment_duration = t.readUint32() }), BoxParser.createFullBoxCtor("meta", function (t) { this.boxes = [], BoxParser.ContainerBox.prototype.parse.call(this, t) }), BoxParser.createFullBoxCtor("mfhd", function (t) { this.sequence_number = t.readUint32() }), BoxParser.createFullBoxCtor("mfro", function (t) { this._size = t.readUint32() }), BoxParser.createFullBoxCtor("mvhd", function (t) { 1 == this.version ? (this.creation_time = t.readUint64(), this.modification_time = t.readUint64(), this.timescale = t.readUint32(), this.duration = t.readUint64()) : (this.creation_time = t.readUint32(), this.modification_time = t.readUint32(), this.timescale = t.readUint32(), this.duration = t.readUint32()), this.rate = t.readUint32(), this.volume = t.readUint16() >> 8, t.readUint16(), t.readUint32Array(2), this.matrix = t.readUint32Array(9), t.readUint32Array(6), this.next_track_id = t.readUint32() }), BoxParser.createBoxCtor("npck", function (t) { this.packetssent = t.readUint32() }), BoxParser.createBoxCtor("nump", function (t) { this.packetssent = t.readUint64() }), BoxParser.createFullBoxCtor("padb", function (t) { var e = t.readUint32(); this.padbits = []; for (var i = 0; i < Math.floor((e + 1) / 2); i++)this.padbits = t.readUint8() }), BoxParser.createBoxCtor("pasp", function (t) { this.hSpacing = t.readUint32(), this.vSpacing = t.readUint32() }), BoxParser.createBoxCtor("payl", function (t) { this.text = t.readString(this.size - this.hdr_size) }), BoxParser.createBoxCtor("payt", function (t) { this.payloadID = t.readUint32(); var e = t.readUint8(); this.rtpmap_string = t.readString(e) }), BoxParser.createFullBoxCtor("pdin", function (t) { var e = (this.size - this.hdr_size) / 8; this.rate = [], this.initial_delay = []; for (var i = 0; i < e; i++)this.rate[i] = t.readUint32(), this.initial_delay[i] = t.readUint32() }), BoxParser.createFullBoxCtor("pitm", function (t) { 0 === this.version ? this.item_id = t.readUint16() : this.item_id = t.readUint32() }), BoxParser.createFullBoxCtor("pixi", function (t) { var e; for (this.num_channels = t.readUint8(), this.bits_per_channels = [], e = 0; e < this.num_channels; e++)this.bits_per_channels[e] = t.readUint8() }), BoxParser.createBoxCtor("pmax", function (t) { this.bytes = t.readUint32() }), BoxParser.createFullBoxCtor("prft", function (t) { this.ref_track_id = t.readUint32(), this.ntp_timestamp = t.readUint64(), 0 === this.version ? this.media_time = t.readUint32() : this.media_time = t.readUint64() }), BoxParser.createFullBoxCtor("pssh", function (t) { if (this.system_id = BoxParser.parseHex16(t), 0 < this.version) { var e = t.readUint32(); this.kid = []; for (var i = 0; i < e; i++)this.kid[i] = BoxParser.parseHex16(t) } var r = t.readUint32(); 0 < r && (this.data = t.readUint8Array(r)) }), BoxParser.createFullBoxCtor("clef", function (t) { this.width = t.readUint32(), this.height = t.readUint32() }), BoxParser.createFullBoxCtor("enof", function (t) { this.width = t.readUint32(), this.height = t.readUint32() }), BoxParser.createFullBoxCtor("prof", function (t) { this.width = t.readUint32(), this.height = t.readUint32() }), BoxParser.createContainerBoxCtor("tapt", null, ["clef", "prof", "enof"]), BoxParser.createBoxCtor("rtp ", function (t) { this.descriptionformat = t.readString(4), this.sdptext = t.readString(this.size - this.hdr_size - 4) }), BoxParser.createFullBoxCtor("saio", function (t) { 1 & this.flags && (this.aux_info_type = t.readUint32(), this.aux_info_type_parameter = t.readUint32()); var e = t.readUint32(); this.offset = []; for (var i = 0; i < e; i++)0 === this.version ? this.offset[i] = t.readUint32() : this.offset[i] = t.readUint64() }), BoxParser.createFullBoxCtor("saiz", function (t) { 1 & this.flags && (this.aux_info_type = t.readUint32(), this.aux_info_type_parameter = t.readUint32()), this.default_sample_info_size = t.readUint8(); var e = t.readUint32(); if (this.sample_info_size = [], 0 === this.default_sample_info_size) for (var i = 0; i < e; i++)this.sample_info_size[i] = t.readUint8() }), BoxParser.createSampleEntryCtor(BoxParser.SAMPLE_ENTRY_TYPE_METADATA, "mett", function (t) { this.parseHeader(t), this.content_encoding = t.readCString(), this.mime_format = t.readCString(), this.parseFooter(t) }), BoxParser.createSampleEntryCtor(BoxParser.SAMPLE_ENTRY_TYPE_METADATA, "metx", function (t) { this.parseHeader(t), this.content_encoding = t.readCString(), this.namespace = t.readCString(), this.schema_location = t.readCString(), this.parseFooter(t) }), BoxParser.createSampleEntryCtor(BoxParser.SAMPLE_ENTRY_TYPE_SUBTITLE, "sbtt", function (t) { this.parseHeader(t), this.content_encoding = t.readCString(), this.mime_format = t.readCString(), this.parseFooter(t) }), BoxParser.createSampleEntryCtor(BoxParser.SAMPLE_ENTRY_TYPE_SUBTITLE, "stpp", function (t) { this.parseHeader(t), this.namespace = t.readCString(), this.schema_location = t.readCString(), this.auxiliary_mime_types = t.readCString(), this.parseFooter(t) }), BoxParser.createSampleEntryCtor(BoxParser.SAMPLE_ENTRY_TYPE_SUBTITLE, "stxt", function (t) { this.parseHeader(t), this.content_encoding = t.readCString(), this.mime_format = t.readCString(), this.parseFooter(t) }), BoxParser.createSampleEntryCtor(BoxParser.SAMPLE_ENTRY_TYPE_SUBTITLE, "tx3g", function (t) { this.parseHeader(t), this.displayFlags = t.readUint32(), this.horizontal_justification = t.readInt8(), this.vertical_justification = t.readInt8(), this.bg_color_rgba = t.readUint8Array(4), this.box_record = t.readInt16Array(4), this.style_record = t.readUint8Array(12), this.parseFooter(t) }), BoxParser.createSampleEntryCtor(BoxParser.SAMPLE_ENTRY_TYPE_METADATA, "wvtt", function (t) { this.parseHeader(t), this.parseFooter(t) }), BoxParser.createSampleGroupCtor("alst", function (t) { var e, i = t.readUint16(); for (this.first_output_sample = t.readUint16(), this.sample_offset = [], e = 0; e < i; e++)this.sample_offset[e] = t.readUint32(); var r = this.description_length - 4 - 4 * i; for (this.num_output_samples = [], this.num_total_samples = [], e = 0; e < r / 4; e++)this.num_output_samples[e] = t.readUint16(), this.num_total_samples[e] = t.readUint16() }), BoxParser.createSampleGroupCtor("avll", function (t) { this.layerNumber = t.readUint8(), this.accurateStatisticsFlag = t.readUint8(), this.avgBitRate = t.readUint16(), this.avgFrameRate = t.readUint16() }), BoxParser.createSampleGroupCtor("avss", function (t) { this.subSequenceIdentifier = t.readUint16(), this.layerNumber = t.readUint8(); var e = t.readUint8(); this.durationFlag = e >> 7, this.avgRateFlag = e >> 6 & 1, this.durationFlag && (this.duration = t.readUint32()), this.avgRateFlag && (this.accurateStatisticsFlag = t.readUint8(), this.avgBitRate = t.readUint16(), this.avgFrameRate = t.readUint16()), this.dependency = []; for (var i = t.readUint8(), r = 0; r < i; r++) { var s = {}; this.dependency.push(s), s.subSeqDirectionFlag = t.readUint8(), s.layerNumber = t.readUint8(), s.subSequenceIdentifier = t.readUint16() } }), BoxParser.createSampleGroupCtor("dtrt", function (t) { Log.warn("BoxParser", "Sample Group type: " + this.grouping_type + " not fully parsed") }), BoxParser.createSampleGroupCtor("mvif", function (t) { Log.warn("BoxParser", "Sample Group type: " + this.grouping_type + " not fully parsed") }), BoxParser.createSampleGroupCtor("prol", function (t) { this.roll_distance = t.readInt16() }), BoxParser.createSampleGroupCtor("rap ", function (t) { t = t.readUint8(); this.num_leading_samples_known = t >> 7, this.num_leading_samples = 127 & t }), BoxParser.createSampleGroupCtor("rash", function (t) { if (this.operation_point_count = t.readUint16(), this.description_length !== 2 + (1 === this.operation_point_count ? 2 : 6 * this.operation_point_count) + 9) Log.warn("BoxParser", "Mismatch in " + this.grouping_type + " sample group length"), this.data = t.readUint8Array(this.description_length - 2); else { if (1 === this.operation_point_count) this.target_rate_share = t.readUint16(); else { this.target_rate_share = [], this.available_bitrate = []; for (var e = 0; e < this.operation_point_count; e++)this.available_bitrate[e] = t.readUint32(), this.target_rate_share[e] = t.readUint16() } this.maximum_bitrate = t.readUint32(), this.minimum_bitrate = t.readUint32(), this.discard_priority = t.readUint8() } }), BoxParser.createSampleGroupCtor("roll", function (t) { this.roll_distance = t.readInt16() }), BoxParser.SampleGroupEntry.prototype.parse = function (t) { Log.warn("BoxParser", "Unknown Sample Group type: " + this.grouping_type), this.data = t.readUint8Array(this.description_length) }, BoxParser.createSampleGroupCtor("scif", function (t) { Log.warn("BoxParser", "Sample Group type: " + this.grouping_type + " not fully parsed") }), BoxParser.createSampleGroupCtor("scnm", function (t) { Log.warn("BoxParser", "Sample Group type: " + this.grouping_type + " not fully parsed") }), BoxParser.createSampleGroupCtor("seig", function (t) { this.reserved = t.readUint8(); var e = t.readUint8(); this.crypt_byte_block = e >> 4, this.skip_byte_block = 15 & e, this.isProtected = t.readUint8(), this.Per_Sample_IV_Size = t.readUint8(), this.KID = BoxParser.parseHex16(t), this.constant_IV_size = 0, this.constant_IV = 0, 1 === this.isProtected && 0 === this.Per_Sample_IV_Size && (this.constant_IV_size = t.readUint8(), this.constant_IV = t.readUint8Array(this.constant_IV_size)) }), BoxParser.createSampleGroupCtor("stsa", function (t) { Log.warn("BoxParser", "Sample Group type: " + this.grouping_type + " not fully parsed") }), BoxParser.createSampleGroupCtor("sync", function (t) { t = t.readUint8(); this.NAL_unit_type = 63 & t }), BoxParser.createSampleGroupCtor("tele", function (t) { t = t.readUint8(); this.level_independently_decodable = t >> 7 }), BoxParser.createSampleGroupCtor("tsas", function (t) { Log.warn("BoxParser", "Sample Group type: " + this.grouping_type + " not fully parsed") }), BoxParser.createSampleGroupCtor("tscl", function (t) { Log.warn("BoxParser", "Sample Group type: " + this.grouping_type + " not fully parsed") }), BoxParser.createSampleGroupCtor("vipr", function (t) { Log.warn("BoxParser", "Sample Group type: " + this.grouping_type + " not fully parsed") }), BoxParser.createFullBoxCtor("sbgp", function (t) { this.grouping_type = t.readString(4), 1 === this.version ? this.grouping_type_parameter = t.readUint32() : this.grouping_type_parameter = 0, this.entries = []; for (var e = t.readUint32(), i = 0; i < e; i++) { var r = {}; this.entries.push(r), r.sample_count = t.readInt32(), r.group_description_index = t.readInt32() } }), BoxParser.createFullBoxCtor("schm", function (t) { this.scheme_type = t.readString(4), this.scheme_version = t.readUint32(), 1 & this.flags && (this.scheme_uri = t.readString(this.size - this.hdr_size - 8)) }), BoxParser.createBoxCtor("sdp ", function (t) { this.sdptext = t.readString(this.size - this.hdr_size) }), BoxParser.createFullBoxCtor("sdtp", function (t) { var e, i = this.size - this.hdr_size; this.is_leading = [], this.sample_depends_on = [], this.sample_is_depended_on = [], this.sample_has_redundancy = []; for (var r = 0; r < i; r++)e = t.readUint8(), this.is_leading[r] = e >> 6, this.sample_depends_on[r] = e >> 4 & 3, this.sample_is_depended_on[r] = e >> 2 & 3, this.sample_has_redundancy[r] = 3 & e }), BoxParser.createFullBoxCtor("senc"), BoxParser.createFullBoxCtor("sgpd", function (t) { this.grouping_type = t.readString(4), Log.debug("BoxParser", "Found Sample Groups of type " + this.grouping_type), 1 === this.version ? this.default_length = t.readUint32() : this.default_length = 0, 2 <= this.version && (this.default_group_description_index = t.readUint32()), this.entries = []; for (var e = t.readUint32(), i = 0; i < e; i++) { var r = new (BoxParser[this.grouping_type + "SampleGroupEntry"] ? BoxParser[this.grouping_type + "SampleGroupEntry"] : BoxParser.SampleGroupEntry)(this.grouping_type); this.entries.push(r), 1 === this.version && 0 === this.default_length ? r.description_length = t.readUint32() : r.description_length = this.default_length, r.write === BoxParser.SampleGroupEntry.prototype.write && (Log.info("BoxParser", "SampleGroup for type " + this.grouping_type + " writing not yet implemented, keeping unparsed data in memory for later write"), r.data = t.readUint8Array(r.description_length), t.position -= r.description_length), r.parse(t) } }), BoxParser.createFullBoxCtor("sidx", function (t) { this.reference_ID = t.readUint32(), this.timescale = t.readUint32(), 0 === this.version ? (this.earliest_presentation_time = t.readUint32(), this.first_offset = t.readUint32()) : (this.earliest_presentation_time = t.readUint64(), this.first_offset = t.readUint64()), t.readUint16(), this.references = []; for (var e = t.readUint16(), i = 0; i < e; i++) { var r = {}; this.references.push(r); var s = t.readUint32(); r.reference_type = s >> 31 & 1, r.referenced_size = 2147483647 & s, r.subsegment_duration = t.readUint32(), s = t.readUint32(), r.starts_with_SAP = s >> 31 & 1, r.SAP_type = s >> 28 & 7, r.SAP_delta_time = 268435455 & s } }), BoxParser.SingleItemTypeReferenceBox = function (t, e, i, r) { BoxParser.Box.call(this, t, e), this.hdr_size = i, this.start = r }, BoxParser.SingleItemTypeReferenceBox.prototype = new BoxParser.Box, BoxParser.SingleItemTypeReferenceBox.prototype.parse = function (t) { this.from_item_ID = t.readUint16(); var e = t.readUint16(); this.references = []; for (var i = 0; i < e; i++)this.references[i] = t.readUint16() }, BoxParser.SingleItemTypeReferenceBoxLarge = function (t, e, i, r) { BoxParser.Box.call(this, t, e), this.hdr_size = i, this.start = r }, BoxParser.SingleItemTypeReferenceBoxLarge.prototype = new BoxParser.Box, BoxParser.SingleItemTypeReferenceBoxLarge.prototype.parse = function (t) { this.from_item_ID = t.readUint32(); var e = t.readUint16(); this.references = []; for (var i = 0; i < e; i++)this.references[i] = t.readUint32() }, BoxParser.createFullBoxCtor("SmDm", function (t) { this.primaryRChromaticity_x = t.readUint16(), this.primaryRChromaticity_y = t.readUint16(), this.primaryGChromaticity_x = t.readUint16(), this.primaryGChromaticity_y = t.readUint16(), this.primaryBChromaticity_x = t.readUint16(), this.primaryBChromaticity_y = t.readUint16(), this.whitePointChromaticity_x = t.readUint16(), this.whitePointChromaticity_y = t.readUint16(), this.luminanceMax = t.readUint32(), this.luminanceMin = t.readUint32() }), BoxParser.createFullBoxCtor("smhd", function (t) { this.balance = t.readUint16(), t.readUint16() }), BoxParser.createFullBoxCtor("ssix", function (t) { this.subsegments = []; for (var e = t.readUint32(), i = 0; i < e; i++) { var r = {}; this.subsegments.push(r), r.ranges = []; for (var s = t.readUint32(), a = 0; a < s; a++) { var n = {}; r.ranges.push(n), n.level = t.readUint8(), n.range_size = t.readUint24() } } }), BoxParser.createFullBoxCtor("stco", function (t) { var e = t.readUint32(); if (this.chunk_offsets = [], 0 === this.version) for (var i = 0; i < e; i++)this.chunk_offsets.push(t.readUint32()) }), BoxParser.createFullBoxCtor("stdp", function (t) { var e = (this.size - this.hdr_size) / 2; this.priority = []; for (var i = 0; i < e; i++)this.priority[i] = t.readUint16() }), BoxParser.createFullBoxCtor("sthd"), BoxParser.createFullBoxCtor("stri", function (t) { this.switch_group = t.readUint16(), this.alternate_group = t.readUint16(), this.sub_track_id = t.readUint32(); var e = (this.size - this.hdr_size - 8) / 4; this.attribute_list = []; for (var i = 0; i < e; i++)this.attribute_list[i] = t.readUint32() }), BoxParser.createFullBoxCtor("stsc", function (t) { var e, i = t.readUint32(); if (this.first_chunk = [], this.samples_per_chunk = [], this.sample_description_index = [], 0 === this.version) for (e = 0; e < i; e++)this.first_chunk.push(t.readUint32()), this.samples_per_chunk.push(t.readUint32()), this.sample_description_index.push(t.readUint32()) }), BoxParser.createFullBoxCtor("stsd", function (t) { var e, i, r, s; for (this.entries = [], r = t.readUint32(), e = 1; e <= r; e++) { if ((i = BoxParser.parseOneBox(t, !0, this.size - (t.getPosition() - this.start))).code !== BoxParser.OK) return; BoxParser[i.type + "SampleEntry"] ? ((s = new BoxParser[i.type + "SampleEntry"](i.size)).hdr_size = i.hdr_size, s.start = i.start) : (Log.warn("BoxParser", "Unknown sample entry type: " + i.type), s = new BoxParser.SampleEntry(i.type, i.size, i.hdr_size, i.start)), s.write === BoxParser.SampleEntry.prototype.write && (Log.info("BoxParser", "SampleEntry " + s.type + " box writing not yet implemented, keeping unparsed data in memory for later write"), s.parseDataAndRewind(t)), s.parse(t), this.entries.push(s) } }), BoxParser.createFullBoxCtor("stsg", function (t) { this.grouping_type = t.readUint32(); var e = t.readUint16(); this.group_description_index = []; for (var i = 0; i < e; i++)this.group_description_index[i] = t.readUint32() }), BoxParser.createFullBoxCtor("stsh", function (t) { var e, i = t.readUint32(); if (this.shadowed_sample_numbers = [], this.sync_sample_numbers = [], 0 === this.version) for (e = 0; e < i; e++)this.shadowed_sample_numbers.push(t.readUint32()), this.sync_sample_numbers.push(t.readUint32()) }), BoxParser.createFullBoxCtor("stss", function (t) { var e, i = t.readUint32(); if (0 === this.version) for (this.sample_numbers = [], e = 0; e < i; e++)this.sample_numbers.push(t.readUint32()) }), BoxParser.createFullBoxCtor("stsz", function (t) { var e; if (this.sample_sizes = [], 0 === this.version) for (this.sample_size = t.readUint32(), this.sample_count = t.readUint32(), e = 0; e < this.sample_count; e++)0 === this.sample_size ? this.sample_sizes.push(t.readUint32()) : this.sample_sizes[e] = this.sample_size }), BoxParser.createFullBoxCtor("stts", function (t) { var e, i, r = t.readUint32(); if (this.sample_counts = [], this.sample_deltas = [], 0 === this.version) for (e = 0; e < r; e++)this.sample_counts.push(t.readUint32()), (i = t.readInt32()) < 0 && (Log.warn("BoxParser", "File uses negative stts sample delta, using value 1 instead, sync may be lost!"), i = 1), this.sample_deltas.push(i) }), BoxParser.createFullBoxCtor("stvi", function (t) { var e = t.readUint32(); this.single_view_allowed = 3 & e, this.stereo_scheme = t.readUint32(); var i, e = t.readUint32(); for (this.stereo_indication_type = t.readString(e), this.boxes = []; t.getPosition() < this.start + this.size;) { if ((i = BoxParser.parseOneBox(t, !1, this.size - (t.getPosition() - this.start))).code !== BoxParser.OK) return; i = i.box, this.boxes.push(i), this[i.type] = i } }), BoxParser.createBoxCtor("styp", function (t) { BoxParser.ftypBox.prototype.parse.call(this, t) }), BoxParser.createFullBoxCtor("stz2", function (t) { var e, i; if (this.sample_sizes = [], 0 === this.version) if (this.reserved = t.readUint24(), this.field_size = t.readUint8(), i = t.readUint32(), 4 === this.field_size) for (e = 0; e < i; e += 2) { var r = t.readUint8(); this.sample_sizes[e] = r >> 4 & 15, this.sample_sizes[e + 1] = 15 & r } else if (8 === this.field_size) for (e = 0; e < i; e++)this.sample_sizes[e] = t.readUint8(); else if (16 === this.field_size) for (e = 0; e < i; e++)this.sample_sizes[e] = t.readUint16(); else Log.error("BoxParser", "Error in length field in stz2 box") }), BoxParser.createFullBoxCtor("subs", function (t) { var e, i, r, s = t.readUint32(); for (this.entries = [], e = 0; e < s; e++) { var a = {}; if ((this.entries[e] = a).sample_delta = t.readUint32(), a.subsamples = [], 0 < (r = t.readUint16())) for (i = 0; i < r; i++) { var n = {}; a.subsamples.push(n), 1 == this.version ? n.size = t.readUint32() : n.size = t.readUint16(), n.priority = t.readUint8(), n.discardable = t.readUint8(), n.codec_specific_parameters = t.readUint32() } } }), BoxParser.createFullBoxCtor("tenc", function (t) { var e; t.readUint8(), 0 === this.version ? t.readUint8() : (e = t.readUint8(), this.default_crypt_byte_block = e >> 4 & 15, this.default_skip_byte_block = 15 & e), this.default_isProtected = t.readUint8(), this.default_Per_Sample_IV_Size = t.readUint8(), this.default_KID = BoxParser.parseHex16(t), 1 === this.default_isProtected && 0 === this.default_Per_Sample_IV_Size && (this.default_constant_IV_size = t.readUint8(), this.default_constant_IV = t.readUint8Array(this.default_constant_IV_size)) }), BoxParser.createFullBoxCtor("tfdt", function (t) { 1 == this.version ? this.baseMediaDecodeTime = t.readUint64() : this.baseMediaDecodeTime = t.readUint32() }), BoxParser.createFullBoxCtor("tfhd", function (t) { var e = 0; this.track_id = t.readUint32(), this.size - this.hdr_size > e && this.flags & BoxParser.TFHD_FLAG_BASE_DATA_OFFSET ? (this.base_data_offset = t.readUint64(), e += 8) : this.base_data_offset = 0, this.size - this.hdr_size > e && this.flags & BoxParser.TFHD_FLAG_SAMPLE_DESC ? (this.default_sample_description_index = t.readUint32(), e += 4) : this.default_sample_description_index = 0, this.size - this.hdr_size > e && this.flags & BoxParser.TFHD_FLAG_SAMPLE_DUR ? (this.default_sample_duration = t.readUint32(), e += 4) : this.default_sample_duration = 0, this.size - this.hdr_size > e && this.flags & BoxParser.TFHD_FLAG_SAMPLE_SIZE ? (this.default_sample_size = t.readUint32(), e += 4) : this.default_sample_size = 0, this.size - this.hdr_size > e && this.flags & BoxParser.TFHD_FLAG_SAMPLE_FLAGS ? (this.default_sample_flags = t.readUint32(), e += 4) : this.default_sample_flags = 0 }), BoxParser.createFullBoxCtor("tfra", function (t) { this.track_ID = t.readUint32(), t.readUint24(); var e = t.readUint8(); this.length_size_of_traf_num = e >> 4 & 3, this.length_size_of_trun_num = e >> 2 & 3, this.length_size_of_sample_num = 3 & e, this.entries = []; for (var i = t.readUint32(), r = 0; r < i; r++)1 === this.version ? (this.time = t.readUint64(), this.moof_offset = t.readUint64()) : (this.time = t.readUint32(), this.moof_offset = t.readUint32()), this.traf_number = t["readUint" + 8 * (this.length_size_of_traf_num + 1)](), this.trun_number = t["readUint" + 8 * (this.length_size_of_trun_num + 1)](), this.sample_number = t["readUint" + 8 * (this.length_size_of_sample_num + 1)]() }), BoxParser.createFullBoxCtor("tkhd", function (t) { 1 == this.version ? (this.creation_time = t.readUint64(), this.modification_time = t.readUint64(), this.track_id = t.readUint32(), t.readUint32(), this.duration = t.readUint64()) : (this.creation_time = t.readUint32(), this.modification_time = t.readUint32(), this.track_id = t.readUint32(), t.readUint32(), this.duration = t.readUint32()), t.readUint32Array(2), this.layer = t.readInt16(), this.alternate_group = t.readInt16(), this.volume = t.readInt16() >> 8, t.readUint16(), this.matrix = t.readInt32Array(9), this.width = t.readUint32(), this.height = t.readUint32() }), BoxParser.createBoxCtor("tmax", function (t) { this.time = t.readUint32() }), BoxParser.createBoxCtor("tmin", function (t) { this.time = t.readUint32() }), BoxParser.createBoxCtor("totl", function (t) { this.bytessent = t.readUint32() }), BoxParser.createBoxCtor("tpay", function (t) { this.bytessent = t.readUint32() }), BoxParser.createBoxCtor("tpyl", function (t) { this.bytessent = t.readUint64() }), BoxParser.TrackGroupTypeBox.prototype.parse = function (t) { this.parseFullHeader(t), this.track_group_id = t.readUint32() }, BoxParser.createTrackGroupCtor("msrc"), BoxParser.TrackReferenceTypeBox = function (t, e, i, r) { BoxParser.Box.call(this, t, e), this.hdr_size = i, this.start = r }, BoxParser.TrackReferenceTypeBox.prototype = new BoxParser.Box, BoxParser.TrackReferenceTypeBox.prototype.parse = function (t) { this.track_ids = t.readUint32Array((this.size - this.hdr_size) / 4) }, BoxParser.trefBox.prototype.parse = function (t) { for (var e; t.getPosition() < this.start + this.size;) { if ((e = BoxParser.parseOneBox(t, !0, this.size - (t.getPosition() - this.start))).code !== BoxParser.OK) return; (e = new BoxParser.TrackReferenceTypeBox(e.type, e.size, e.hdr_size, e.start)).write === BoxParser.Box.prototype.write && "mdat" !== e.type && (Log.info("BoxParser", "TrackReference " + e.type + " box writing not yet implemented, keeping unparsed data in memory for later write"), e.parseDataAndRewind(t)), e.parse(t), this.boxes.push(e) } }, BoxParser.createFullBoxCtor("trep", function (t) { for (this.track_ID = t.readUint32(), this.boxes = []; t.getPosition() < this.start + this.size;) { if (ret = BoxParser.parseOneBox(t, !1, this.size - (t.getPosition() - this.start)), ret.code !== BoxParser.OK) return; box = ret.box, this.boxes.push(box) } }), BoxParser.createFullBoxCtor("trex", function (t) { this.track_id = t.readUint32(), this.default_sample_description_index = t.readUint32(), this.default_sample_duration = t.readUint32(), this.default_sample_size = t.readUint32(), this.default_sample_flags = t.readUint32() }), BoxParser.createBoxCtor("trpy", function (t) { this.bytessent = t.readUint64() }), BoxParser.createFullBoxCtor("trun", function (t) { var e = 0; if (this.sample_count = t.readUint32(), e += 4, this.size - this.hdr_size > e && this.flags & BoxParser.TRUN_FLAGS_DATA_OFFSET ? (this.data_offset = t.readInt32(), e += 4) : this.data_offset = 0, this.size - this.hdr_size > e && this.flags & BoxParser.TRUN_FLAGS_FIRST_FLAG ? (this.first_sample_flags = t.readUint32(), e += 4) : this.first_sample_flags = 0, this.sample_duration = [], this.sample_size = [], this.sample_flags = [], this.sample_composition_time_offset = [], this.size - this.hdr_size > e) for (var i = 0; i < this.sample_count; i++)this.flags & BoxParser.TRUN_FLAGS_DURATION && (this.sample_duration[i] = t.readUint32()), this.flags & BoxParser.TRUN_FLAGS_SIZE && (this.sample_size[i] = t.readUint32()), this.flags & BoxParser.TRUN_FLAGS_FLAGS && (this.sample_flags[i] = t.readUint32()), this.flags & BoxParser.TRUN_FLAGS_CTS_OFFSET && (0 === this.version ? this.sample_composition_time_offset[i] = t.readUint32() : this.sample_composition_time_offset[i] = t.readInt32()) }), BoxParser.createFullBoxCtor("tsel", function (t) { this.switch_group = t.readUint32(); var e = (this.size - this.hdr_size - 4) / 4; this.attribute_list = []; for (var i = 0; i < e; i++)this.attribute_list[i] = t.readUint32() }), BoxParser.createFullBoxCtor("txtC", function (t) { this.config = t.readCString() }), BoxParser.createFullBoxCtor("url ", function (t) { 1 !== this.flags && (this.location = t.readCString()) }), BoxParser.createFullBoxCtor("urn ", function (t) { this.name = t.readCString(), 0 < this.size - this.hdr_size - this.name.length - 1 && (this.location = t.readCString()) }), BoxParser.createUUIDBox("a5d40b30e81411ddba2f0800200c9a66", !0, !1, function (t) { this.LiveServerManifest = t.readString(this.size - this.hdr_size).replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#039;") }), BoxParser.createUUIDBox("d08a4f1810f34a82b6c832d8aba183d3", !0, !1, function (t) { this.system_id = BoxParser.parseHex16(t); var e = t.readUint32(); 0 < e && (this.data = t.readUint8Array(e)) }), BoxParser.createUUIDBox("a2394f525a9b4f14a2446c427c648df4", !0, !1), BoxParser.createUUIDBox("8974dbce7be74c5184f97148f9882554", !0, !1, function (t) { this.default_AlgorithmID = t.readUint24(), this.default_IV_size = t.readUint8(), this.default_KID = BoxParser.parseHex16(t) }), BoxParser.createUUIDBox("d4807ef2ca3946958e5426cb9e46a79f", !0, !1, function (t) { this.fragment_count = t.readUint8(), this.entries = []; for (var e = 0; e < this.fragment_count; e++) { var i = {}, r = 0, s = 0, s = 1 === this.version ? (r = t.readUint64(), t.readUint64()) : (r = t.readUint32(), t.readUint32()); i.absolute_time = r, i.absolute_duration = s, this.entries.push(i) } }), BoxParser.createUUIDBox("6d1d9b0542d544e680e2141daff757b2", !0, !1, function (t) { 1 === this.version ? (this.absolute_time = t.readUint64(), this.duration = t.readUint64()) : (this.absolute_time = t.readUint32(), this.duration = t.readUint32()) }), BoxParser.createFullBoxCtor("vmhd", function (t) { this.graphicsmode = t.readUint16(), this.opcolor = t.readUint16Array(3) }), BoxParser.createFullBoxCtor("vpcC", function (t) { var e; 1 === this.version ? (this.profile = t.readUint8(), this.level = t.readUint8(), e = t.readUint8(), this.bitDepth = e >> 4, this.chromaSubsampling = e >> 1 & 7, this.videoFullRangeFlag = 1 & e, this.colourPrimaries = t.readUint8(), this.transferCharacteristics = t.readUint8(), this.matrixCoefficients = t.readUint8()) : (this.profile = t.readUint8(), this.level = t.readUint8(), e = t.readUint8(), this.bitDepth = e >> 4 & 15, this.colorSpace = 15 & e, e = t.readUint8(), this.chromaSubsampling = e >> 4 & 15, this.transferFunction = e >> 1 & 7, this.videoFullRangeFlag = 1 & e), this.codecIntializationDataSize = t.readUint16(), this.codecIntializationData = t.readUint8Array(this.codecIntializationDataSize) }), BoxParser.createBoxCtor("vttC", function (t) { this.text = t.readString(this.size - this.hdr_size) }), BoxParser.createFullBoxCtor("vvcC", function (t) { var e, i = { held_bits: void 0, num_held_bits: 0, stream_read_1_bytes: function (t) { this.held_bits = t.readUint8(), this.num_held_bits = 8 }, stream_read_2_bytes: function (t) { this.held_bits = t.readUint16(), this.num_held_bits = 16 }, extract_bits: function (t) { var e = this.held_bits >> this.num_held_bits - t & (1 << t) - 1; return this.num_held_bits -= t, e } }; if (i.stream_read_1_bytes(t), i.extract_bits(5), this.lengthSizeMinusOne = i.extract_bits(2), this.ptl_present_flag = i.extract_bits(1), this.ptl_present_flag) { if (i.stream_read_2_bytes(t), this.ols_idx = i.extract_bits(9), this.num_sublayers = i.extract_bits(3), this.constant_frame_rate = i.extract_bits(2), this.chroma_format_idc = i.extract_bits(2), i.stream_read_1_bytes(t), this.bit_depth_minus8 = i.extract_bits(3), i.extract_bits(5), i.stream_read_2_bytes(t), i.extract_bits(2), this.num_bytes_constraint_info = i.extract_bits(6), this.general_profile_idc = i.extract_bits(7), this.general_tier_flag = i.extract_bits(1), this.general_level_idc = t.readUint8(), i.stream_read_1_bytes(t), this.ptl_frame_only_constraint_flag = i.extract_bits(1), this.ptl_multilayer_enabled_flag = i.extract_bits(1), this.general_constraint_info = new Uint8Array(this.num_bytes_constraint_info), this.num_bytes_constraint_info) { for (o = 0; o < this.num_bytes_constraint_info - 1; o++) { var r = i.extract_bits(6); i.stream_read_1_bytes(t); var s = i.extract_bits(2); this.general_constraint_info[o] = r << 2 | s } this.general_constraint_info[this.num_bytes_constraint_info - 1] = i.extract_bits(6) } else i.extract_bits(6); for (i.stream_read_1_bytes(t), this.ptl_sublayer_present_mask = 0, e = this.num_sublayers - 2; 0 <= e; --e) { var a = i.extract_bits(1); this.ptl_sublayer_present_mask |= a << e } for (e = this.num_sublayers; e <= 8 && 1 < this.num_sublayers; ++e)i.extract_bits(1); for (e = this.num_sublayers - 2; 0 <= e; --e)this.ptl_sublayer_present_mask & 1 << e && (this.sublayer_level_idc[e] = t.readUint8()); if (this.ptl_num_sub_profiles = t.readUint8(), this.general_sub_profile_idc = [], this.ptl_num_sub_profiles) for (o = 0; o < this.ptl_num_sub_profiles; o++)this.general_sub_profile_idc.push(t.readUint32()); this.max_picture_width = t.readUint16(), this.max_picture_height = t.readUint16(), this.avg_frame_rate = t.readUint16() } this.nalu_arrays = []; for (var n = t.readUint8(), o = 0; o < n; o++) { var h = []; this.nalu_arrays.push(h), i.stream_read_1_bytes(t), h.completeness = i.extract_bits(1), i.extract_bits(2), h.nalu_type = i.extract_bits(5); var d = 1; for (13 != h.nalu_type && 12 != h.nalu_type && (d = t.readUint16()), e = 0; e < d; e++) { var l = t.readUint16(); h.push({ data: t.readUint8Array(l), length: l }) } } }), BoxParser.createFullBoxCtor("vvnC", function (t) { var e = strm.readUint8(); this.lengthSizeMinusOne = 3 & e }), BoxParser.SampleEntry.prototype.isVideo = function () { return !1 }, BoxParser.SampleEntry.prototype.isAudio = function () { return !1 }, BoxParser.SampleEntry.prototype.isSubtitle = function () { return !1 }, BoxParser.SampleEntry.prototype.isMetadata = function () { return !1 }, BoxParser.SampleEntry.prototype.isHint = function () { return !1 }, BoxParser.SampleEntry.prototype.getCodec = function () { return this.type.replace(".", "") }, BoxParser.SampleEntry.prototype.getWidth = function () { return "" }, BoxParser.SampleEntry.prototype.getHeight = function () { return "" }, BoxParser.SampleEntry.prototype.getChannelCount = function () { return "" }, BoxParser.SampleEntry.prototype.getSampleRate = function () { return "" }, BoxParser.SampleEntry.prototype.getSampleSize = function () { return "" }, BoxParser.VisualSampleEntry.prototype.isVideo = function () { return !0 }, BoxParser.VisualSampleEntry.prototype.getWidth = function () { return this.width }, BoxParser.VisualSampleEntry.prototype.getHeight = function () { return this.height }, BoxParser.AudioSampleEntry.prototype.isAudio = function () { return !0 }, BoxParser.AudioSampleEntry.prototype.getChannelCount = function () { return this.channel_count }, BoxParser.AudioSampleEntry.prototype.getSampleRate = function () { return this.samplerate }, BoxParser.AudioSampleEntry.prototype.getSampleSize = function () { return this.samplesize }, BoxParser.SubtitleSampleEntry.prototype.isSubtitle = function () { return !0 }, BoxParser.MetadataSampleEntry.prototype.isMetadata = function () { return !0 }, BoxParser.decimalToHex = function (t, e) { var i = Number(t).toString(16); for (e = null == e ? e = 2 : e; i.length < e;)i = "0" + i; return i }, BoxParser.avc1SampleEntry.prototype.getCodec = BoxParser.avc2SampleEntry.prototype.getCodec = BoxParser.avc3SampleEntry.prototype.getCodec = BoxParser.avc4SampleEntry.prototype.getCodec = function () { var t = BoxParser.SampleEntry.prototype.getCodec.call(this); return this.avcC ? t + "." + BoxParser.decimalToHex(this.avcC.AVCProfileIndication) + BoxParser.decimalToHex(this.avcC.profile_compatibility) + BoxParser.decimalToHex(this.avcC.AVCLevelIndication) : t }, BoxParser.hev1SampleEntry.prototype.getCodec = BoxParser.hvc1SampleEntry.prototype.getCodec = function () { var t = BoxParser.SampleEntry.prototype.getCodec.call(this); if (this.hvcC) { switch (t += ".", this.hvcC.general_profile_space) { case 0: t += ""; break; case 1: t += "A"; break; case 2: t += "B"; break; case 3: t += "C" }t += this.hvcC.general_profile_idc, t += "."; for (var e = this.hvcC.general_profile_compatibility, i = 0, r = 0; r < 32 && (i |= 1 & e, 31 != r); r++)i <<= 1, e >>= 1; t += BoxParser.decimalToHex(i, 0), t += ".", 0 === this.hvcC.general_tier_flag ? t += "L" : t += "H", t += this.hvcC.general_level_idc; var s = !1, a = ""; for (r = 5; 0 <= r; r--)(this.hvcC.general_constraint_indicator[r] || s) && (a = "." + BoxParser.decimalToHex(this.hvcC.general_constraint_indicator[r], 0) + a, s = !0); t += a } return t }, BoxParser.vvc1SampleEntry.prototype.getCodec = BoxParser.vvi1SampleEntry.prototype.getCodec = function () { var t = BoxParser.SampleEntry.prototype.getCodec.call(this); if (this.vvcC) { t += "." + this.vvcC.general_profile_idc, this.vvcC.general_tier_flag ? t += ".H" : t += ".L", t += this.vvcC.general_level_idc; var e = ""; if (this.vvcC.general_constraint_info) { var i, r = [], s = 0; for (s |= this.vvcC.ptl_frame_only_constraint << 7, s |= this.vvcC.ptl_multilayer_enabled << 6, h = 0; h < this.vvcC.general_constraint_info.length; ++h)s |= this.vvcC.general_constraint_info[h] >> 2 & 63, r.push(s), s && (i = h), s = this.vvcC.general_constraint_info[h] >> 2 & 3; if (void 0 === i) e = ".CA"; else { e = ".C"; for (var a = "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567", n = 0, o = 0, h = 0; h <= i; ++h)for (n = n << 8 | r[h], o += 8; 5 <= o;)e += a[n >> o - 5 & 31], n &= (1 << (o -= 5)) - 1; o && (e += a[31 & (n <<= 5 - o)]) } } t += e } return t }, BoxParser.mp4aSampleEntry.prototype.getCodec = function () { var t = BoxParser.SampleEntry.prototype.getCodec.call(this); if (this.esds && this.esds.esd) { var e = this.esds.esd.getOTI(), i = this.esds.esd.getAudioConfig(); return t + "." + BoxParser.decimalToHex(e) + (i ? "." + i : "") } return t }, BoxParser.stxtSampleEntry.prototype.getCodec = function () { var t = BoxParser.SampleEntry.prototype.getCodec.call(this); return this.mime_format ? t + "." + this.mime_format : t }, BoxParser.vp08SampleEntry.prototype.getCodec = BoxParser.vp09SampleEntry.prototype.getCodec = function () { var t = BoxParser.SampleEntry.prototype.getCodec.call(this), e = this.vpcC.level; 0 == e && (e = "00"); var i = this.vpcC.bitDepth; return 8 == i && (i = "08"), t + ".0" + this.vpcC.profile + "." + e + "." + i }, BoxParser.av01SampleEntry.prototype.getCodec = function () { var t, e = BoxParser.SampleEntry.prototype.getCodec.call(this), i = this.av1C.seq_level_idx_0; return i < 10 && (i = "0" + i), 2 === this.av1C.seq_profile && 1 === this.av1C.high_bitdepth ? t = 1 === this.av1C.twelve_bit ? "12" : "10" : this.av1C.seq_profile <= 2 && (t = 1 === this.av1C.high_bitdepth ? "10" : "08"), e + "." + this.av1C.seq_profile + "." + i + (this.av1C.seq_tier_0 ? "H" : "M") + "." + t }, BoxParser.Box.prototype.writeHeader = function (t, e) { this.size += 8, this.size > MAX_SIZE && (this.size += 8), "uuid" === this.type && (this.size += 16), Log.debug("BoxWriter", "Writing box " + this.type + " of size: " + this.size + " at position " + t.getPosition() + (e || "")), this.size > MAX_SIZE ? t.writeUint32(1) : (this.sizePosition = t.getPosition(), t.writeUint32(this.size)), t.writeString(this.type, null, 4), "uuid" === this.type && t.writeUint8Array(this.uuid), this.size > MAX_SIZE && t.writeUint64(this.size) }, BoxParser.FullBox.prototype.writeHeader = function (t) { this.size += 4, BoxParser.Box.prototype.writeHeader.call(this, t, " v=" + this.version + " f=" + this.flags), t.writeUint8(this.version), t.writeUint24(this.flags) }, BoxParser.Box.prototype.write = function (t) { "mdat" === this.type ? this.data && (this.size = this.data.length, this.writeHeader(t), t.writeUint8Array(this.data)) : (this.size = this.data ? this.data.length : 0, this.writeHeader(t), this.data && t.writeUint8Array(this.data)) }, BoxParser.ContainerBox.prototype.write = function (t) { this.size = 0, this.writeHeader(t); for (var e = 0; e < this.boxes.length; e++)this.boxes[e] && (this.boxes[e].write(t), this.size += this.boxes[e].size); Log.debug("BoxWriter", "Adjusting box " + this.type + " with new size " + this.size), t.adjustUint32(this.sizePosition, this.size) }, BoxParser.TrackReferenceTypeBox.prototype.write = function (t) { this.size = 4 * this.track_ids.length, this.writeHeader(t), t.writeUint32Array(this.track_ids) }, BoxParser.avcCBox.prototype.write = function (t) { var e; for (this.size = 7, e = 0; e < this.SPS.length; e++)this.size += 2 + this.SPS[e].length; for (e = 0; e < this.PPS.length; e++)this.size += 2 + this.PPS[e].length; for (this.ext && (this.size += this.ext.length), this.writeHeader(t), t.writeUint8(this.configurationVersion), t.writeUint8(this.AVCProfileIndication), t.writeUint8(this.profile_compatibility), t.writeUint8(this.AVCLevelIndication), t.writeUint8(this.lengthSizeMinusOne + 252), t.writeUint8(this.SPS.length + 224), e = 0; e < this.SPS.length; e++)t.writeUint16(this.SPS[e].length), t.writeUint8Array(this.SPS[e].nalu); for (t.writeUint8(this.PPS.length), e = 0; e < this.PPS.length; e++)t.writeUint16(this.PPS[e].length), t.writeUint8Array(this.PPS[e].nalu); this.ext && t.writeUint8Array(this.ext) }, BoxParser.co64Box.prototype.write = function (t) { var e; for (this.version = 0, this.flags = 0, this.size = 4 + 8 * this.chunk_offsets.length, this.writeHeader(t), t.writeUint32(this.chunk_offsets.length), e = 0; e < this.chunk_offsets.length; e++)t.writeUint64(this.chunk_offsets[e]) }, BoxParser.cslgBox.prototype.write = function (t) { this.version = 0, this.flags = 0, this.size = 20, this.writeHeader(t), t.writeInt32(this.compositionToDTSShift), t.writeInt32(this.leastDecodeToDisplayDelta), t.writeInt32(this.greatestDecodeToDisplayDelta), t.writeInt32(this.compositionStartTime), t.writeInt32(this.compositionEndTime) }, BoxParser.cttsBox.prototype.write = function (t) { var e; for (this.version = 0, this.flags = 0, this.size = 4 + 8 * this.sample_counts.length, this.writeHeader(t), t.writeUint32(this.sample_counts.length), e = 0; e < this.sample_counts.length; e++)t.writeUint32(this.sample_counts[e]), 1 === this.version ? t.writeInt32(this.sample_offsets[e]) : t.writeUint32(this.sample_offsets[e]) }, BoxParser.drefBox.prototype.write = function (t) { this.version = 0, this.flags = 0, this.size = 4, this.writeHeader(t), t.writeUint32(this.entries.length); for (var e = 0; e < this.entries.length; e++)this.entries[e].write(t), this.size += this.entries[e].size; Log.debug("BoxWriter", "Adjusting box " + this.type + " with new size " + this.size), t.adjustUint32(this.sizePosition, this.size) }, BoxParser.elngBox.prototype.write = function (t) { this.version = 0, this.flags = 0, this.size = this.extended_language.length, this.writeHeader(t), t.writeString(this.extended_language) }, BoxParser.elstBox.prototype.write = function (t) { this.version = 0, this.flags = 0, this.size = 4 + 12 * this.entries.length, this.writeHeader(t), t.writeUint32(this.entries.length); for (var e = 0; e < this.entries.length; e++) { var i = this.entries[e]; t.writeUint32(i.segment_duration), t.writeInt32(i.media_time), t.writeInt16(i.media_rate_integer), t.writeInt16(i.media_rate_fraction) } }, BoxParser.emsgBox.prototype.write = function (t) { this.version = 0, this.flags = 0, this.size = 16 + this.message_data.length + (this.scheme_id_uri.length + 1) + (this.value.length + 1), this.writeHeader(t), t.writeCString(this.scheme_id_uri), t.writeCString(this.value), t.writeUint32(this.timescale), t.writeUint32(this.presentation_time_delta), t.writeUint32(this.event_duration), t.writeUint32(this.id), t.writeUint8Array(this.message_data) }, BoxParser.ftypBox.prototype.write = function (t) { this.size = 8 + 4 * this.compatible_brands.length, this.writeHeader(t), t.writeString(this.major_brand, null, 4), t.writeUint32(this.minor_version); for (var e = 0; e < this.compatible_brands.length; e++)t.writeString(this.compatible_brands[e], null, 4) }, BoxParser.hdlrBox.prototype.write = function (t) { this.size = 20 + this.name.length + 1, this.version = 0, this.flags = 0, this.writeHeader(t), t.writeUint32(0), t.writeString(this.handler, null, 4), t.writeUint32(0), t.writeUint32(0), t.writeUint32(0), t.writeCString(this.name) }, BoxParser.kindBox.prototype.write = function (t) { this.version = 0, this.flags = 0, this.size = this.schemeURI.length + 1 + (this.value.length + 1), this.writeHeader(t), t.writeCString(this.schemeURI), t.writeCString(this.value) }, BoxParser.mdhdBox.prototype.write = function (t) { this.size = 20, this.flags = 0, this.version = 0, this.writeHeader(t), t.writeUint32(this.creation_time), t.writeUint32(this.modification_time), t.writeUint32(this.timescale), t.writeUint32(this.duration), t.writeUint16(this.language), t.writeUint16(0) }, BoxParser.mehdBox.prototype.write = function (t) { this.version = 0, this.flags = 0, this.size = 4, this.writeHeader(t), t.writeUint32(this.fragment_duration) }, BoxParser.mfhdBox.prototype.write = function (t) { this.version = 0, this.flags = 0, this.size = 4, this.writeHeader(t), t.writeUint32(this.sequence_number) }, BoxParser.mvhdBox.prototype.write = function (t) { this.version = 0, this.flags = 0, this.size = 96, this.writeHeader(t), t.writeUint32(this.creation_time), t.writeUint32(this.modification_time), t.writeUint32(this.timescale), t.writeUint32(this.duration), t.writeUint32(this.rate), t.writeUint16(this.volume << 8), t.writeUint16(0), t.writeUint32(0), t.writeUint32(0), t.writeUint32Array(this.matrix), t.writeUint32(0), t.writeUint32(0), t.writeUint32(0), t.writeUint32(0), t.writeUint32(0), t.writeUint32(0), t.writeUint32(this.next_track_id) }, BoxParser.SampleEntry.prototype.writeHeader = function (t) { this.size = 8, BoxParser.Box.prototype.writeHeader.call(this, t), t.writeUint8(0), t.writeUint8(0), t.writeUint8(0), t.writeUint8(0), t.writeUint8(0), t.writeUint8(0), t.writeUint16(this.data_reference_index) }, BoxParser.SampleEntry.prototype.writeFooter = function (t) { for (var e = 0; e < this.boxes.length; e++)this.boxes[e].write(t), this.size += this.boxes[e].size; Log.debug("BoxWriter", "Adjusting box " + this.type + " with new size " + this.size), t.adjustUint32(this.sizePosition, this.size) }, BoxParser.SampleEntry.prototype.write = function (t) { this.writeHeader(t), t.writeUint8Array(this.data), this.size += this.data.length, Log.debug("BoxWriter", "Adjusting box " + this.type + " with new size " + this.size), t.adjustUint32(this.sizePosition, this.size) }, BoxParser.VisualSampleEntry.prototype.write = function (t) { this.writeHeader(t), this.size += 70, t.writeUint16(0), t.writeUint16(0), t.writeUint32(0), t.writeUint32(0), t.writeUint32(0), t.writeUint16(this.width), t.writeUint16(this.height), t.writeUint32(this.horizresolution), t.writeUint32(this.vertresolution), t.writeUint32(0), t.writeUint16(this.frame_count), t.writeUint8(Math.min(31, this.compressorname.length)), t.writeString(this.compressorname, null, 31), t.writeUint16(this.depth), t.writeInt16(-1), this.writeFooter(t) }, BoxParser.AudioSampleEntry.prototype.write = function (t) { this.writeHeader(t), this.size += 20, t.writeUint32(0), t.writeUint32(0), t.writeUint16(this.channel_count), t.writeUint16(this.samplesize), t.writeUint16(0), t.writeUint16(0), t.writeUint32(this.samplerate << 16), this.writeFooter(t) }, BoxParser.stppSampleEntry.prototype.write = function (t) { this.writeHeader(t), this.size += this.namespace.length + 1 + this.schema_location.length + 1 + this.auxiliary_mime_types.length + 1, t.writeCString(this.namespace), t.writeCString(this.schema_location), t.writeCString(this.auxiliary_mime_types), this.writeFooter(t) }, BoxParser.SampleGroupEntry.prototype.write = function (t) { t.writeUint8Array(this.data) }, BoxParser.sbgpBox.prototype.write = function (t) { this.version = 1, this.flags = 0, this.size = 12 + 8 * this.entries.length, this.writeHeader(t), t.writeString(this.grouping_type, null, 4), t.writeUint32(this.grouping_type_parameter), t.writeUint32(this.entries.length); for (var e = 0; e < this.entries.length; e++) { var i = this.entries[e]; t.writeInt32(i.sample_count), t.writeInt32(i.group_description_index) } }, BoxParser.sgpdBox.prototype.write = function (t) { var e, i; for (this.flags = 0, this.size = 12, e = 0; e < this.entries.length; e++)i = this.entries[e], 1 === this.version && (0 === this.default_length && (this.size += 4), this.size += i.data.length); for (this.writeHeader(t), t.writeString(this.grouping_type, null, 4), 1 === this.version && t.writeUint32(this.default_length), 2 <= this.version && t.writeUint32(this.default_sample_description_index), t.writeUint32(this.entries.length), e = 0; e < this.entries.length; e++)i = this.entries[e], 1 === this.version && 0 === this.default_length && t.writeUint32(i.description_length), i.write(t) }, BoxParser.sidxBox.prototype.write = function (t) { this.version = 0, this.flags = 0, this.size = 20 + 12 * this.references.length, this.writeHeader(t), t.writeUint32(this.reference_ID), t.writeUint32(this.timescale), t.writeUint32(this.earliest_presentation_time), t.writeUint32(this.first_offset), t.writeUint16(0), t.writeUint16(this.references.length); for (var e = 0; e < this.references.length; e++) { var i = this.references[e]; t.writeUint32(i.reference_type << 31 | i.referenced_size), t.writeUint32(i.subsegment_duration), t.writeUint32(i.starts_with_SAP << 31 | i.SAP_type << 28 | i.SAP_delta_time) } }, BoxParser.smhdBox.prototype.write = function (t) { this.version = 0, this.flags = 1, this.size = 4, this.writeHeader(t), t.writeUint16(this.balance), t.writeUint16(0) }, BoxParser.stcoBox.prototype.write = function (t) { this.version = 0, this.flags = 0, this.size = 4 + 4 * this.chunk_offsets.length, this.writeHeader(t), t.writeUint32(this.chunk_offsets.length), t.writeUint32Array(this.chunk_offsets) }, BoxParser.stscBox.prototype.write = function (t) { var e; for (this.version = 0, this.flags = 0, this.size = 4 + 12 * this.first_chunk.length, this.writeHeader(t), t.writeUint32(this.first_chunk.length), e = 0; e < this.first_chunk.length; e++)t.writeUint32(this.first_chunk[e]), t.writeUint32(this.samples_per_chunk[e]), t.writeUint32(this.sample_description_index[e]) }, BoxParser.stsdBox.prototype.write = function (t) { var e; for (this.version = 0, this.flags = 0, this.size = 0, this.writeHeader(t), t.writeUint32(this.entries.length), this.size += 4, e = 0; e < this.entries.length; e++)this.entries[e].write(t), this.size += this.entries[e].size; Log.debug("BoxWriter", "Adjusting box " + this.type + " with new size " + this.size), t.adjustUint32(this.sizePosition, this.size) }, BoxParser.stshBox.prototype.write = function (t) { var e; for (this.version = 0, this.flags = 0, this.size = 4 + 8 * this.shadowed_sample_numbers.length, this.writeHeader(t), t.writeUint32(this.shadowed_sample_numbers.length), e = 0; e < this.shadowed_sample_numbers.length; e++)t.writeUint32(this.shadowed_sample_numbers[e]), t.writeUint32(this.sync_sample_numbers[e]) }, BoxParser.stssBox.prototype.write = function (t) { this.version = 0, this.flags = 0, this.size = 4 + 4 * this.sample_numbers.length, this.writeHeader(t), t.writeUint32(this.sample_numbers.length), t.writeUint32Array(this.sample_numbers) }, BoxParser.stszBox.prototype.write = function (t) { var e, i = !0; if (this.version = 0, (this.flags = 0) < this.sample_sizes.length) for (e = 0; e + 1 < this.sample_sizes.length;) { if (this.sample_sizes[e + 1] !== this.sample_sizes[0]) { i = !1; break } e++ } else i = !1; this.size = 8, i || (this.size += 4 * this.sample_sizes.length), this.writeHeader(t), i ? t.writeUint32(this.sample_sizes[0]) : t.writeUint32(0), t.writeUint32(this.sample_sizes.length), i || t.writeUint32Array(this.sample_sizes) }, BoxParser.sttsBox.prototype.write = function (t) { var e; for (this.version = 0, this.flags = 0, this.size = 4 + 8 * this.sample_counts.length, this.writeHeader(t), t.writeUint32(this.sample_counts.length), e = 0; e < this.sample_counts.length; e++)t.writeUint32(this.sample_counts[e]), t.writeUint32(this.sample_deltas[e]) }, BoxParser.tfdtBox.prototype.write = function (t) { var e = Math.pow(2, 32) - 1; this.version = this.baseMediaDecodeTime > e ? 1 : 0, this.flags = 0, this.size = 4, 1 === this.version && (this.size += 4), this.writeHeader(t), 1 === this.version ? t.writeUint64(this.baseMediaDecodeTime) : t.writeUint32(this.baseMediaDecodeTime) }, BoxParser.tfhdBox.prototype.write = function (t) { this.version = 0, this.size = 4, this.flags & BoxParser.TFHD_FLAG_BASE_DATA_OFFSET && (this.size += 8), this.flags & BoxParser.TFHD_FLAG_SAMPLE_DESC && (this.size += 4), this.flags & BoxParser.TFHD_FLAG_SAMPLE_DUR && (this.size += 4), this.flags & BoxParser.TFHD_FLAG_SAMPLE_SIZE && (this.size += 4), this.flags & BoxParser.TFHD_FLAG_SAMPLE_FLAGS && (this.size += 4), this.writeHeader(t), t.writeUint32(this.track_id), this.flags & BoxParser.TFHD_FLAG_BASE_DATA_OFFSET && t.writeUint64(this.base_data_offset), this.flags & BoxParser.TFHD_FLAG_SAMPLE_DESC && t.writeUint32(this.default_sample_description_index), this.flags & BoxParser.TFHD_FLAG_SAMPLE_DUR && t.writeUint32(this.default_sample_duration), this.flags & BoxParser.TFHD_FLAG_SAMPLE_SIZE && t.writeUint32(this.default_sample_size), this.flags & BoxParser.TFHD_FLAG_SAMPLE_FLAGS && t.writeUint32(this.default_sample_flags) }, BoxParser.tkhdBox.prototype.write = function (t) { this.version = 0, this.size = 80, this.writeHeader(t), t.writeUint32(this.creation_time), t.writeUint32(this.modification_time), t.writeUint32(this.track_id), t.writeUint32(0), t.writeUint32(this.duration), t.writeUint32(0), t.writeUint32(0), t.writeInt16(this.layer), t.writeInt16(this.alternate_group), t.writeInt16(this.volume << 8), t.writeUint16(0), t.writeInt32Array(this.matrix), t.writeUint32(this.width), t.writeUint32(this.height) }, BoxParser.trexBox.prototype.write = function (t) { this.version = 0, this.flags = 0, this.size = 20, this.writeHeader(t), t.writeUint32(this.track_id), t.writeUint32(this.default_sample_description_index), t.writeUint32(this.default_sample_duration), t.writeUint32(this.default_sample_size), t.writeUint32(this.default_sample_flags) }, BoxParser.trunBox.prototype.write = function (t) { this.version = 0, this.size = 4, this.flags & BoxParser.TRUN_FLAGS_DATA_OFFSET && (this.size += 4), this.flags & BoxParser.TRUN_FLAGS_FIRST_FLAG && (this.size += 4), this.flags & BoxParser.TRUN_FLAGS_DURATION && (this.size += 4 * this.sample_duration.length), this.flags & BoxParser.TRUN_FLAGS_SIZE && (this.size += 4 * this.sample_size.length), this.flags & BoxParser.TRUN_FLAGS_FLAGS && (this.size += 4 * this.sample_flags.length), this.flags & BoxParser.TRUN_FLAGS_CTS_OFFSET && (this.size += 4 * this.sample_composition_time_offset.length), this.writeHeader(t), t.writeUint32(this.sample_count), this.flags & BoxParser.TRUN_FLAGS_DATA_OFFSET && (this.data_offset_position = t.getPosition(), t.writeInt32(this.data_offset)), this.flags & BoxParser.TRUN_FLAGS_FIRST_FLAG && t.writeUint32(this.first_sample_flags); for (var e = 0; e < this.sample_count; e++)this.flags & BoxParser.TRUN_FLAGS_DURATION && t.writeUint32(this.sample_duration[e]), this.flags & BoxParser.TRUN_FLAGS_SIZE && t.writeUint32(this.sample_size[e]), this.flags & BoxParser.TRUN_FLAGS_FLAGS && t.writeUint32(this.sample_flags[e]), this.flags & BoxParser.TRUN_FLAGS_CTS_OFFSET && (0 === this.version ? t.writeUint32(this.sample_composition_time_offset[e]) : t.writeInt32(this.sample_composition_time_offset[e])) }, BoxParser["url Box"].prototype.write = function (t) { this.version = 0, this.location ? (this.flags = 0, this.size = this.location.length + 1) : (this.flags = 1, this.size = 0), this.writeHeader(t), this.location && t.writeCString(this.location) }, BoxParser["urn Box"].prototype.write = function (t) { this.version = 0, this.flags = 0, this.size = this.name.length + 1 + (this.location ? this.location.length + 1 : 0), this.writeHeader(t), t.writeCString(this.name), this.location && t.writeCString(this.location) }, BoxParser.vmhdBox.prototype.write = function (t) { this.version = 0, this.flags = 1, this.size = 8, this.writeHeader(t), t.writeUint16(this.graphicsmode), t.writeUint16Array(this.opcolor) }, BoxParser.cttsBox.prototype.unpack = function (t) { for (var e, i = 0, r = 0; r < this.sample_counts.length; r++)for (e = 0; e < this.sample_counts[r]; e++)t[i].pts = t[i].dts + this.sample_offsets[r], i++ }, BoxParser.sttsBox.prototype.unpack = function (t) { for (var e, i = 0, r = 0; r < this.sample_counts.length; r++)for (e = 0; e < this.sample_counts[r]; e++)t[i].dts = 0 === i ? 0 : t[i - 1].dts + this.sample_deltas[r], i++ }, BoxParser.stcoBox.prototype.unpack = function (t) { for (var e = 0; e < this.chunk_offsets.length; e++)t[e].offset = this.chunk_offsets[e] }, BoxParser.stscBox.prototype.unpack = function (t) { for (var e, i, r = 0, s = 0, a = 0; a < this.first_chunk.length; a++)for (e = 0; e < (a + 1 < this.first_chunk.length ? this.first_chunk[a + 1] : 1 / 0); e++)for (s++, i = 0; i < this.samples_per_chunk[a]; i++) { if (!t[r]) return; t[r].description_index = this.sample_description_index[a], t[r].chunk_index = s, r++ } }, BoxParser.stszBox.prototype.unpack = function (t) { for (var e = 0; e < this.sample_sizes.length; e++)t[e].size = this.sample_sizes[e] }, BoxParser.DIFF_BOXES_PROP_NAMES = ["boxes", "entries", "references", "subsamples", "items", "item_infos", "extents", "associations", "subsegments", "ranges", "seekLists", "seekPoints", "esd", "levels"], BoxParser.DIFF_PRIMITIVE_ARRAY_PROP_NAMES = ["compatible_brands", "matrix", "opcolor", "sample_counts", "sample_counts", "sample_deltas", "first_chunk", "samples_per_chunk", "sample_sizes", "chunk_offsets", "sample_offsets", "sample_description_index", "sample_duration"], BoxParser.boxEqualFields = function (t, e) { if (t && !e) return !1; for (var i in t) if (!(-1 < BoxParser.DIFF_BOXES_PROP_NAMES.indexOf(i) || t[i] instanceof BoxParser.Box || e[i] instanceof BoxParser.Box || void 0 === t[i] || void 0 === e[i] || "function" == typeof t[i] || "function" == typeof e[i] || t.subBoxNames && -1 < t.subBoxNames.indexOf(i.slice(0, 4)) || e.subBoxNames && -1 < e.subBoxNames.indexOf(i.slice(0, 4)) || "data" === i || "start" === i || "size" === i || "creation_time" === i || "modification_time" === i || -1 < BoxParser.DIFF_PRIMITIVE_ARRAY_PROP_NAMES.indexOf(i) || t[i] === e[i])) return !1; return !0 }, BoxParser.boxEqual = function (t, e) { if (!BoxParser.boxEqualFields(t, e)) return !1; for (var i = 0; i < BoxParser.DIFF_BOXES_PROP_NAMES.length; i++) { var r = BoxParser.DIFF_BOXES_PROP_NAMES[i]; if (t[r] && e[r] && !BoxParser.boxEqual(t[r], e[r])) return !1 } return !0 }; var VTTin4Parser = function () { }; VTTin4Parser.prototype.parseSample = function (t) { for (var e, i = new MP4BoxStream(t.buffer), r = []; !i.isEos();)(e = BoxParser.parseOneBox(i, !1)).code === BoxParser.OK && "vttc" === e.box.type && r.push(e.box); return r }, VTTin4Parser.prototype.getText = function (t, e, i) { function s(t, e, i) { return i = i || "0", (t += "").length >= e ? t : new Array(e - t.length + 1).join(i) + t } function r(t) { var e = Math.floor(t / 3600), i = Math.floor((t - 3600 * e) / 60), r = Math.floor(t - 3600 * e - 60 * i), t = Math.floor(1e3 * (t - 3600 * e - 60 * i - r)); return s(e, 2) + ":" + s(i, 2) + ":" + s(r, 2) + "." + s(t, 3) } for (var a = this.parseSample(i), n = "", o = 0; o < a.length; o++) { var h = a[o]; n += r(t) + " --\x3e " + r(e) + "\r\n", n += h.payl.text } return n }; var XMLSubtitlein4Parser = function () { }; XMLSubtitlein4Parser.prototype.parseSample = function (t) { var e, i = { resources: [] }, r = new MP4BoxStream(t.data.buffer); if (t.subsamples && 0 !== t.subsamples.length) { if (i.documentString = r.readString(t.subsamples[0].size), 1 < t.subsamples.length) for (e = 1; e < t.subsamples.length; e++)i.resources[e] = r.readUint8Array(t.subsamples[e].size) } else i.documentString = r.readString(t.data.length); return "undefined" != typeof DOMParser && (i.document = (new DOMParser).parseFromString(i.documentString, "application/xml")), i }; var Textin4Parser = function () { }; Textin4Parser.prototype.parseSample = function (t) { return new MP4BoxStream(t.data.buffer).readString(t.data.length) }, Textin4Parser.prototype.parseConfig = function (t) { t = new MP4BoxStream(t.buffer); return t.readUint32(), t.readCString() }, "undefined" != typeof exports && (exports.XMLSubtitlein4Parser = XMLSubtitlein4Parser, exports.Textin4Parser = Textin4Parser); var ISOFile = function (t) { this.stream = t || new MultiBufferStream, this.boxes = [], this.mdats = [], this.moofs = [], this.isProgressive = !1, this.moovStartFound = !1, this.onMoovStart = null, this.moovStartSent = !1, this.onReady = null, this.readySent = !1, this.onSegment = null, this.onSamples = null, this.onError = null, this.sampleListBuilt = !1, this.fragmentedTracks = [], this.extractedTracks = [], this.isFragmentationInitialized = !1, this.sampleProcessingStarted = !1, this.nextMoofNumber = 0, this.itemListBuilt = !1, this.onSidx = null, this.sidxSent = !1 }; ISOFile.prototype.setSegmentOptions = function (t, e, i) { var r, s = this.getTrackById(t); s && (r = {}, this.fragmentedTracks.push(r), r.id = t, r.user = e, (r.trak = s).nextSample = 0, r.segmentStream = null, r.nb_samples = 1e3, r.rapAlignement = !0, i && (i.nbSamples && (r.nb_samples = i.nbSamples), i.rapAlignement && (r.rapAlignement = i.rapAlignement))) }, ISOFile.prototype.unsetSegmentOptions = function (t) { for (var e = -1, i = 0; i < this.fragmentedTracks.length; i++)this.fragmentedTracks[i].id == t && (e = i); -1 < e && this.fragmentedTracks.splice(e, 1) }, ISOFile.prototype.setExtractionOptions = function (t, e, i) { var r, s = this.getTrackById(t); s && (r = {}, this.extractedTracks.push(r), r.id = t, r.user = e, (r.trak = s).nextSample = 0, r.nb_samples = 1e3, r.samples = [], i && i.nbSamples && (r.nb_samples = i.nbSamples)) }, ISOFile.prototype.unsetExtractionOptions = function (t) { for (var e = -1, i = 0; i < this.extractedTracks.length; i++)this.extractedTracks[i].id == t && (e = i); -1 < e && this.extractedTracks.splice(e, 1) }, ISOFile.prototype.parse = function () { var t; if (!this.restoreParsePosition || this.restoreParsePosition()) for (; ;)if (this.hasIncompleteMdat && this.hasIncompleteMdat()) { if (!this.processIncompleteMdat()) return } else if (this.saveParsePosition && this.saveParsePosition(), (t = BoxParser.parseOneBox(this.stream, !1)).code === BoxParser.ERR_NOT_ENOUGH_DATA) { if (!this.processIncompleteBox) return; if (!this.processIncompleteBox(t)) return } else { var e, i = "uuid" !== (e = t.box).type ? e.type : e.uuid; switch (this.boxes.push(e), i) { case "mdat": this.mdats.push(e); break; case "moof": this.moofs.push(e); break; case "moov": this.moovStartFound = !0, 0 === this.mdats.length && (this.isProgressive = !0); default: void 0 !== this[i] && Log.warn("ISOFile", "Duplicate Box of type: " + i + ", overriding previous occurrence"), this[i] = e }this.updateUsedBytes && this.updateUsedBytes(e, t) } }, ISOFile.prototype.checkBuffer = function (t) { if (null == t) throw "Buffer must be defined and non empty"; if (void 0 === t.fileStart) throw "Buffer must have a fileStart property"; return 0 === t.byteLength ? (Log.warn("ISOFile", "Ignoring empty buffer (fileStart: " + t.fileStart + ")"), this.stream.logBufferLevel(), !1) : (Log.info("ISOFile", "Processing buffer (fileStart: " + t.fileStart + ")"), t.usedBytes = 0, this.stream.insertBuffer(t), this.stream.logBufferLevel(), !!this.stream.initialized() || (Log.warn("ISOFile", "Not ready to start parsing"), !1)) }, ISOFile.prototype.appendBuffer = function (t, e) { var i; if (this.checkBuffer(t)) return this.parse(), this.moovStartFound && !this.moovStartSent && (this.moovStartSent = !0, this.onMoovStart && this.onMoovStart()), this.moov ? (this.sampleListBuilt || (this.buildSampleLists(), this.sampleListBuilt = !0), this.updateSampleLists(), this.onReady && !this.readySent && (this.readySent = !0, this.onReady(this.getInfo())), this.processSamples(e), this.nextSeekPosition ? (i = this.nextSeekPosition, this.nextSeekPosition = void 0) : i = this.nextParsePosition, this.stream.getEndFilePositionAfter && (i = this.stream.getEndFilePositionAfter(i))) : i = this.nextParsePosition || 0, this.sidx && this.onSidx && !this.sidxSent && (this.onSidx(this.sidx), this.sidxSent = !0), this.meta && (this.flattenItemInfo && !this.itemListBuilt && (this.flattenItemInfo(), this.itemListBuilt = !0), this.processItems && this.processItems(this.onItem)), this.stream.cleanBuffers && (Log.info("ISOFile", "Done processing buffer (fileStart: " + t.fileStart + ") - next buffer to fetch should have a fileStart position of " + i), this.stream.logBufferLevel(), this.stream.cleanBuffers(), this.stream.logBufferLevel(!0), Log.info("ISOFile", "Sample data size in memory: " + this.getAllocatedSampleDataSize())), i }, ISOFile.prototype.getInfo = function () { var t, e, i, r, s, a, n = {}, o = new Date("1904-01-01T00:00:00Z").getTime(); if (this.moov) for (n.hasMoov = !0, n.duration = this.moov.mvhd.duration, n.timescale = this.moov.mvhd.timescale, n.isFragmented = null != this.moov.mvex, n.isFragmented && this.moov.mvex.mehd && (n.fragment_duration = this.moov.mvex.mehd.fragment_duration), n.isProgressive = this.isProgressive, n.hasIOD = null != this.moov.iods, n.brands = [], n.brands.push(this.ftyp.major_brand), n.brands = n.brands.concat(this.ftyp.compatible_brands), n.created = new Date(o + 1e3 * this.moov.mvhd.creation_time), n.modified = new Date(o + 1e3 * this.moov.mvhd.modification_time), n.tracks = [], n.audioTracks = [], n.videoTracks = [], n.subtitleTracks = [], n.metadataTracks = [], n.hintTracks = [], n.otherTracks = [], t = 0; t < this.moov.traks.length; t++) { if (a = (i = this.moov.traks[t]).mdia.minf.stbl.stsd.entries[0], r = {}, n.tracks.push(r), r.id = i.tkhd.track_id, r.name = i.mdia.hdlr.name, r.references = [], i.tref) for (e = 0; e < i.tref.boxes.length; e++)s = {}, r.references.push(s), s.type = i.tref.boxes[e].type, s.track_ids = i.tref.boxes[e].track_ids; i.edts && (r.edits = i.edts.elst.entries), r.created = new Date(o + 1e3 * i.tkhd.creation_time), r.modified = new Date(o + 1e3 * i.tkhd.modification_time), r.movie_duration = i.tkhd.duration, r.movie_timescale = n.timescale, r.layer = i.tkhd.layer, r.alternate_group = i.tkhd.alternate_group, r.volume = i.tkhd.volume, r.matrix = i.tkhd.matrix, r.track_width = i.tkhd.width / 65536, r.track_height = i.tkhd.height / 65536, r.timescale = i.mdia.mdhd.timescale, r.cts_shift = i.mdia.minf.stbl.cslg, r.duration = i.mdia.mdhd.duration, r.samples_duration = i.samples_duration, r.codec = a.getCodec(), r.kind = i.udta && i.udta.kinds.length ? i.udta.kinds[0] : { schemeURI: "", value: "" }, r.language = i.mdia.elng ? i.mdia.elng.extended_language : i.mdia.mdhd.languageString, r.nb_samples = i.samples.length, r.size = i.samples_size, r.bitrate = 8 * r.size * r.timescale / r.samples_duration, a.isAudio() ? (r.type = "audio", n.audioTracks.push(r), r.audio = {}, r.audio.sample_rate = a.getSampleRate(), r.audio.channel_count = a.getChannelCount(), r.audio.sample_size = a.getSampleSize()) : a.isVideo() ? (r.type = "video", n.videoTracks.push(r), r.video = {}, r.video.width = a.getWidth(), r.video.height = a.getHeight()) : a.isSubtitle() ? (r.type = "subtitles", n.subtitleTracks.push(r)) : a.isHint() ? (r.type = "metadata", n.hintTracks.push(r)) : a.isMetadata() ? (r.type = "metadata", n.metadataTracks.push(r)) : (r.type = "metadata", n.otherTracks.push(r)) } else n.hasMoov = !1; if (n.mime = "", n.hasMoov && n.tracks) { for (n.videoTracks && 0 < n.videoTracks.length ? n.mime += 'video/mp4; codecs="' : n.audioTracks && 0 < n.audioTracks.length ? n.mime += 'audio/mp4; codecs="' : n.mime += 'application/mp4; codecs="', t = 0; t < n.tracks.length; t++)0 !== t && (n.mime += ","), n.mime += n.tracks[t].codec; n.mime += '"; profiles="', n.mime += this.ftyp.compatible_brands.join(), n.mime += '"' } return n }, ISOFile.prototype.processSamples = function (t) { var e; if (this.sampleProcessingStarted) { if (this.isFragmentationInitialized && null !== this.onSegment) for (e = 0; e < this.fragmentedTracks.length; e++)for (var i = this.fragmentedTracks[e], r = i.trak; r.nextSample < r.samples.length && this.sampleProcessingStarted;) { Log.debug("ISOFile", "Creating media fragment on track #" + i.id + " for sample " + r.nextSample); var s = this.createFragment(i.id, r.nextSample, i.segmentStream); if (!s) break; if (i.segmentStream = s, r.nextSample++, (r.nextSample % i.nb_samples == 0 || t || r.nextSample >= r.samples.length) && (Log.info("ISOFile", "Sending fragmented data on track #" + i.id + " for samples [" + Math.max(0, r.nextSample - i.nb_samples) + "," + (r.nextSample - 1) + "]"), Log.info("ISOFile", "Sample data size in memory: " + this.getAllocatedSampleDataSize()), this.onSegment && this.onSegment(i.id, i.user, i.segmentStream.buffer, r.nextSample, t || r.nextSample >= r.samples.length), i.segmentStream = null, i !== this.fragmentedTracks[e])) break } if (null !== this.onSamples) for (e = 0; e < this.extractedTracks.length; e++) { var a = this.extractedTracks[e]; for (r = a.trak; r.nextSample < r.samples.length && this.sampleProcessingStarted;) { Log.debug("ISOFile", "Exporting on track #" + a.id + " sample #" + r.nextSample); var n = this.getSample(r, r.nextSample); if (!n) break; if (r.nextSample++, a.samples.push(n), (r.nextSample % a.nb_samples == 0 || r.nextSample >= r.samples.length) && (Log.debug("ISOFile", "Sending samples on track #" + a.id + " for sample " + r.nextSample), this.onSamples && this.onSamples(a.id, a.user, a.samples), a.samples = [], a !== this.extractedTracks[e])) break } } } }, ISOFile.prototype.getBox = function (t) { t = this.getBoxes(t, !0); return t.length ? t[0] : null }, ISOFile.prototype.getBoxes = function (t, e) { var i = []; return ISOFile._sweep.call(this, t, i, e), i }, ISOFile._sweep = function (t, e, i) { for (var r in this.type && this.type == t && e.push(this), this.boxes) { if (e.length && i) return; ISOFile._sweep.call(this.boxes[r], t, e, i) } }, ISOFile.prototype.getTrackSamplesInfo = function (t) { t = this.getTrackById(t); if (t) return t.samples }, ISOFile.prototype.getTrackSample = function (t, e) { t = this.getTrackById(t); return this.getSample(t, e) }, ISOFile.prototype.releaseUsedSamples = function (t, e) { var i = 0, r = this.getTrackById(t); r.lastValidSample || (r.lastValidSample = 0); for (var s = r.lastValidSample; s < e; s++)i += this.releaseSample(r, s); Log.info("ISOFile", "Track #" + t + " released samples up to " + e + " (released size: " + i + ", remaining: " + this.samplesDataSize + ")"), r.lastValidSample = e }, ISOFile.prototype.start = function () { this.sampleProcessingStarted = !0, this.processSamples(!1) }, ISOFile.prototype.stop = function () { this.sampleProcessingStarted = !1 }, ISOFile.prototype.flush = function () { Log.info("ISOFile", "Flushing remaining samples"), this.updateSampleLists(), this.processSamples(!0), this.stream.cleanBuffers(), this.stream.logBufferLevel(!0) }, ISOFile.prototype.seekTrack = function (t, e, i) { var r, s, a, n, o = 0, h = 0; if (0 === i.samples.length) return Log.info("ISOFile", "No sample in track, cannot seek! Using time " + Log.getDurationString(0, 1) + " and offset: 0"), { offset: 0, time: 0 }; for (r = 0; r < i.samples.length; r++) { if (s = i.samples[r], 0 === r) h = 0, n = s.timescale; else if (s.cts > t * s.timescale) { h = r - 1; break } e && s.is_sync && (o = r) } for (e && (h = o), t = i.samples[h].cts, i.nextSample = h; i.samples[h].alreadyRead === i.samples[h].size && i.samples[h + 1];)h++; return a = i.samples[h].offset + i.samples[h].alreadyRead, Log.info("ISOFile", "Seeking to " + (e ? "RAP" : "") + " sample #" + i.nextSample + " on track " + i.tkhd.track_id + ", time " + Log.getDurationString(t, n) + " and offset: " + a), { offset: a, time: t / n } }, ISOFile.prototype.seek = function (t, e) { var i, r, s = this.moov, a = { offset: 1 / 0, time: 1 / 0 }; if (this.moov) { for (r = 0; r < s.traks.length; r++)i = s.traks[r], (i = this.seekTrack(t, e, i)).offset < a.offset && (a.offset = i.offset), i.time < a.time && (a.time = i.time); return Log.info("ISOFile", "Seeking at time " + Log.getDurationString(a.time, 1) + " needs a buffer with a fileStart position of " + a.offset), a.offset === 1 / 0 ? a = { offset: this.nextParsePosition, time: 0 } : a.offset = this.stream.getEndFilePositionAfter(a.offset), Log.info("ISOFile", "Adjusted seek position (after checking data already in buffer): " + a.offset), a } throw "Cannot seek: moov not received!" }, ISOFile.prototype.equal = function (t) { for (var e = 0; e < this.boxes.length && e < t.boxes.length;) { var i = this.boxes[e], r = t.boxes[e]; if (!BoxParser.boxEqual(i, r)) return !1; e++ } return !0 }, "undefined" != typeof exports && (exports.ISOFile = ISOFile), ISOFile.prototype.lastBoxStartPosition = 0, ISOFile.prototype.parsingMdat = null, ISOFile.prototype.nextParsePosition = 0, ISOFile.prototype.discardMdatData = !1, ISOFile.prototype.processIncompleteBox = function (t) { var e; return "mdat" === t.type ? (e = new BoxParser[t.type + "Box"](t.size), this.parsingMdat = e, this.boxes.push(e), this.mdats.push(e), e.start = t.start, e.hdr_size = t.hdr_size, this.stream.addUsedBytes(e.hdr_size), this.lastBoxStartPosition = e.start + e.size, this.stream.seek(e.start + e.size, !1, this.discardMdatData) ? !(this.parsingMdat = null) : (this.moovStartFound ? this.nextParsePosition = this.stream.findEndContiguousBuf() : this.nextParsePosition = e.start + e.size, !1)) : ("moov" === t.type && (this.moovStartFound = !0, 0 === this.mdats.length && (this.isProgressive = !0)), !!this.stream.mergeNextBuffer && this.stream.mergeNextBuffer() ? (this.nextParsePosition = this.stream.getEndPosition(), !0) : (!t.type || this.moovStartFound ? this.nextParsePosition = this.stream.getEndPosition() : this.nextParsePosition = this.stream.getPosition() + t.size, !1)) }, ISOFile.prototype.hasIncompleteMdat = function () { return null !== this.parsingMdat }, ISOFile.prototype.processIncompleteMdat = function () { var t = this.parsingMdat; return this.stream.seek(t.start + t.size, !1, this.discardMdatData) ? (Log.debug("ISOFile", "Found 'mdat' end in buffered data"), !(this.parsingMdat = null)) : (this.nextParsePosition = this.stream.findEndContiguousBuf(), !1) }, ISOFile.prototype.restoreParsePosition = function () { return this.stream.seek(this.lastBoxStartPosition, !0, this.discardMdatData) }, ISOFile.prototype.saveParsePosition = function () { this.lastBoxStartPosition = this.stream.getPosition() }, ISOFile.prototype.updateUsedBytes = function (t, e) { this.stream.addUsedBytes && ("mdat" === t.type ? (this.stream.addUsedBytes(t.hdr_size), this.discardMdatData && this.stream.addUsedBytes(t.size - t.hdr_size)) : this.stream.addUsedBytes(t.size)) }, ISOFile.prototype.add = BoxParser.Box.prototype.add, ISOFile.prototype.addBox = BoxParser.Box.prototype.addBox, ISOFile.prototype.init = function (t) { var e = t || {}, t = (this.add("ftyp").set("major_brand", e.brands && e.brands[0] || "iso4").set("minor_version", 0).set("compatible_brands", e.brands || ["iso4"]), this.add("moov")); return t.add("mvhd").set("timescale", e.timescale || 600).set("rate", e.rate || 65536).set("creation_time", 0).set("modification_time", 0).set("duration", e.duration || 0).set("volume", e.width ? 0 : 256).set("matrix", [65536, 0, 0, 0, 65536, 0, 0, 0, 1073741824]).set("next_track_id", 1), t.add("mvex"), this }, ISOFile.prototype.addTrack = function (t) { this.moov || this.init(t); var e = t || {}; e.width = e.width || 320, e.height = e.height || 320, e.id = e.id || this.moov.mvhd.next_track_id, e.type = e.type || "avc1"; var i = this.moov.add("trak"); this.moov.mvhd.next_track_id = e.id + 1, i.add("tkhd").set("flags", BoxParser.TKHD_FLAG_ENABLED | BoxParser.TKHD_FLAG_IN_MOVIE | BoxParser.TKHD_FLAG_IN_PREVIEW).set("creation_time", 0).set("modification_time", 0).set("track_id", e.id).set("duration", e.duration || 0).set("layer", e.layer || 0).set("alternate_group", 0).set("volume", 1).set("matrix", [0, 0, 0, 0, 0, 0, 0, 0, 0]).set("width", e.width << 16).set("height", e.height << 16); t = i.add("mdia"); t.add("mdhd").set("creation_time", 0).set("modification_time", 0).set("timescale", e.timescale || 1).set("duration", e.media_duration || 0).set("language", e.language || "und"), t.add("hdlr").set("handler", e.hdlr || "vide").set("name", e.name || "Track created with MP4Box.js"), t.add("elng").set("extended_language", e.language || "fr-FR"); var r = t.add("minf"); if (void 0 !== BoxParser[e.type + "SampleEntry"]) { var s = new BoxParser[e.type + "SampleEntry"]; s.data_reference_index = 1; var a, n, o, h = ""; for (a in BoxParser.sampleEntryCodes) for (var d = BoxParser.sampleEntryCodes[a], l = 0; l < d.length; l++)if (-1 < d.indexOf(e.type)) { h = a; break } switch (h) { case "Visual": r.add("vmhd").set("graphicsmode", 0).set("opcolor", [0, 0, 0]), s.set("width", e.width).set("height", e.height).set("horizresolution", 72 << 16).set("vertresolution", 72 << 16).set("frame_count", 1).set("compressorname", e.type + " Compressor").set("depth", 24), e.avcDecoderConfigRecord && (n = new BoxParser.avcCBox, o = new MP4BoxStream(e.avcDecoderConfigRecord), n.parse(o), s.addBox(n)); break; case "Audio": r.add("smhd").set("balance", e.balance || 0), s.set("channel_count", e.channel_count || 2).set("samplesize", e.samplesize || 16).set("samplerate", e.samplerate || 65536); break; case "Hint": r.add("hmhd"); break; case "Subtitle": r.add("sthd"), "stpp" === e.type && s.set("namespace", e.namespace || "nonamespace").set("schema_location", e.schema_location || "").set("auxiliary_mime_types", e.auxiliary_mime_types || ""); break; case "Metadata": case "System": default: r.add("nmhd") }e.description && s.addBox(e.description), e.description_boxes && e.description_boxes.forEach(function (t) { s.addBox(t) }), r.add("dinf").add("dref").addEntry((new BoxParser["url Box"]).set("flags", 1)); t = r.add("stbl"); return t.add("stsd").addEntry(s), t.add("stts").set("sample_counts", []).set("sample_deltas", []), t.add("stsc").set("first_chunk", []).set("samples_per_chunk", []).set("sample_description_index", []), t.add("stco").set("chunk_offsets", []), t.add("stsz").set("sample_sizes", []), this.moov.mvex.add("trex").set("track_id", e.id).set("default_sample_description_index", e.default_sample_description_index || 1).set("default_sample_duration", e.default_sample_duration || 0).set("default_sample_size", e.default_sample_size || 0).set("default_sample_flags", e.default_sample_flags || 0), this.buildTrakSampleLists(i), e.id } }, BoxParser.Box.prototype.computeSize = function (t) { t = t || new DataStream; t.endianness = DataStream.BIG_ENDIAN, this.write(t) }, ISOFile.prototype.addSample = function (t, e, i) { var r = i || {}, i = {}, t = this.getTrackById(t); if (null !== t) { i.number = t.samples.length, i.track_id = t.tkhd.track_id, i.timescale = t.mdia.mdhd.timescale, i.description_index = r.sample_description_index ? r.sample_description_index - 1 : 0, i.description = t.mdia.minf.stbl.stsd.entries[i.description_index], i.data = e, i.size = e.byteLength, i.alreadyRead = i.size, i.duration = r.duration || 1, i.cts = r.cts || 0, i.dts = r.dts || 0, i.is_sync = r.is_sync || !1, i.is_leading = r.is_leading || 0, i.depends_on = r.depends_on || 0, i.is_depended_on = r.is_depended_on || 0, i.has_redundancy = r.has_redundancy || 0, i.degradation_priority = r.degradation_priority || 0, i.offset = 0, i.subsamples = r.subsamples, t.samples.push(i), t.samples_size += i.size, t.samples_duration += i.duration, t.first_dts || (t.first_dts = r.dts), this.processSamples(); r = this.createSingleSampleMoof(i); return this.addBox(r), r.computeSize(), r.trafs[0].truns[0].data_offset = r.size + 8, this.add("mdat").data = new Uint8Array(e), i } }, ISOFile.prototype.createSingleSampleMoof = function (t) { var e = 0, e = t.is_sync ? 1 << 25 : 65536, i = new BoxParser.moofBox; i.add("mfhd").set("sequence_number", this.nextMoofNumber), this.nextMoofNumber++; var r = i.add("traf"), s = this.getTrackById(t.track_id); return r.add("tfhd").set("track_id", t.track_id).set("flags", BoxParser.TFHD_FLAG_DEFAULT_BASE_IS_MOOF), r.add("tfdt").set("baseMediaDecodeTime", t.dts - (s.first_dts || 0)), r.add("trun").set("flags", BoxParser.TRUN_FLAGS_DATA_OFFSET | BoxParser.TRUN_FLAGS_DURATION | BoxParser.TRUN_FLAGS_SIZE | BoxParser.TRUN_FLAGS_FLAGS | BoxParser.TRUN_FLAGS_CTS_OFFSET).set("data_offset", 0).set("first_sample_flags", 0).set("sample_count", 1).set("sample_duration", [t.duration]).set("sample_size", [t.size]).set("sample_flags", [e]).set("sample_composition_time_offset", [t.cts - t.dts]), i }, ISOFile.prototype.lastMoofIndex = 0, ISOFile.prototype.samplesDataSize = 0, ISOFile.prototype.resetTables = function () { var t, e; for (this.initial_duration = this.moov.mvhd.duration, t = this.moov.mvhd.duration = 0; t < this.moov.traks.length; t++) { (e = this.moov.traks[t]).tkhd.duration = 0, e.mdia.mdhd.duration = 0, (e.mdia.minf.stbl.stco || e.mdia.minf.stbl.co64).chunk_offsets = [], (i = e.mdia.minf.stbl.stsc).first_chunk = [], i.samples_per_chunk = [], i.sample_description_index = [], (e.mdia.minf.stbl.stsz || e.mdia.minf.stbl.stz2).sample_sizes = [], (i = e.mdia.minf.stbl.stts).sample_counts = [], i.sample_deltas = [], (i = e.mdia.minf.stbl.ctts) && (i.sample_counts = [], i.sample_offsets = []), i = e.mdia.minf.stbl.stss; var i = e.mdia.minf.stbl.boxes.indexOf(i); -1 != i && (e.mdia.minf.stbl.boxes[i] = null) } }, ISOFile.initSampleGroups = function (t, e, i, r, s) { var a, n, o, h; function d(t, e, i) { this.grouping_type = t, this.grouping_type_parameter = e, this.sbgp = i, this.last_sample_in_run = -1, this.entry_index = -1 } for (e && (e.sample_groups_info = []), t.sample_groups_info || (t.sample_groups_info = []), n = 0; n < i.length; n++) { for (h = i[n].grouping_type + "/" + i[n].grouping_type_parameter, o = new d(i[n].grouping_type, i[n].grouping_type_parameter, i[n]), e && (e.sample_groups_info[h] = o), t.sample_groups_info[h] || (t.sample_groups_info[h] = o), a = 0; a < r.length; a++)r[a].grouping_type === i[n].grouping_type && (o.description = r[a], o.description.used = !0); if (s) for (a = 0; a < s.length; a++)s[a].grouping_type === i[n].grouping_type && (o.fragment_description = s[a], o.fragment_description.used = !0, o.is_fragment = !0) } if (e) { if (s) for (n = 0; n < s.length; n++)!s[n].used && 2 <= s[n].version && (h = s[n].grouping_type + "/0", (o = new d(s[n].grouping_type, 0)).is_fragment = !0, e.sample_groups_info[h] || (e.sample_groups_info[h] = o)) } else for (n = 0; n < r.length; n++)!r[n].used && 2 <= r[n].version && (h = r[n].grouping_type + "/0", o = new d(r[n].grouping_type, 0), t.sample_groups_info[h] || (t.sample_groups_info[h] = o)) }, ISOFile.setSampleGroupProperties = function (t, e, i, r) { var s, a, n; for (s in e.sample_groups = [], r) e.sample_groups[s] = {}, e.sample_groups[s].grouping_type = r[s].grouping_type, e.sample_groups[s].grouping_type_parameter = r[s].grouping_type_parameter, i >= r[s].last_sample_in_run && (r[s].last_sample_in_run < 0 && (r[s].last_sample_in_run = 0), r[s].entry_index++, r[s].entry_index <= r[s].sbgp.entries.length - 1 && (r[s].last_sample_in_run += r[s].sbgp.entries[r[s].entry_index].sample_count)), r[s].entry_index <= r[s].sbgp.entries.length - 1 ? e.sample_groups[s].group_description_index = r[s].sbgp.entries[r[s].entry_index].group_description_index : e.sample_groups[s].group_description_index = -1, 0 !== e.sample_groups[s].group_description_index && (n = r[s].fragment_description || r[s].description, 0 < e.sample_groups[s].group_description_index ? (a = 65535 < e.sample_groups[s].group_description_index ? (e.sample_groups[s].group_description_index >> 16) - 1 : e.sample_groups[s].group_description_index - 1, n && 0 <= a && (e.sample_groups[s].description = n.entries[a])) : n && 2 <= n.version && 0 < n.default_group_description_index && (e.sample_groups[s].description = n.entries[n.default_group_description_index - 1])) }, ISOFile.process_sdtp = function (t, e, i) { e && (t ? (e.is_leading = t.is_leading[i], e.depends_on = t.sample_depends_on[i], e.is_depended_on = t.sample_is_depended_on[i], e.has_redundancy = t.sample_has_redundancy[i]) : (e.is_leading = 0, e.depends_on = 0, e.is_depended_on = 0, e.has_redundancy = 0)) }, ISOFile.prototype.buildSampleLists = function () { for (var t, e = 0; e < this.moov.traks.length; e++)t = this.moov.traks[e], this.buildTrakSampleLists(t) }, ISOFile.prototype.buildTrakSampleLists = function (t) { var e, i, r, s, a, n, o, h, d, l, p, f, u, _, c, m, g, x, y, B, S, P, U, b; if (t.samples = [], t.samples_duration = 0, t.samples_size = 0, i = t.mdia.minf.stbl.stco || t.mdia.minf.stbl.co64, r = t.mdia.minf.stbl.stsc, s = t.mdia.minf.stbl.stsz || t.mdia.minf.stbl.stz2, a = t.mdia.minf.stbl.stts, n = t.mdia.minf.stbl.ctts, o = t.mdia.minf.stbl.stss, h = t.mdia.minf.stbl.stsd, d = t.mdia.minf.stbl.subs, f = t.mdia.minf.stbl.stdp, l = t.mdia.minf.stbl.sbgps, p = t.mdia.minf.stbl.sgpds, S = B = y = x = -1, b = U = P = 0, ISOFile.initSampleGroups(t, null, l, p), void 0 !== s) { for (e = 0; e < s.sample_sizes.length; e++) { var v = {}; v.number = e, v.track_id = t.tkhd.track_id, v.timescale = t.mdia.mdhd.timescale, v.alreadyRead = 0, (t.samples[e] = v).size = s.sample_sizes[e], t.samples_size += v.size, 0 === e ? (_ = 1, u = 0, v.chunk_index = _, v.chunk_run_index = u, g = r.samples_per_chunk[u], m = 0, c = u + 1 < r.first_chunk.length ? r.first_chunk[u + 1] - 1 : 1 / 0) : e < g ? (v.chunk_index = _, v.chunk_run_index = u) : (_++, m = 0, (v.chunk_index = _) <= c || (c = ++u + 1 < r.first_chunk.length ? r.first_chunk[u + 1] - 1 : 1 / 0), v.chunk_run_index = u, g += r.samples_per_chunk[u]), v.description_index = r.sample_description_index[v.chunk_run_index] - 1, v.description = h.entries[v.description_index], v.offset = i.chunk_offsets[v.chunk_index - 1] + m, m += v.size, x < e && (y++, x < 0 && (x = 0), x += a.sample_counts[y]), 0 < e ? (t.samples[e - 1].duration = a.sample_deltas[y], t.samples_duration += t.samples[e - 1].duration, v.dts = t.samples[e - 1].dts + t.samples[e - 1].duration) : v.dts = 0, n ? (B <= e && (S++, B < 0 && (B = 0), B += n.sample_counts[S]), v.cts = t.samples[e].dts + n.sample_offsets[S]) : v.cts = v.dts, o ? (e == o.sample_numbers[P] - 1 ? (v.is_sync = !0, P++) : (v.is_sync = !1, v.degradation_priority = 0), d && d.entries[U].sample_delta + b == e + 1 && (v.subsamples = d.entries[U].subsamples, b += d.entries[U].sample_delta, U++)) : v.is_sync = !0, ISOFile.process_sdtp(t.mdia.minf.stbl.sdtp, v, v.number), v.degradation_priority = f ? f.priority[e] : 0, d && d.entries[U].sample_delta + b == e && (v.subsamples = d.entries[U].subsamples, b += d.entries[U].sample_delta), (0 < l.length || 0 < p.length) && ISOFile.setSampleGroupProperties(t, v, e, t.sample_groups_info) } 0 < e && (t.samples[e - 1].duration = Math.max(t.mdia.mdhd.duration - t.samples[e - 1].dts, 0), t.samples_duration += t.samples[e - 1].duration) } }, ISOFile.prototype.updateSampleLists = function () { var t, e, i, r, s, a, n, o, h, d, l, p; if (void 0 !== this.moov) for (; this.lastMoofIndex < this.moofs.length;)if (n = this.moofs[this.lastMoofIndex], this.lastMoofIndex++, "moof" == n.type) for (o = n, t = 0; t < o.trafs.length; t++) { for (h = o.trafs[t], d = this.getTrackById(h.tfhd.track_id), l = this.getTrexById(h.tfhd.track_id), e = h.tfhd.flags & BoxParser.TFHD_FLAG_SAMPLE_DESC ? h.tfhd.default_sample_description_index : l ? l.default_sample_description_index : 1, i = h.tfhd.flags & BoxParser.TFHD_FLAG_SAMPLE_DUR ? h.tfhd.default_sample_duration : l ? l.default_sample_duration : 0, r = h.tfhd.flags & BoxParser.TFHD_FLAG_SAMPLE_SIZE ? h.tfhd.default_sample_size : l ? l.default_sample_size : 0, s = h.tfhd.flags & BoxParser.TFHD_FLAG_SAMPLE_FLAGS ? h.tfhd.default_sample_flags : l ? l.default_sample_flags : 0, (h.sample_number = 0) < h.sbgps.length && ISOFile.initSampleGroups(d, h, h.sbgps, d.mdia.minf.stbl.sgpds, h.sgpds), y = 0; y < h.truns.length; y++)for (var f = h.truns[y], u = 0; u < f.sample_count; u++) { (p = {}).moof_number = this.lastMoofIndex, p.number_in_traf = h.sample_number, h.sample_number++, p.number = d.samples.length, h.first_sample_index = d.samples.length, d.samples.push(p), p.track_id = d.tkhd.track_id, p.timescale = d.mdia.mdhd.timescale, p.description_index = e - 1, p.description = d.mdia.minf.stbl.stsd.entries[p.description_index], p.size = r, f.flags & BoxParser.TRUN_FLAGS_SIZE && (p.size = f.sample_size[u]), d.samples_size += p.size, p.duration = i, f.flags & BoxParser.TRUN_FLAGS_DURATION && (p.duration = f.sample_duration[u]), d.samples_duration += p.duration, d.first_traf_merged || 0 < u ? p.dts = d.samples[d.samples.length - 2].dts + d.samples[d.samples.length - 2].duration : (h.tfdt ? p.dts = h.tfdt.baseMediaDecodeTime : p.dts = 0, d.first_traf_merged = !0), p.cts = p.dts, f.flags & BoxParser.TRUN_FLAGS_CTS_OFFSET && (p.cts = p.dts + f.sample_composition_time_offset[u]), g = s, f.flags & BoxParser.TRUN_FLAGS_FLAGS ? g = f.sample_flags[u] : 0 === u && f.flags & BoxParser.TRUN_FLAGS_FIRST_FLAG && (g = f.first_sample_flags), p.is_sync = !(g >> 16 & 1), p.is_leading = g >> 26 & 3, p.depends_on = g >> 24 & 3, p.is_depended_on = g >> 22 & 3, p.has_redundancy = g >> 20 & 3, p.degradation_priority = 65535 & g; var _ = !!(h.tfhd.flags & BoxParser.TFHD_FLAG_BASE_DATA_OFFSET), c = !!(h.tfhd.flags & BoxParser.TFHD_FLAG_DEFAULT_BASE_IS_MOOF), m = !!(f.flags & BoxParser.TRUN_FLAGS_DATA_OFFSET), g = 0, g = _ ? h.tfhd.base_data_offset : c || 0 === y ? o.start : a; p.offset = 0 === y && 0 === u ? m ? g + f.data_offset : g : a, a = p.offset + p.size, (0 < h.sbgps.length || 0 < h.sgpds.length || 0 < d.mdia.minf.stbl.sbgps.length || 0 < d.mdia.minf.stbl.sgpds.length) && ISOFile.setSampleGroupProperties(d, p, p.number_in_traf, h.sample_groups_info) } if (h.subs) { d.has_fragment_subsamples = !0; for (var x = h.first_sample_index, y = 0; y < h.subs.entries.length; y++)x += h.subs.entries[y].sample_delta, (p = d.samples[x - 1]).subsamples = h.subs.entries[y].subsamples } } }, ISOFile.prototype.getSample = function (t, e) { var i, r = t.samples[e]; if (!this.moov) return null; if (r.data) { if (r.alreadyRead == r.size) return r } else r.data = new Uint8Array(r.size), r.alreadyRead = 0, this.samplesDataSize += r.size, Log.debug("ISOFile", "Allocating sample #" + e + " on track #" + t.tkhd.track_id + " of size " + r.size + " (total: " + this.samplesDataSize + ")"); for (; ;) { var s = this.stream.findPosition(!0, r.offset + r.alreadyRead, !1); if (!(-1 < s)) return null; s = (i = this.stream.buffers[s]).byteLength - (r.offset + r.alreadyRead - i.fileStart); if (r.size - r.alreadyRead <= s) return Log.debug("ISOFile", "Getting sample #" + e + " data (alreadyRead: " + r.alreadyRead + " offset: " + (r.offset + r.alreadyRead - i.fileStart) + " read size: " + (r.size - r.alreadyRead) + " full size: " + r.size + ")"), DataStream.memcpy(r.data.buffer, r.alreadyRead, i, r.offset + r.alreadyRead - i.fileStart, r.size - r.alreadyRead), i.usedBytes += r.size - r.alreadyRead, this.stream.logBufferLevel(), r.alreadyRead = r.size, r; if (0 == s) return null; Log.debug("ISOFile", "Getting sample #" + e + " partial data (alreadyRead: " + r.alreadyRead + " offset: " + (r.offset + r.alreadyRead - i.fileStart) + " read size: " + s + " full size: " + r.size + ")"), DataStream.memcpy(r.data.buffer, r.alreadyRead, i, r.offset + r.alreadyRead - i.fileStart, s), r.alreadyRead += s, i.usedBytes += s, this.stream.logBufferLevel() } }, ISOFile.prototype.releaseSample = function (t, e) { e = t.samples[e]; return e.data ? (this.samplesDataSize -= e.size, e.data = null, e.alreadyRead = 0, e.size) : 0 }, ISOFile.prototype.getAllocatedSampleDataSize = function () { return this.samplesDataSize }, ISOFile.prototype.getCodecs = function () { for (var t = "", e = 0; e < this.moov.traks.length; e++)0 < e && (t += ","), t += this.moov.traks[e].mdia.minf.stbl.stsd.entries[0].getCodec(); return t }, ISOFile.prototype.getTrexById = function (t) { var e; if (!this.moov || !this.moov.mvex) return null; for (e = 0; e < this.moov.mvex.trexs.length; e++) { var i = this.moov.mvex.trexs[e]; if (i.track_id == t) return i } return null }, ISOFile.prototype.getTrackById = function (t) { if (void 0 === this.moov) return null; for (var e = 0; e < this.moov.traks.length; e++) { var i = this.moov.traks[e]; if (i.tkhd.track_id == t) return i } return null }, ISOFile.prototype.items = [], ISOFile.prototype.itemsDataSize = 0, ISOFile.prototype.flattenItemInfo = function () { var t = this.items, e = this.meta; if (null != e && void 0 !== e.hdlr && void 0 !== e.iinf) { for (h = 0; h < e.iinf.item_infos.length; h++)(r = {}).id = e.iinf.item_infos[h].item_ID, (t[r.id] = r).ref_to = [], r.name = e.iinf.item_infos[h].item_name, 0 < e.iinf.item_infos[h].protection_index && (r.protection = e.ipro.protections[e.iinf.item_infos[h].protection_index - 1]), e.iinf.item_infos[h].item_type ? r.type = e.iinf.item_infos[h].item_type : r.type = "mime", r.content_type = e.iinf.item_infos[h].content_type, r.content_encoding = e.iinf.item_infos[h].content_encoding; if (e.iloc) for (h = 0; h < e.iloc.items.length; h++) { var i = e.iloc.items[h], r = t[i.item_ID]; switch (0 !== i.data_reference_index && (Log.warn("Item storage with reference to other files: not supported"), r.source = e.dinf.boxes[i.data_reference_index - 1]), i.construction_method) { case 0: break; case 1: case 2: Log.warn("Item storage with construction_method : not supported") }for (r.extents = [], a = r.size = 0; a < i.extents.length; a++)r.extents[a] = {}, r.extents[a].offset = i.extents[a].extent_offset + i.base_offset, r.extents[a].length = i.extents[a].extent_length, r.extents[a].alreadyRead = 0, r.size += r.extents[a].length } if (e.pitm && (t[e.pitm.item_id].primary = !0), e.iref) for (h = 0; h < e.iref.references.length; h++)for (var s = e.iref.references[h], a = 0; a < s.references.length; a++)t[s.from_item_ID].ref_to.push({ type: s.type, id: s.references[a] }); if (e.iprp) for (var n = 0; n < e.iprp.ipmas.length; n++)for (var o = e.iprp.ipmas[n], h = 0; h < o.associations.length; h++) { var d = o.associations[h]; for (void 0 === (r = t[d.id]).properties && (r.properties = {}, r.properties.boxes = []), a = 0; a < d.props.length; a++) { var l = d.props[a]; 0 < l.property_index && l.property_index - 1 < e.iprp.ipco.boxes.length && (l = e.iprp.ipco.boxes[l.property_index - 1], r.properties[l.type] = l, r.properties.boxes.push(l)) } } } }, ISOFile.prototype.getItem = function (t) { var e, i; if (!this.meta) return null; if (!(i = this.items[t]).data && i.size) i.data = new Uint8Array(i.size), i.alreadyRead = 0, this.itemsDataSize += i.size, Log.debug("ISOFile", "Allocating item #" + t + " of size " + i.size + " (total: " + this.itemsDataSize + ")"); else if (i.alreadyRead === i.size) return i; for (var r = 0; r < i.extents.length; r++) { var s = i.extents[r]; if (s.alreadyRead !== s.length) { var a = this.stream.findPosition(!0, s.offset + s.alreadyRead, !1); if (!(-1 < a)) return null; a = (e = this.stream.buffers[a]).byteLength - (s.offset + s.alreadyRead - e.fileStart); if (!(s.length - s.alreadyRead <= a)) return Log.debug("ISOFile", "Getting item #" + t + " extent #" + r + " partial data (alreadyRead: " + s.alreadyRead + " offset: " + (s.offset + s.alreadyRead - e.fileStart) + " read size: " + a + " full extent size: " + s.length + " full item size: " + i.size + ")"), DataStream.memcpy(i.data.buffer, i.alreadyRead, e, s.offset + s.alreadyRead - e.fileStart, a), s.alreadyRead += a, i.alreadyRead += a, e.usedBytes += a, this.stream.logBufferLevel(), null; Log.debug("ISOFile", "Getting item #" + t + " extent #" + r + " data (alreadyRead: " + s.alreadyRead + " offset: " + (s.offset + s.alreadyRead - e.fileStart) + " read size: " + (s.length - s.alreadyRead) + " full extent size: " + s.length + " full item size: " + i.size + ")"), DataStream.memcpy(i.data.buffer, i.alreadyRead, e, s.offset + s.alreadyRead - e.fileStart, s.length - s.alreadyRead), e.usedBytes += s.length - s.alreadyRead, this.stream.logBufferLevel(), i.alreadyRead += s.length - s.alreadyRead, s.alreadyRead = s.length } } return i.alreadyRead === i.size ? i : null }, ISOFile.prototype.releaseItem = function (t) { var e = this.items[t]; if (e.data) { this.itemsDataSize -= e.size, e.data = null; for (var i = e.alreadyRead = 0; i < e.extents.length; i++)e.extents[i].alreadyRead = 0; return e.size } return 0 }, ISOFile.prototype.processItems = function (t) { for (var e in this.items) { var i = this.items[e]; this.getItem(i.id), t && !i.sent && (t(i), i.sent = !0, i.data = null) } }, ISOFile.prototype.hasItem = function (t) { for (var e in this.items) { var i = this.items[e]; if (i.name === t) return i.id } return -1 }, ISOFile.prototype.getMetaHandler = function () { return this.meta ? this.meta.hdlr.handler : null }, ISOFile.prototype.getPrimaryItem = function () { return this.meta && this.meta.pitm ? this.getItem(this.meta.pitm.item_id) : null }, ISOFile.prototype.itemToFragmentedTrackFile = function (t) { var e = t || {}, i = null; if (null == (i = e.itemId ? this.getItem(e.itemId) : this.getPrimaryItem())) return null; t = new ISOFile; t.discardMdatData = !1; e = { type: i.type, description_boxes: i.properties.boxes }; i.properties.ispe && (e.width = i.properties.ispe.image_width, e.height = i.properties.ispe.image_height); e = t.addTrack(e); return e ? (t.addSample(e, i.data), t) : null }, ISOFile.prototype.write = function (t) { for (var e = 0; e < this.boxes.length; e++)this.boxes[e].write(t) }, ISOFile.prototype.createFragment = function (t, e, i) { var r = this.getTrackById(t), t = this.getSample(r, e); if (null == t) return t = r.samples[e], this.nextSeekPosition ? this.nextSeekPosition = Math.min(t.offset + t.alreadyRead, this.nextSeekPosition) : this.nextSeekPosition = r.samples[e].offset + t.alreadyRead, null; e = i || new DataStream; e.endianness = DataStream.BIG_ENDIAN; i = this.createSingleSampleMoof(t); i.write(e), i.trafs[0].truns[0].data_offset = i.size + 8, Log.debug("MP4Box", "Adjusting data_offset with new value " + i.trafs[0].truns[0].data_offset), e.adjustUint32(i.trafs[0].truns[0].data_offset_position, i.trafs[0].truns[0].data_offset); i = new BoxParser.mdatBox; return i.data = t.data, i.write(e), e }, ISOFile.writeInitializationSegment = function (t, e, i, r) { var s; Log.debug("ISOFile", "Generating initialization segment"); var a = new DataStream; a.endianness = DataStream.BIG_ENDIAN, t.write(a); var n = e.add("mvex"); for (i && n.add("mehd").set("fragment_duration", i), s = 0; s < e.traks.length; s++)n.add("trex").set("track_id", e.traks[s].tkhd.track_id).set("default_sample_description_index", 1).set("default_sample_duration", r).set("default_sample_size", 0).set("default_sample_flags", 65536); return e.write(a), a.buffer }, ISOFile.prototype.save = function (t) { var e = new DataStream; e.endianness = DataStream.BIG_ENDIAN, this.write(e), e.save(t) }, ISOFile.prototype.getBuffer = function () { var t = new DataStream; return t.endianness = DataStream.BIG_ENDIAN, this.write(t), t.buffer }, ISOFile.prototype.initializeSegmentation = function () { var t, e, i, r; for (null === this.onSegment && Log.warn("MP4Box", "No segmentation callback set!"), this.isFragmentationInitialized || (this.isFragmentationInitialized = !0, this.nextMoofNumber = 0, this.resetTables()), e = [], t = 0; t < this.fragmentedTracks.length; t++) { var s = new BoxParser.moovBox; s.mvhd = this.moov.mvhd, s.boxes.push(s.mvhd), i = this.getTrackById(this.fragmentedTracks[t].id), s.boxes.push(i), s.traks.push(i), (r = {}).id = i.tkhd.track_id, r.user = this.fragmentedTracks[t].user, r.buffer = ISOFile.writeInitializationSegment(this.ftyp, s, this.moov.mvex && this.moov.mvex.mehd ? this.moov.mvex.mehd.fragment_duration : void 0, 0 < this.moov.traks[t].samples.length ? this.moov.traks[t].samples[0].duration : 0), e.push(r) } return e }, BoxParser.Box.prototype.printHeader = function (t) { this.size += 8, this.size > MAX_SIZE && (this.size += 8), "uuid" === this.type && (this.size += 16), t.log(t.indent + "size:" + this.size), t.log(t.indent + "type:" + this.type) }, BoxParser.FullBox.prototype.printHeader = function (t) { this.size += 4, BoxParser.Box.prototype.printHeader.call(this, t), t.log(t.indent + "version:" + this.version), t.log(t.indent + "flags:" + this.flags) }, BoxParser.Box.prototype.print = function (t) { this.printHeader(t) }, BoxParser.ContainerBox.prototype.print = function (t) { this.printHeader(t); for (var e, i = 0; i < this.boxes.length; i++)this.boxes[i] && (e = t.indent, t.indent += " ", this.boxes[i].print(t), t.indent = e) }, ISOFile.prototype.print = function (t) { t.indent = ""; for (var e = 0; e < this.boxes.length; e++)this.boxes[e] && this.boxes[e].print(t) }, BoxParser.mvhdBox.prototype.print = function (t) { BoxParser.FullBox.prototype.printHeader.call(this, t), t.log(t.indent + "creation_time: " + this.creation_time), t.log(t.indent + "modification_time: " + this.modification_time), t.log(t.indent + "timescale: " + this.timescale), t.log(t.indent + "duration: " + this.duration), t.log(t.indent + "rate: " + this.rate), t.log(t.indent + "volume: " + (this.volume >> 8)), t.log(t.indent + "matrix: " + this.matrix.join(", ")), t.log(t.indent + "next_track_id: " + this.next_track_id) }, BoxParser.tkhdBox.prototype.print = function (t) { BoxParser.FullBox.prototype.printHeader.call(this, t), t.log(t.indent + "creation_time: " + this.creation_time), t.log(t.indent + "modification_time: " + this.modification_time), t.log(t.indent + "track_id: " + this.track_id), t.log(t.indent + "duration: " + this.duration), t.log(t.indent + "volume: " + (this.volume >> 8)), t.log(t.indent + "matrix: " + this.matrix.join(", ")), t.log(t.indent + "layer: " + this.layer), t.log(t.indent + "alternate_group: " + this.alternate_group), t.log(t.indent + "width: " + this.width), t.log(t.indent + "height: " + this.height) }; var MP4Box = { createFile: function (t, e) { t = void 0 === t || t, e = new ISOFile(e); return e.discardMdatData = !t, e } }; "undefined" != typeof exports && (exports.createFile = MP4Box.createFile);
  //# sourceMappingURL=mp4box.all.min.js.map
</script>
<script>
  /*!
 * Vue.js v2.6.10
 * (c) 2014-2019 Evan You
 * Released under the MIT License.
 */
  !function (e, t) { "object" == typeof exports && "undefined" != typeof module ? module.exports = t() : "function" == typeof define && define.amd ? define(t) : (e = e || self).Vue = t() }(this, function () { "use strict"; var e = Object.freeze({}); function t(e) { return null == e } function n(e) { return null != e } function r(e) { return !0 === e } function i(e) { return "string" == typeof e || "number" == typeof e || "symbol" == typeof e || "boolean" == typeof e } function o(e) { return null !== e && "object" == typeof e } var a = Object.prototype.toString; function s(e) { return "[object Object]" === a.call(e) } function c(e) { var t = parseFloat(String(e)); return t >= 0 && Math.floor(t) === t && isFinite(e) } function u(e) { return n(e) && "function" == typeof e.then && "function" == typeof e.catch } function l(e) { return null == e ? "" : Array.isArray(e) || s(e) && e.toString === a ? JSON.stringify(e, null, 2) : String(e) } function f(e) { var t = parseFloat(e); return isNaN(t) ? e : t } function p(e, t) { for (var n = Object.create(null), r = e.split(","), i = 0; i < r.length; i++)n[r[i]] = !0; return t ? function (e) { return n[e.toLowerCase()] } : function (e) { return n[e] } } var d = p("slot,component", !0), v = p("key,ref,slot,slot-scope,is"); function h(e, t) { if (e.length) { var n = e.indexOf(t); if (n > -1) return e.splice(n, 1) } } var m = Object.prototype.hasOwnProperty; function y(e, t) { return m.call(e, t) } function g(e) { var t = Object.create(null); return function (n) { return t[n] || (t[n] = e(n)) } } var _ = /-(\w)/g, b = g(function (e) { return e.replace(_, function (e, t) { return t ? t.toUpperCase() : "" }) }), $ = g(function (e) { return e.charAt(0).toUpperCase() + e.slice(1) }), w = /\B([A-Z])/g, C = g(function (e) { return e.replace(w, "-$1").toLowerCase() }); var x = Function.prototype.bind ? function (e, t) { return e.bind(t) } : function (e, t) { function n(n) { var r = arguments.length; return r ? r > 1 ? e.apply(t, arguments) : e.call(t, n) : e.call(t) } return n._length = e.length, n }; function k(e, t) { t = t || 0; for (var n = e.length - t, r = new Array(n); n--;)r[n] = e[n + t]; return r } function A(e, t) { for (var n in t) e[n] = t[n]; return e } function O(e) { for (var t = {}, n = 0; n < e.length; n++)e[n] && A(t, e[n]); return t } function S(e, t, n) { } var T = function (e, t, n) { return !1 }, E = function (e) { return e }; function N(e, t) { if (e === t) return !0; var n = o(e), r = o(t); if (!n || !r) return !n && !r && String(e) === String(t); try { var i = Array.isArray(e), a = Array.isArray(t); if (i && a) return e.length === t.length && e.every(function (e, n) { return N(e, t[n]) }); if (e instanceof Date && t instanceof Date) return e.getTime() === t.getTime(); if (i || a) return !1; var s = Object.keys(e), c = Object.keys(t); return s.length === c.length && s.every(function (n) { return N(e[n], t[n]) }) } catch (e) { return !1 } } function j(e, t) { for (var n = 0; n < e.length; n++)if (N(e[n], t)) return n; return -1 } function D(e) { var t = !1; return function () { t || (t = !0, e.apply(this, arguments)) } } var L = "data-server-rendered", M = ["component", "directive", "filter"], I = ["beforeCreate", "created", "beforeMount", "mounted", "beforeUpdate", "updated", "beforeDestroy", "destroyed", "activated", "deactivated", "errorCaptured", "serverPrefetch"], F = { optionMergeStrategies: Object.create(null), silent: !1, productionTip: !1, devtools: !1, performance: !1, errorHandler: null, warnHandler: null, ignoredElements: [], keyCodes: Object.create(null), isReservedTag: T, isReservedAttr: T, isUnknownElement: T, getTagNamespace: S, parsePlatformTagName: E, mustUseProp: T, async: !0, _lifecycleHooks: I }, P = /a-zA-Z\u00B7\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u037D\u037F-\u1FFF\u200C-\u200D\u203F-\u2040\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD/; function R(e, t, n, r) { Object.defineProperty(e, t, { value: n, enumerable: !!r, writable: !0, configurable: !0 }) } var H = new RegExp("[^" + P.source + ".$_\\d]"); var B, U = "__proto__" in {}, z = "undefined" != typeof window, V = "undefined" != typeof WXEnvironment && !!WXEnvironment.platform, K = V && WXEnvironment.platform.toLowerCase(), J = z && window.navigator.userAgent.toLowerCase(), q = J && /msie|trident/.test(J), W = J && J.indexOf("msie 9.0") > 0, Z = J && J.indexOf("edge/") > 0, G = (J && J.indexOf("android"), J && /iphone|ipad|ipod|ios/.test(J) || "ios" === K), X = (J && /chrome\/\d+/.test(J), J && /phantomjs/.test(J), J && J.match(/firefox\/(\d+)/)), Y = {}.watch, Q = !1; if (z) try { var ee = {}; Object.defineProperty(ee, "passive", { get: function () { Q = !0 } }), window.addEventListener("test-passive", null, ee) } catch (e) { } var te = function () { return void 0 === B && (B = !z && !V && "undefined" != typeof global && (global.process && "server" === global.process.env.VUE_ENV)), B }, ne = z && window.__VUE_DEVTOOLS_GLOBAL_HOOK__; function re(e) { return "function" == typeof e && /native code/.test(e.toString()) } var ie, oe = "undefined" != typeof Symbol && re(Symbol) && "undefined" != typeof Reflect && re(Reflect.ownKeys); ie = "undefined" != typeof Set && re(Set) ? Set : function () { function e() { this.set = Object.create(null) } return e.prototype.has = function (e) { return !0 === this.set[e] }, e.prototype.add = function (e) { this.set[e] = !0 }, e.prototype.clear = function () { this.set = Object.create(null) }, e }(); var ae = S, se = 0, ce = function () { this.id = se++, this.subs = [] }; ce.prototype.addSub = function (e) { this.subs.push(e) }, ce.prototype.removeSub = function (e) { h(this.subs, e) }, ce.prototype.depend = function () { ce.target && ce.target.addDep(this) }, ce.prototype.notify = function () { for (var e = this.subs.slice(), t = 0, n = e.length; t < n; t++)e[t].update() }, ce.target = null; var ue = []; function le(e) { ue.push(e), ce.target = e } function fe() { ue.pop(), ce.target = ue[ue.length - 1] } var pe = function (e, t, n, r, i, o, a, s) { this.tag = e, this.data = t, this.children = n, this.text = r, this.elm = i, this.ns = void 0, this.context = o, this.fnContext = void 0, this.fnOptions = void 0, this.fnScopeId = void 0, this.key = t && t.key, this.componentOptions = a, this.componentInstance = void 0, this.parent = void 0, this.raw = !1, this.isStatic = !1, this.isRootInsert = !0, this.isComment = !1, this.isCloned = !1, this.isOnce = !1, this.asyncFactory = s, this.asyncMeta = void 0, this.isAsyncPlaceholder = !1 }, de = { child: { configurable: !0 } }; de.child.get = function () { return this.componentInstance }, Object.defineProperties(pe.prototype, de); var ve = function (e) { void 0 === e && (e = ""); var t = new pe; return t.text = e, t.isComment = !0, t }; function he(e) { return new pe(void 0, void 0, void 0, String(e)) } function me(e) { var t = new pe(e.tag, e.data, e.children && e.children.slice(), e.text, e.elm, e.context, e.componentOptions, e.asyncFactory); return t.ns = e.ns, t.isStatic = e.isStatic, t.key = e.key, t.isComment = e.isComment, t.fnContext = e.fnContext, t.fnOptions = e.fnOptions, t.fnScopeId = e.fnScopeId, t.asyncMeta = e.asyncMeta, t.isCloned = !0, t } var ye = Array.prototype, ge = Object.create(ye);["push", "pop", "shift", "unshift", "splice", "sort", "reverse"].forEach(function (e) { var t = ye[e]; R(ge, e, function () { for (var n = [], r = arguments.length; r--;)n[r] = arguments[r]; var i, o = t.apply(this, n), a = this.__ob__; switch (e) { case "push": case "unshift": i = n; break; case "splice": i = n.slice(2) }return i && a.observeArray(i), a.dep.notify(), o }) }); var _e = Object.getOwnPropertyNames(ge), be = !0; function $e(e) { be = e } var we = function (e) { var t; this.value = e, this.dep = new ce, this.vmCount = 0, R(e, "__ob__", this), Array.isArray(e) ? (U ? (t = ge, e.__proto__ = t) : function (e, t, n) { for (var r = 0, i = n.length; r < i; r++) { var o = n[r]; R(e, o, t[o]) } }(e, ge, _e), this.observeArray(e)) : this.walk(e) }; function Ce(e, t) { var n; if (o(e) && !(e instanceof pe)) return y(e, "__ob__") && e.__ob__ instanceof we ? n = e.__ob__ : be && !te() && (Array.isArray(e) || s(e)) && Object.isExtensible(e) && !e._isVue && (n = new we(e)), t && n && n.vmCount++, n } function xe(e, t, n, r, i) { var o = new ce, a = Object.getOwnPropertyDescriptor(e, t); if (!a || !1 !== a.configurable) { var s = a && a.get, c = a && a.set; s && !c || 2 !== arguments.length || (n = e[t]); var u = !i && Ce(n); Object.defineProperty(e, t, { enumerable: !0, configurable: !0, get: function () { var t = s ? s.call(e) : n; return ce.target && (o.depend(), u && (u.dep.depend(), Array.isArray(t) && function e(t) { for (var n = void 0, r = 0, i = t.length; r < i; r++)(n = t[r]) && n.__ob__ && n.__ob__.dep.depend(), Array.isArray(n) && e(n) }(t))), t }, set: function (t) { var r = s ? s.call(e) : n; t === r || t != t && r != r || s && !c || (c ? c.call(e, t) : n = t, u = !i && Ce(t), o.notify()) } }) } } function ke(e, t, n) { if (Array.isArray(e) && c(t)) return e.length = Math.max(e.length, t), e.splice(t, 1, n), n; if (t in e && !(t in Object.prototype)) return e[t] = n, n; var r = e.__ob__; return e._isVue || r && r.vmCount ? n : r ? (xe(r.value, t, n), r.dep.notify(), n) : (e[t] = n, n) } function Ae(e, t) { if (Array.isArray(e) && c(t)) e.splice(t, 1); else { var n = e.__ob__; e._isVue || n && n.vmCount || y(e, t) && (delete e[t], n && n.dep.notify()) } } we.prototype.walk = function (e) { for (var t = Object.keys(e), n = 0; n < t.length; n++)xe(e, t[n]) }, we.prototype.observeArray = function (e) { for (var t = 0, n = e.length; t < n; t++)Ce(e[t]) }; var Oe = F.optionMergeStrategies; function Se(e, t) { if (!t) return e; for (var n, r, i, o = oe ? Reflect.ownKeys(t) : Object.keys(t), a = 0; a < o.length; a++)"__ob__" !== (n = o[a]) && (r = e[n], i = t[n], y(e, n) ? r !== i && s(r) && s(i) && Se(r, i) : ke(e, n, i)); return e } function Te(e, t, n) { return n ? function () { var r = "function" == typeof t ? t.call(n, n) : t, i = "function" == typeof e ? e.call(n, n) : e; return r ? Se(r, i) : i } : t ? e ? function () { return Se("function" == typeof t ? t.call(this, this) : t, "function" == typeof e ? e.call(this, this) : e) } : t : e } function Ee(e, t) { var n = t ? e ? e.concat(t) : Array.isArray(t) ? t : [t] : e; return n ? function (e) { for (var t = [], n = 0; n < e.length; n++)-1 === t.indexOf(e[n]) && t.push(e[n]); return t }(n) : n } function Ne(e, t, n, r) { var i = Object.create(e || null); return t ? A(i, t) : i } Oe.data = function (e, t, n) { return n ? Te(e, t, n) : t && "function" != typeof t ? e : Te(e, t) }, I.forEach(function (e) { Oe[e] = Ee }), M.forEach(function (e) { Oe[e + "s"] = Ne }), Oe.watch = function (e, t, n, r) { if (e === Y && (e = void 0), t === Y && (t = void 0), !t) return Object.create(e || null); if (!e) return t; var i = {}; for (var o in A(i, e), t) { var a = i[o], s = t[o]; a && !Array.isArray(a) && (a = [a]), i[o] = a ? a.concat(s) : Array.isArray(s) ? s : [s] } return i }, Oe.props = Oe.methods = Oe.inject = Oe.computed = function (e, t, n, r) { if (!e) return t; var i = Object.create(null); return A(i, e), t && A(i, t), i }, Oe.provide = Te; var je = function (e, t) { return void 0 === t ? e : t }; function De(e, t, n) { if ("function" == typeof t && (t = t.options), function (e, t) { var n = e.props; if (n) { var r, i, o = {}; if (Array.isArray(n)) for (r = n.length; r--;)"string" == typeof (i = n[r]) && (o[b(i)] = { type: null }); else if (s(n)) for (var a in n) i = n[a], o[b(a)] = s(i) ? i : { type: i }; e.props = o } }(t), function (e, t) { var n = e.inject; if (n) { var r = e.inject = {}; if (Array.isArray(n)) for (var i = 0; i < n.length; i++)r[n[i]] = { from: n[i] }; else if (s(n)) for (var o in n) { var a = n[o]; r[o] = s(a) ? A({ from: o }, a) : { from: a } } } }(t), function (e) { var t = e.directives; if (t) for (var n in t) { var r = t[n]; "function" == typeof r && (t[n] = { bind: r, update: r }) } }(t), !t._base && (t.extends && (e = De(e, t.extends, n)), t.mixins)) for (var r = 0, i = t.mixins.length; r < i; r++)e = De(e, t.mixins[r], n); var o, a = {}; for (o in e) c(o); for (o in t) y(e, o) || c(o); function c(r) { var i = Oe[r] || je; a[r] = i(e[r], t[r], n, r) } return a } function Le(e, t, n, r) { if ("string" == typeof n) { var i = e[t]; if (y(i, n)) return i[n]; var o = b(n); if (y(i, o)) return i[o]; var a = $(o); return y(i, a) ? i[a] : i[n] || i[o] || i[a] } } function Me(e, t, n, r) { var i = t[e], o = !y(n, e), a = n[e], s = Pe(Boolean, i.type); if (s > -1) if (o && !y(i, "default")) a = !1; else if ("" === a || a === C(e)) { var c = Pe(String, i.type); (c < 0 || s < c) && (a = !0) } if (void 0 === a) { a = function (e, t, n) { if (!y(t, "default")) return; var r = t.default; if (e && e.$options.propsData && void 0 === e.$options.propsData[n] && void 0 !== e._props[n]) return e._props[n]; return "function" == typeof r && "Function" !== Ie(t.type) ? r.call(e) : r }(r, i, e); var u = be; $e(!0), Ce(a), $e(u) } return a } function Ie(e) { var t = e && e.toString().match(/^\s*function (\w+)/); return t ? t[1] : "" } function Fe(e, t) { return Ie(e) === Ie(t) } function Pe(e, t) { if (!Array.isArray(t)) return Fe(t, e) ? 0 : -1; for (var n = 0, r = t.length; n < r; n++)if (Fe(t[n], e)) return n; return -1 } function Re(e, t, n) { le(); try { if (t) for (var r = t; r = r.$parent;) { var i = r.$options.errorCaptured; if (i) for (var o = 0; o < i.length; o++)try { if (!1 === i[o].call(r, e, t, n)) return } catch (e) { Be(e, r, "errorCaptured hook") } } Be(e, t, n) } finally { fe() } } function He(e, t, n, r, i) { var o; try { (o = n ? e.apply(t, n) : e.call(t)) && !o._isVue && u(o) && !o._handled && (o.catch(function (e) { return Re(e, r, i + " (Promise/async)") }), o._handled = !0) } catch (e) { Re(e, r, i) } return o } function Be(e, t, n) { if (F.errorHandler) try { return F.errorHandler.call(null, e, t, n) } catch (t) { t !== e && Ue(t, null, "config.errorHandler") } Ue(e, t, n) } function Ue(e, t, n) { if (!z && !V || "undefined" == typeof console) throw e; console.error(e) } var ze, Ve = !1, Ke = [], Je = !1; function qe() { Je = !1; var e = Ke.slice(0); Ke.length = 0; for (var t = 0; t < e.length; t++)e[t]() } if ("undefined" != typeof Promise && re(Promise)) { var We = Promise.resolve(); ze = function () { We.then(qe), G && setTimeout(S) }, Ve = !0 } else if (q || "undefined" == typeof MutationObserver || !re(MutationObserver) && "[object MutationObserverConstructor]" !== MutationObserver.toString()) ze = "undefined" != typeof setImmediate && re(setImmediate) ? function () { setImmediate(qe) } : function () { setTimeout(qe, 0) }; else { var Ze = 1, Ge = new MutationObserver(qe), Xe = document.createTextNode(String(Ze)); Ge.observe(Xe, { characterData: !0 }), ze = function () { Ze = (Ze + 1) % 2, Xe.data = String(Ze) }, Ve = !0 } function Ye(e, t) { var n; if (Ke.push(function () { if (e) try { e.call(t) } catch (e) { Re(e, t, "nextTick") } else n && n(t) }), Je || (Je = !0, ze()), !e && "undefined" != typeof Promise) return new Promise(function (e) { n = e }) } var Qe = new ie; function et(e) { !function e(t, n) { var r, i; var a = Array.isArray(t); if (!a && !o(t) || Object.isFrozen(t) || t instanceof pe) return; if (t.__ob__) { var s = t.__ob__.dep.id; if (n.has(s)) return; n.add(s) } if (a) for (r = t.length; r--;)e(t[r], n); else for (i = Object.keys(t), r = i.length; r--;)e(t[i[r]], n) }(e, Qe), Qe.clear() } var tt = g(function (e) { var t = "&" === e.charAt(0), n = "~" === (e = t ? e.slice(1) : e).charAt(0), r = "!" === (e = n ? e.slice(1) : e).charAt(0); return { name: e = r ? e.slice(1) : e, once: n, capture: r, passive: t } }); function nt(e, t) { function n() { var e = arguments, r = n.fns; if (!Array.isArray(r)) return He(r, null, arguments, t, "v-on handler"); for (var i = r.slice(), o = 0; o < i.length; o++)He(i[o], null, e, t, "v-on handler") } return n.fns = e, n } function rt(e, n, i, o, a, s) { var c, u, l, f; for (c in e) u = e[c], l = n[c], f = tt(c), t(u) || (t(l) ? (t(u.fns) && (u = e[c] = nt(u, s)), r(f.once) && (u = e[c] = a(f.name, u, f.capture)), i(f.name, u, f.capture, f.passive, f.params)) : u !== l && (l.fns = u, e[c] = l)); for (c in n) t(e[c]) && o((f = tt(c)).name, n[c], f.capture) } function it(e, i, o) { var a; e instanceof pe && (e = e.data.hook || (e.data.hook = {})); var s = e[i]; function c() { o.apply(this, arguments), h(a.fns, c) } t(s) ? a = nt([c]) : n(s.fns) && r(s.merged) ? (a = s).fns.push(c) : a = nt([s, c]), a.merged = !0, e[i] = a } function ot(e, t, r, i, o) { if (n(t)) { if (y(t, r)) return e[r] = t[r], o || delete t[r], !0; if (y(t, i)) return e[r] = t[i], o || delete t[i], !0 } return !1 } function at(e) { return i(e) ? [he(e)] : Array.isArray(e) ? function e(o, a) { var s = []; var c, u, l, f; for (c = 0; c < o.length; c++)t(u = o[c]) || "boolean" == typeof u || (l = s.length - 1, f = s[l], Array.isArray(u) ? u.length > 0 && (st((u = e(u, (a || "") + "_" + c))[0]) && st(f) && (s[l] = he(f.text + u[0].text), u.shift()), s.push.apply(s, u)) : i(u) ? st(f) ? s[l] = he(f.text + u) : "" !== u && s.push(he(u)) : st(u) && st(f) ? s[l] = he(f.text + u.text) : (r(o._isVList) && n(u.tag) && t(u.key) && n(a) && (u.key = "__vlist" + a + "_" + c + "__"), s.push(u))); return s }(e) : void 0 } function st(e) { return n(e) && n(e.text) && !1 === e.isComment } function ct(e, t) { if (e) { for (var n = Object.create(null), r = oe ? Reflect.ownKeys(e) : Object.keys(e), i = 0; i < r.length; i++) { var o = r[i]; if ("__ob__" !== o) { for (var a = e[o].from, s = t; s;) { if (s._provided && y(s._provided, a)) { n[o] = s._provided[a]; break } s = s.$parent } if (!s && "default" in e[o]) { var c = e[o].default; n[o] = "function" == typeof c ? c.call(t) : c } } } return n } } function ut(e, t) { if (!e || !e.length) return {}; for (var n = {}, r = 0, i = e.length; r < i; r++) { var o = e[r], a = o.data; if (a && a.attrs && a.attrs.slot && delete a.attrs.slot, o.context !== t && o.fnContext !== t || !a || null == a.slot) (n.default || (n.default = [])).push(o); else { var s = a.slot, c = n[s] || (n[s] = []); "template" === o.tag ? c.push.apply(c, o.children || []) : c.push(o) } } for (var u in n) n[u].every(lt) && delete n[u]; return n } function lt(e) { return e.isComment && !e.asyncFactory || " " === e.text } function ft(t, n, r) { var i, o = Object.keys(n).length > 0, a = t ? !!t.$stable : !o, s = t && t.$key; if (t) { if (t._normalized) return t._normalized; if (a && r && r !== e && s === r.$key && !o && !r.$hasNormal) return r; for (var c in i = {}, t) t[c] && "$" !== c[0] && (i[c] = pt(n, c, t[c])) } else i = {}; for (var u in n) u in i || (i[u] = dt(n, u)); return t && Object.isExtensible(t) && (t._normalized = i), R(i, "$stable", a), R(i, "$key", s), R(i, "$hasNormal", o), i } function pt(e, t, n) { var r = function () { var e = arguments.length ? n.apply(null, arguments) : n({}); return (e = e && "object" == typeof e && !Array.isArray(e) ? [e] : at(e)) && (0 === e.length || 1 === e.length && e[0].isComment) ? void 0 : e }; return n.proxy && Object.defineProperty(e, t, { get: r, enumerable: !0, configurable: !0 }), r } function dt(e, t) { return function () { return e[t] } } function vt(e, t) { var r, i, a, s, c; if (Array.isArray(e) || "string" == typeof e) for (r = new Array(e.length), i = 0, a = e.length; i < a; i++)r[i] = t(e[i], i); else if ("number" == typeof e) for (r = new Array(e), i = 0; i < e; i++)r[i] = t(i + 1, i); else if (o(e)) if (oe && e[Symbol.iterator]) { r = []; for (var u = e[Symbol.iterator](), l = u.next(); !l.done;)r.push(t(l.value, r.length)), l = u.next() } else for (s = Object.keys(e), r = new Array(s.length), i = 0, a = s.length; i < a; i++)c = s[i], r[i] = t(e[c], c, i); return n(r) || (r = []), r._isVList = !0, r } function ht(e, t, n, r) { var i, o = this.$scopedSlots[e]; o ? (n = n || {}, r && (n = A(A({}, r), n)), i = o(n) || t) : i = this.$slots[e] || t; var a = n && n.slot; return a ? this.$createElement("template", { slot: a }, i) : i } function mt(e) { return Le(this.$options, "filters", e) || E } function yt(e, t) { return Array.isArray(e) ? -1 === e.indexOf(t) : e !== t } function gt(e, t, n, r, i) { var o = F.keyCodes[t] || n; return i && r && !F.keyCodes[t] ? yt(i, r) : o ? yt(o, e) : r ? C(r) !== t : void 0 } function _t(e, t, n, r, i) { if (n) if (o(n)) { var a; Array.isArray(n) && (n = O(n)); var s = function (o) { if ("class" === o || "style" === o || v(o)) a = e; else { var s = e.attrs && e.attrs.type; a = r || F.mustUseProp(t, s, o) ? e.domProps || (e.domProps = {}) : e.attrs || (e.attrs = {}) } var c = b(o), u = C(o); c in a || u in a || (a[o] = n[o], i && ((e.on || (e.on = {}))["update:" + o] = function (e) { n[o] = e })) }; for (var c in n) s(c) } else; return e } function bt(e, t) { var n = this._staticTrees || (this._staticTrees = []), r = n[e]; return r && !t ? r : (wt(r = n[e] = this.$options.staticRenderFns[e].call(this._renderProxy, null, this), "__static__" + e, !1), r) } function $t(e, t, n) { return wt(e, "__once__" + t + (n ? "_" + n : ""), !0), e } function wt(e, t, n) { if (Array.isArray(e)) for (var r = 0; r < e.length; r++)e[r] && "string" != typeof e[r] && Ct(e[r], t + "_" + r, n); else Ct(e, t, n) } function Ct(e, t, n) { e.isStatic = !0, e.key = t, e.isOnce = n } function xt(e, t) { if (t) if (s(t)) { var n = e.on = e.on ? A({}, e.on) : {}; for (var r in t) { var i = n[r], o = t[r]; n[r] = i ? [].concat(i, o) : o } } else; return e } function kt(e, t, n, r) { t = t || { $stable: !n }; for (var i = 0; i < e.length; i++) { var o = e[i]; Array.isArray(o) ? kt(o, t, n) : o && (o.proxy && (o.fn.proxy = !0), t[o.key] = o.fn) } return r && (t.$key = r), t } function At(e, t) { for (var n = 0; n < t.length; n += 2) { var r = t[n]; "string" == typeof r && r && (e[t[n]] = t[n + 1]) } return e } function Ot(e, t) { return "string" == typeof e ? t + e : e } function St(e) { e._o = $t, e._n = f, e._s = l, e._l = vt, e._t = ht, e._q = N, e._i = j, e._m = bt, e._f = mt, e._k = gt, e._b = _t, e._v = he, e._e = ve, e._u = kt, e._g = xt, e._d = At, e._p = Ot } function Tt(t, n, i, o, a) { var s, c = this, u = a.options; y(o, "_uid") ? (s = Object.create(o))._original = o : (s = o, o = o._original); var l = r(u._compiled), f = !l; this.data = t, this.props = n, this.children = i, this.parent = o, this.listeners = t.on || e, this.injections = ct(u.inject, o), this.slots = function () { return c.$slots || ft(t.scopedSlots, c.$slots = ut(i, o)), c.$slots }, Object.defineProperty(this, "scopedSlots", { enumerable: !0, get: function () { return ft(t.scopedSlots, this.slots()) } }), l && (this.$options = u, this.$slots = this.slots(), this.$scopedSlots = ft(t.scopedSlots, this.$slots)), u._scopeId ? this._c = function (e, t, n, r) { var i = Pt(s, e, t, n, r, f); return i && !Array.isArray(i) && (i.fnScopeId = u._scopeId, i.fnContext = o), i } : this._c = function (e, t, n, r) { return Pt(s, e, t, n, r, f) } } function Et(e, t, n, r, i) { var o = me(e); return o.fnContext = n, o.fnOptions = r, t.slot && ((o.data || (o.data = {})).slot = t.slot), o } function Nt(e, t) { for (var n in t) e[b(n)] = t[n] } St(Tt.prototype); var jt = { init: function (e, t) { if (e.componentInstance && !e.componentInstance._isDestroyed && e.data.keepAlive) { var r = e; jt.prepatch(r, r) } else { (e.componentInstance = function (e, t) { var r = { _isComponent: !0, _parentVnode: e, parent: t }, i = e.data.inlineTemplate; n(i) && (r.render = i.render, r.staticRenderFns = i.staticRenderFns); return new e.componentOptions.Ctor(r) }(e, Wt)).$mount(t ? e.elm : void 0, t) } }, prepatch: function (t, n) { var r = n.componentOptions; !function (t, n, r, i, o) { var a = i.data.scopedSlots, s = t.$scopedSlots, c = !!(a && !a.$stable || s !== e && !s.$stable || a && t.$scopedSlots.$key !== a.$key), u = !!(o || t.$options._renderChildren || c); t.$options._parentVnode = i, t.$vnode = i, t._vnode && (t._vnode.parent = i); if (t.$options._renderChildren = o, t.$attrs = i.data.attrs || e, t.$listeners = r || e, n && t.$options.props) { $e(!1); for (var l = t._props, f = t.$options._propKeys || [], p = 0; p < f.length; p++) { var d = f[p], v = t.$options.props; l[d] = Me(d, v, n, t) } $e(!0), t.$options.propsData = n } r = r || e; var h = t.$options._parentListeners; t.$options._parentListeners = r, qt(t, r, h), u && (t.$slots = ut(o, i.context), t.$forceUpdate()) }(n.componentInstance = t.componentInstance, r.propsData, r.listeners, n, r.children) }, insert: function (e) { var t, n = e.context, r = e.componentInstance; r._isMounted || (r._isMounted = !0, Yt(r, "mounted")), e.data.keepAlive && (n._isMounted ? ((t = r)._inactive = !1, en.push(t)) : Xt(r, !0)) }, destroy: function (e) { var t = e.componentInstance; t._isDestroyed || (e.data.keepAlive ? function e(t, n) { if (n && (t._directInactive = !0, Gt(t))) return; if (!t._inactive) { t._inactive = !0; for (var r = 0; r < t.$children.length; r++)e(t.$children[r]); Yt(t, "deactivated") } }(t, !0) : t.$destroy()) } }, Dt = Object.keys(jt); function Lt(i, a, s, c, l) { if (!t(i)) { var f = s.$options._base; if (o(i) && (i = f.extend(i)), "function" == typeof i) { var p; if (t(i.cid) && void 0 === (i = function (e, i) { if (r(e.error) && n(e.errorComp)) return e.errorComp; if (n(e.resolved)) return e.resolved; var a = Ht; a && n(e.owners) && -1 === e.owners.indexOf(a) && e.owners.push(a); if (r(e.loading) && n(e.loadingComp)) return e.loadingComp; if (a && !n(e.owners)) { var s = e.owners = [a], c = !0, l = null, f = null; a.$on("hook:destroyed", function () { return h(s, a) }); var p = function (e) { for (var t = 0, n = s.length; t < n; t++)s[t].$forceUpdate(); e && (s.length = 0, null !== l && (clearTimeout(l), l = null), null !== f && (clearTimeout(f), f = null)) }, d = D(function (t) { e.resolved = Bt(t, i), c ? s.length = 0 : p(!0) }), v = D(function (t) { n(e.errorComp) && (e.error = !0, p(!0)) }), m = e(d, v); return o(m) && (u(m) ? t(e.resolved) && m.then(d, v) : u(m.component) && (m.component.then(d, v), n(m.error) && (e.errorComp = Bt(m.error, i)), n(m.loading) && (e.loadingComp = Bt(m.loading, i), 0 === m.delay ? e.loading = !0 : l = setTimeout(function () { l = null, t(e.resolved) && t(e.error) && (e.loading = !0, p(!1)) }, m.delay || 200)), n(m.timeout) && (f = setTimeout(function () { f = null, t(e.resolved) && v(null) }, m.timeout)))), c = !1, e.loading ? e.loadingComp : e.resolved } }(p = i, f))) return function (e, t, n, r, i) { var o = ve(); return o.asyncFactory = e, o.asyncMeta = { data: t, context: n, children: r, tag: i }, o }(p, a, s, c, l); a = a || {}, $n(i), n(a.model) && function (e, t) { var r = e.model && e.model.prop || "value", i = e.model && e.model.event || "input"; (t.attrs || (t.attrs = {}))[r] = t.model.value; var o = t.on || (t.on = {}), a = o[i], s = t.model.callback; n(a) ? (Array.isArray(a) ? -1 === a.indexOf(s) : a !== s) && (o[i] = [s].concat(a)) : o[i] = s }(i.options, a); var d = function (e, r, i) { var o = r.options.props; if (!t(o)) { var a = {}, s = e.attrs, c = e.props; if (n(s) || n(c)) for (var u in o) { var l = C(u); ot(a, c, u, l, !0) || ot(a, s, u, l, !1) } return a } }(a, i); if (r(i.options.functional)) return function (t, r, i, o, a) { var s = t.options, c = {}, u = s.props; if (n(u)) for (var l in u) c[l] = Me(l, u, r || e); else n(i.attrs) && Nt(c, i.attrs), n(i.props) && Nt(c, i.props); var f = new Tt(i, c, a, o, t), p = s.render.call(null, f._c, f); if (p instanceof pe) return Et(p, i, f.parent, s); if (Array.isArray(p)) { for (var d = at(p) || [], v = new Array(d.length), h = 0; h < d.length; h++)v[h] = Et(d[h], i, f.parent, s); return v } }(i, d, a, s, c); var v = a.on; if (a.on = a.nativeOn, r(i.options.abstract)) { var m = a.slot; a = {}, m && (a.slot = m) } !function (e) { for (var t = e.hook || (e.hook = {}), n = 0; n < Dt.length; n++) { var r = Dt[n], i = t[r], o = jt[r]; i === o || i && i._merged || (t[r] = i ? Mt(o, i) : o) } }(a); var y = i.options.name || l; return new pe("vue-component-" + i.cid + (y ? "-" + y : ""), a, void 0, void 0, void 0, s, { Ctor: i, propsData: d, listeners: v, tag: l, children: c }, p) } } } function Mt(e, t) { var n = function (n, r) { e(n, r), t(n, r) }; return n._merged = !0, n } var It = 1, Ft = 2; function Pt(e, a, s, c, u, l) { return (Array.isArray(s) || i(s)) && (u = c, c = s, s = void 0), r(l) && (u = Ft), function (e, i, a, s, c) { if (n(a) && n(a.__ob__)) return ve(); n(a) && n(a.is) && (i = a.is); if (!i) return ve(); Array.isArray(s) && "function" == typeof s[0] && ((a = a || {}).scopedSlots = { default: s[0] }, s.length = 0); c === Ft ? s = at(s) : c === It && (s = function (e) { for (var t = 0; t < e.length; t++)if (Array.isArray(e[t])) return Array.prototype.concat.apply([], e); return e }(s)); var u, l; if ("string" == typeof i) { var f; l = e.$vnode && e.$vnode.ns || F.getTagNamespace(i), u = F.isReservedTag(i) ? new pe(F.parsePlatformTagName(i), a, s, void 0, void 0, e) : a && a.pre || !n(f = Le(e.$options, "components", i)) ? new pe(i, a, s, void 0, void 0, e) : Lt(f, a, e, s, i) } else u = Lt(i, a, e, s); return Array.isArray(u) ? u : n(u) ? (n(l) && function e(i, o, a) { i.ns = o; "foreignObject" === i.tag && (o = void 0, a = !0); if (n(i.children)) for (var s = 0, c = i.children.length; s < c; s++) { var u = i.children[s]; n(u.tag) && (t(u.ns) || r(a) && "svg" !== u.tag) && e(u, o, a) } }(u, l), n(a) && function (e) { o(e.style) && et(e.style); o(e.class) && et(e.class) }(a), u) : ve() }(e, a, s, c, u) } var Rt, Ht = null; function Bt(e, t) { return (e.__esModule || oe && "Module" === e[Symbol.toStringTag]) && (e = e.default), o(e) ? t.extend(e) : e } function Ut(e) { return e.isComment && e.asyncFactory } function zt(e) { if (Array.isArray(e)) for (var t = 0; t < e.length; t++) { var r = e[t]; if (n(r) && (n(r.componentOptions) || Ut(r))) return r } } function Vt(e, t) { Rt.$on(e, t) } function Kt(e, t) { Rt.$off(e, t) } function Jt(e, t) { var n = Rt; return function r() { null !== t.apply(null, arguments) && n.$off(e, r) } } function qt(e, t, n) { Rt = e, rt(t, n || {}, Vt, Kt, Jt, e), Rt = void 0 } var Wt = null; function Zt(e) { var t = Wt; return Wt = e, function () { Wt = t } } function Gt(e) { for (; e && (e = e.$parent);)if (e._inactive) return !0; return !1 } function Xt(e, t) { if (t) { if (e._directInactive = !1, Gt(e)) return } else if (e._directInactive) return; if (e._inactive || null === e._inactive) { e._inactive = !1; for (var n = 0; n < e.$children.length; n++)Xt(e.$children[n]); Yt(e, "activated") } } function Yt(e, t) { le(); var n = e.$options[t], r = t + " hook"; if (n) for (var i = 0, o = n.length; i < o; i++)He(n[i], e, null, e, r); e._hasHookEvent && e.$emit("hook:" + t), fe() } var Qt = [], en = [], tn = {}, nn = !1, rn = !1, on = 0; var an = 0, sn = Date.now; if (z && !q) { var cn = window.performance; cn && "function" == typeof cn.now && sn() > document.createEvent("Event").timeStamp && (sn = function () { return cn.now() }) } function un() { var e, t; for (an = sn(), rn = !0, Qt.sort(function (e, t) { return e.id - t.id }), on = 0; on < Qt.length; on++)(e = Qt[on]).before && e.before(), t = e.id, tn[t] = null, e.run(); var n = en.slice(), r = Qt.slice(); on = Qt.length = en.length = 0, tn = {}, nn = rn = !1, function (e) { for (var t = 0; t < e.length; t++)e[t]._inactive = !0, Xt(e[t], !0) }(n), function (e) { var t = e.length; for (; t--;) { var n = e[t], r = n.vm; r._watcher === n && r._isMounted && !r._isDestroyed && Yt(r, "updated") } }(r), ne && F.devtools && ne.emit("flush") } var ln = 0, fn = function (e, t, n, r, i) { this.vm = e, i && (e._watcher = this), e._watchers.push(this), r ? (this.deep = !!r.deep, this.user = !!r.user, this.lazy = !!r.lazy, this.sync = !!r.sync, this.before = r.before) : this.deep = this.user = this.lazy = this.sync = !1, this.cb = n, this.id = ++ln, this.active = !0, this.dirty = this.lazy, this.deps = [], this.newDeps = [], this.depIds = new ie, this.newDepIds = new ie, this.expression = "", "function" == typeof t ? this.getter = t : (this.getter = function (e) { if (!H.test(e)) { var t = e.split("."); return function (e) { for (var n = 0; n < t.length; n++) { if (!e) return; e = e[t[n]] } return e } } }(t), this.getter || (this.getter = S)), this.value = this.lazy ? void 0 : this.get() }; fn.prototype.get = function () { var e; le(this); var t = this.vm; try { e = this.getter.call(t, t) } catch (e) { if (!this.user) throw e; Re(e, t, 'getter for watcher "' + this.expression + '"') } finally { this.deep && et(e), fe(), this.cleanupDeps() } return e }, fn.prototype.addDep = function (e) { var t = e.id; this.newDepIds.has(t) || (this.newDepIds.add(t), this.newDeps.push(e), this.depIds.has(t) || e.addSub(this)) }, fn.prototype.cleanupDeps = function () { for (var e = this.deps.length; e--;) { var t = this.deps[e]; this.newDepIds.has(t.id) || t.removeSub(this) } var n = this.depIds; this.depIds = this.newDepIds, this.newDepIds = n, this.newDepIds.clear(), n = this.deps, this.deps = this.newDeps, this.newDeps = n, this.newDeps.length = 0 }, fn.prototype.update = function () { this.lazy ? this.dirty = !0 : this.sync ? this.run() : function (e) { var t = e.id; if (null == tn[t]) { if (tn[t] = !0, rn) { for (var n = Qt.length - 1; n > on && Qt[n].id > e.id;)n--; Qt.splice(n + 1, 0, e) } else Qt.push(e); nn || (nn = !0, Ye(un)) } }(this) }, fn.prototype.run = function () { if (this.active) { var e = this.get(); if (e !== this.value || o(e) || this.deep) { var t = this.value; if (this.value = e, this.user) try { this.cb.call(this.vm, e, t) } catch (e) { Re(e, this.vm, 'callback for watcher "' + this.expression + '"') } else this.cb.call(this.vm, e, t) } } }, fn.prototype.evaluate = function () { this.value = this.get(), this.dirty = !1 }, fn.prototype.depend = function () { for (var e = this.deps.length; e--;)this.deps[e].depend() }, fn.prototype.teardown = function () { if (this.active) { this.vm._isBeingDestroyed || h(this.vm._watchers, this); for (var e = this.deps.length; e--;)this.deps[e].removeSub(this); this.active = !1 } }; var pn = { enumerable: !0, configurable: !0, get: S, set: S }; function dn(e, t, n) { pn.get = function () { return this[t][n] }, pn.set = function (e) { this[t][n] = e }, Object.defineProperty(e, n, pn) } function vn(e) { e._watchers = []; var t = e.$options; t.props && function (e, t) { var n = e.$options.propsData || {}, r = e._props = {}, i = e.$options._propKeys = []; e.$parent && $e(!1); var o = function (o) { i.push(o); var a = Me(o, t, n, e); xe(r, o, a), o in e || dn(e, "_props", o) }; for (var a in t) o(a); $e(!0) }(e, t.props), t.methods && function (e, t) { e.$options.props; for (var n in t) e[n] = "function" != typeof t[n] ? S : x(t[n], e) }(e, t.methods), t.data ? function (e) { var t = e.$options.data; s(t = e._data = "function" == typeof t ? function (e, t) { le(); try { return e.call(t, t) } catch (e) { return Re(e, t, "data()"), {} } finally { fe() } }(t, e) : t || {}) || (t = {}); var n = Object.keys(t), r = e.$options.props, i = (e.$options.methods, n.length); for (; i--;) { var o = n[i]; r && y(r, o) || (a = void 0, 36 !== (a = (o + "").charCodeAt(0)) && 95 !== a && dn(e, "_data", o)) } var a; Ce(t, !0) }(e) : Ce(e._data = {}, !0), t.computed && function (e, t) { var n = e._computedWatchers = Object.create(null), r = te(); for (var i in t) { var o = t[i], a = "function" == typeof o ? o : o.get; r || (n[i] = new fn(e, a || S, S, hn)), i in e || mn(e, i, o) } }(e, t.computed), t.watch && t.watch !== Y && function (e, t) { for (var n in t) { var r = t[n]; if (Array.isArray(r)) for (var i = 0; i < r.length; i++)_n(e, n, r[i]); else _n(e, n, r) } }(e, t.watch) } var hn = { lazy: !0 }; function mn(e, t, n) { var r = !te(); "function" == typeof n ? (pn.get = r ? yn(t) : gn(n), pn.set = S) : (pn.get = n.get ? r && !1 !== n.cache ? yn(t) : gn(n.get) : S, pn.set = n.set || S), Object.defineProperty(e, t, pn) } function yn(e) { return function () { var t = this._computedWatchers && this._computedWatchers[e]; if (t) return t.dirty && t.evaluate(), ce.target && t.depend(), t.value } } function gn(e) { return function () { return e.call(this, this) } } function _n(e, t, n, r) { return s(n) && (r = n, n = n.handler), "string" == typeof n && (n = e[n]), e.$watch(t, n, r) } var bn = 0; function $n(e) { var t = e.options; if (e.super) { var n = $n(e.super); if (n !== e.superOptions) { e.superOptions = n; var r = function (e) { var t, n = e.options, r = e.sealedOptions; for (var i in n) n[i] !== r[i] && (t || (t = {}), t[i] = n[i]); return t }(e); r && A(e.extendOptions, r), (t = e.options = De(n, e.extendOptions)).name && (t.components[t.name] = e) } } return t } function wn(e) { this._init(e) } function Cn(e) { e.cid = 0; var t = 1; e.extend = function (e) { e = e || {}; var n = this, r = n.cid, i = e._Ctor || (e._Ctor = {}); if (i[r]) return i[r]; var o = e.name || n.options.name, a = function (e) { this._init(e) }; return (a.prototype = Object.create(n.prototype)).constructor = a, a.cid = t++, a.options = De(n.options, e), a.super = n, a.options.props && function (e) { var t = e.options.props; for (var n in t) dn(e.prototype, "_props", n) }(a), a.options.computed && function (e) { var t = e.options.computed; for (var n in t) mn(e.prototype, n, t[n]) }(a), a.extend = n.extend, a.mixin = n.mixin, a.use = n.use, M.forEach(function (e) { a[e] = n[e] }), o && (a.options.components[o] = a), a.superOptions = n.options, a.extendOptions = e, a.sealedOptions = A({}, a.options), i[r] = a, a } } function xn(e) { return e && (e.Ctor.options.name || e.tag) } function kn(e, t) { return Array.isArray(e) ? e.indexOf(t) > -1 : "string" == typeof e ? e.split(",").indexOf(t) > -1 : (n = e, "[object RegExp]" === a.call(n) && e.test(t)); var n } function An(e, t) { var n = e.cache, r = e.keys, i = e._vnode; for (var o in n) { var a = n[o]; if (a) { var s = xn(a.componentOptions); s && !t(s) && On(n, o, r, i) } } } function On(e, t, n, r) { var i = e[t]; !i || r && i.tag === r.tag || i.componentInstance.$destroy(), e[t] = null, h(n, t) } !function (t) { t.prototype._init = function (t) { var n = this; n._uid = bn++, n._isVue = !0, t && t._isComponent ? function (e, t) { var n = e.$options = Object.create(e.constructor.options), r = t._parentVnode; n.parent = t.parent, n._parentVnode = r; var i = r.componentOptions; n.propsData = i.propsData, n._parentListeners = i.listeners, n._renderChildren = i.children, n._componentTag = i.tag, t.render && (n.render = t.render, n.staticRenderFns = t.staticRenderFns) }(n, t) : n.$options = De($n(n.constructor), t || {}, n), n._renderProxy = n, n._self = n, function (e) { var t = e.$options, n = t.parent; if (n && !t.abstract) { for (; n.$options.abstract && n.$parent;)n = n.$parent; n.$children.push(e) } e.$parent = n, e.$root = n ? n.$root : e, e.$children = [], e.$refs = {}, e._watcher = null, e._inactive = null, e._directInactive = !1, e._isMounted = !1, e._isDestroyed = !1, e._isBeingDestroyed = !1 }(n), function (e) { e._events = Object.create(null), e._hasHookEvent = !1; var t = e.$options._parentListeners; t && qt(e, t) }(n), function (t) { t._vnode = null, t._staticTrees = null; var n = t.$options, r = t.$vnode = n._parentVnode, i = r && r.context; t.$slots = ut(n._renderChildren, i), t.$scopedSlots = e, t._c = function (e, n, r, i) { return Pt(t, e, n, r, i, !1) }, t.$createElement = function (e, n, r, i) { return Pt(t, e, n, r, i, !0) }; var o = r && r.data; xe(t, "$attrs", o && o.attrs || e, null, !0), xe(t, "$listeners", n._parentListeners || e, null, !0) }(n), Yt(n, "beforeCreate"), function (e) { var t = ct(e.$options.inject, e); t && ($e(!1), Object.keys(t).forEach(function (n) { xe(e, n, t[n]) }), $e(!0)) }(n), vn(n), function (e) { var t = e.$options.provide; t && (e._provided = "function" == typeof t ? t.call(e) : t) }(n), Yt(n, "created"), n.$options.el && n.$mount(n.$options.el) } }(wn), function (e) { var t = { get: function () { return this._data } }, n = { get: function () { return this._props } }; Object.defineProperty(e.prototype, "$data", t), Object.defineProperty(e.prototype, "$props", n), e.prototype.$set = ke, e.prototype.$delete = Ae, e.prototype.$watch = function (e, t, n) { if (s(t)) return _n(this, e, t, n); (n = n || {}).user = !0; var r = new fn(this, e, t, n); if (n.immediate) try { t.call(this, r.value) } catch (e) { Re(e, this, 'callback for immediate watcher "' + r.expression + '"') } return function () { r.teardown() } } }(wn), function (e) { var t = /^hook:/; e.prototype.$on = function (e, n) { var r = this; if (Array.isArray(e)) for (var i = 0, o = e.length; i < o; i++)r.$on(e[i], n); else (r._events[e] || (r._events[e] = [])).push(n), t.test(e) && (r._hasHookEvent = !0); return r }, e.prototype.$once = function (e, t) { var n = this; function r() { n.$off(e, r), t.apply(n, arguments) } return r.fn = t, n.$on(e, r), n }, e.prototype.$off = function (e, t) { var n = this; if (!arguments.length) return n._events = Object.create(null), n; if (Array.isArray(e)) { for (var r = 0, i = e.length; r < i; r++)n.$off(e[r], t); return n } var o, a = n._events[e]; if (!a) return n; if (!t) return n._events[e] = null, n; for (var s = a.length; s--;)if ((o = a[s]) === t || o.fn === t) { a.splice(s, 1); break } return n }, e.prototype.$emit = function (e) { var t = this._events[e]; if (t) { t = t.length > 1 ? k(t) : t; for (var n = k(arguments, 1), r = 'event handler for "' + e + '"', i = 0, o = t.length; i < o; i++)He(t[i], this, n, this, r) } return this } }(wn), function (e) { e.prototype._update = function (e, t) { var n = this, r = n.$el, i = n._vnode, o = Zt(n); n._vnode = e, n.$el = i ? n.__patch__(i, e) : n.__patch__(n.$el, e, t, !1), o(), r && (r.__vue__ = null), n.$el && (n.$el.__vue__ = n), n.$vnode && n.$parent && n.$vnode === n.$parent._vnode && (n.$parent.$el = n.$el) }, e.prototype.$forceUpdate = function () { this._watcher && this._watcher.update() }, e.prototype.$destroy = function () { var e = this; if (!e._isBeingDestroyed) { Yt(e, "beforeDestroy"), e._isBeingDestroyed = !0; var t = e.$parent; !t || t._isBeingDestroyed || e.$options.abstract || h(t.$children, e), e._watcher && e._watcher.teardown(); for (var n = e._watchers.length; n--;)e._watchers[n].teardown(); e._data.__ob__ && e._data.__ob__.vmCount--, e._isDestroyed = !0, e.__patch__(e._vnode, null), Yt(e, "destroyed"), e.$off(), e.$el && (e.$el.__vue__ = null), e.$vnode && (e.$vnode.parent = null) } } }(wn), function (e) { St(e.prototype), e.prototype.$nextTick = function (e) { return Ye(e, this) }, e.prototype._render = function () { var e, t = this, n = t.$options, r = n.render, i = n._parentVnode; i && (t.$scopedSlots = ft(i.data.scopedSlots, t.$slots, t.$scopedSlots)), t.$vnode = i; try { Ht = t, e = r.call(t._renderProxy, t.$createElement) } catch (n) { Re(n, t, "render"), e = t._vnode } finally { Ht = null } return Array.isArray(e) && 1 === e.length && (e = e[0]), e instanceof pe || (e = ve()), e.parent = i, e } }(wn); var Sn = [String, RegExp, Array], Tn = { KeepAlive: { name: "keep-alive", abstract: !0, props: { include: Sn, exclude: Sn, max: [String, Number] }, created: function () { this.cache = Object.create(null), this.keys = [] }, destroyed: function () { for (var e in this.cache) On(this.cache, e, this.keys) }, mounted: function () { var e = this; this.$watch("include", function (t) { An(e, function (e) { return kn(t, e) }) }), this.$watch("exclude", function (t) { An(e, function (e) { return !kn(t, e) }) }) }, render: function () { var e = this.$slots.default, t = zt(e), n = t && t.componentOptions; if (n) { var r = xn(n), i = this.include, o = this.exclude; if (i && (!r || !kn(i, r)) || o && r && kn(o, r)) return t; var a = this.cache, s = this.keys, c = null == t.key ? n.Ctor.cid + (n.tag ? "::" + n.tag : "") : t.key; a[c] ? (t.componentInstance = a[c].componentInstance, h(s, c), s.push(c)) : (a[c] = t, s.push(c), this.max && s.length > parseInt(this.max) && On(a, s[0], s, this._vnode)), t.data.keepAlive = !0 } return t || e && e[0] } } }; !function (e) { var t = { get: function () { return F } }; Object.defineProperty(e, "config", t), e.util = { warn: ae, extend: A, mergeOptions: De, defineReactive: xe }, e.set = ke, e.delete = Ae, e.nextTick = Ye, e.observable = function (e) { return Ce(e), e }, e.options = Object.create(null), M.forEach(function (t) { e.options[t + "s"] = Object.create(null) }), e.options._base = e, A(e.options.components, Tn), function (e) { e.use = function (e) { var t = this._installedPlugins || (this._installedPlugins = []); if (t.indexOf(e) > -1) return this; var n = k(arguments, 1); return n.unshift(this), "function" == typeof e.install ? e.install.apply(e, n) : "function" == typeof e && e.apply(null, n), t.push(e), this } }(e), function (e) { e.mixin = function (e) { return this.options = De(this.options, e), this } }(e), Cn(e), function (e) { M.forEach(function (t) { e[t] = function (e, n) { return n ? ("component" === t && s(n) && (n.name = n.name || e, n = this.options._base.extend(n)), "directive" === t && "function" == typeof n && (n = { bind: n, update: n }), this.options[t + "s"][e] = n, n) : this.options[t + "s"][e] } }) }(e) }(wn), Object.defineProperty(wn.prototype, "$isServer", { get: te }), Object.defineProperty(wn.prototype, "$ssrContext", { get: function () { return this.$vnode && this.$vnode.ssrContext } }), Object.defineProperty(wn, "FunctionalRenderContext", { value: Tt }), wn.version = "2.6.10"; var En = p("style,class"), Nn = p("input,textarea,option,select,progress"), jn = function (e, t, n) { return "value" === n && Nn(e) && "button" !== t || "selected" === n && "option" === e || "checked" === n && "input" === e || "muted" === n && "video" === e }, Dn = p("contenteditable,draggable,spellcheck"), Ln = p("events,caret,typing,plaintext-only"), Mn = function (e, t) { return Hn(t) || "false" === t ? "false" : "contenteditable" === e && Ln(t) ? t : "true" }, In = p("allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,default,defaultchecked,defaultmuted,defaultselected,defer,disabled,enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,required,reversed,scoped,seamless,selected,sortable,translate,truespeed,typemustmatch,visible"), Fn = "http://www.w3.org/1999/xlink", Pn = function (e) { return ":" === e.charAt(5) && "xlink" === e.slice(0, 5) }, Rn = function (e) { return Pn(e) ? e.slice(6, e.length) : "" }, Hn = function (e) { return null == e || !1 === e }; function Bn(e) { for (var t = e.data, r = e, i = e; n(i.componentInstance);)(i = i.componentInstance._vnode) && i.data && (t = Un(i.data, t)); for (; n(r = r.parent);)r && r.data && (t = Un(t, r.data)); return function (e, t) { if (n(e) || n(t)) return zn(e, Vn(t)); return "" }(t.staticClass, t.class) } function Un(e, t) { return { staticClass: zn(e.staticClass, t.staticClass), class: n(e.class) ? [e.class, t.class] : t.class } } function zn(e, t) { return e ? t ? e + " " + t : e : t || "" } function Vn(e) { return Array.isArray(e) ? function (e) { for (var t, r = "", i = 0, o = e.length; i < o; i++)n(t = Vn(e[i])) && "" !== t && (r && (r += " "), r += t); return r }(e) : o(e) ? function (e) { var t = ""; for (var n in e) e[n] && (t && (t += " "), t += n); return t }(e) : "string" == typeof e ? e : "" } var Kn = { svg: "http://www.w3.org/2000/svg", math: "http://www.w3.org/1998/Math/MathML" }, Jn = p("html,body,base,head,link,meta,style,title,address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,menuitem,summary,content,element,shadow,template,blockquote,iframe,tfoot"), qn = p("svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,foreignObject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view", !0), Wn = function (e) { return Jn(e) || qn(e) }; function Zn(e) { return qn(e) ? "svg" : "math" === e ? "math" : void 0 } var Gn = Object.create(null); var Xn = p("text,number,password,search,email,tel,url"); function Yn(e) { if ("string" == typeof e) { var t = document.querySelector(e); return t || document.createElement("div") } return e } var Qn = Object.freeze({ createElement: function (e, t) { var n = document.createElement(e); return "select" !== e ? n : (t.data && t.data.attrs && void 0 !== t.data.attrs.multiple && n.setAttribute("multiple", "multiple"), n) }, createElementNS: function (e, t) { return document.createElementNS(Kn[e], t) }, createTextNode: function (e) { return document.createTextNode(e) }, createComment: function (e) { return document.createComment(e) }, insertBefore: function (e, t, n) { e.insertBefore(t, n) }, removeChild: function (e, t) { e.removeChild(t) }, appendChild: function (e, t) { e.appendChild(t) }, parentNode: function (e) { return e.parentNode }, nextSibling: function (e) { return e.nextSibling }, tagName: function (e) { return e.tagName }, setTextContent: function (e, t) { e.textContent = t }, setStyleScope: function (e, t) { e.setAttribute(t, "") } }), er = { create: function (e, t) { tr(t) }, update: function (e, t) { e.data.ref !== t.data.ref && (tr(e, !0), tr(t)) }, destroy: function (e) { tr(e, !0) } }; function tr(e, t) { var r = e.data.ref; if (n(r)) { var i = e.context, o = e.componentInstance || e.elm, a = i.$refs; t ? Array.isArray(a[r]) ? h(a[r], o) : a[r] === o && (a[r] = void 0) : e.data.refInFor ? Array.isArray(a[r]) ? a[r].indexOf(o) < 0 && a[r].push(o) : a[r] = [o] : a[r] = o } } var nr = new pe("", {}, []), rr = ["create", "activate", "update", "remove", "destroy"]; function ir(e, i) { return e.key === i.key && (e.tag === i.tag && e.isComment === i.isComment && n(e.data) === n(i.data) && function (e, t) { if ("input" !== e.tag) return !0; var r, i = n(r = e.data) && n(r = r.attrs) && r.type, o = n(r = t.data) && n(r = r.attrs) && r.type; return i === o || Xn(i) && Xn(o) }(e, i) || r(e.isAsyncPlaceholder) && e.asyncFactory === i.asyncFactory && t(i.asyncFactory.error)) } function or(e, t, r) { var i, o, a = {}; for (i = t; i <= r; ++i)n(o = e[i].key) && (a[o] = i); return a } var ar = { create: sr, update: sr, destroy: function (e) { sr(e, nr) } }; function sr(e, t) { (e.data.directives || t.data.directives) && function (e, t) { var n, r, i, o = e === nr, a = t === nr, s = ur(e.data.directives, e.context), c = ur(t.data.directives, t.context), u = [], l = []; for (n in c) r = s[n], i = c[n], r ? (i.oldValue = r.value, i.oldArg = r.arg, fr(i, "update", t, e), i.def && i.def.componentUpdated && l.push(i)) : (fr(i, "bind", t, e), i.def && i.def.inserted && u.push(i)); if (u.length) { var f = function () { for (var n = 0; n < u.length; n++)fr(u[n], "inserted", t, e) }; o ? it(t, "insert", f) : f() } l.length && it(t, "postpatch", function () { for (var n = 0; n < l.length; n++)fr(l[n], "componentUpdated", t, e) }); if (!o) for (n in s) c[n] || fr(s[n], "unbind", e, e, a) }(e, t) } var cr = Object.create(null); function ur(e, t) { var n, r, i = Object.create(null); if (!e) return i; for (n = 0; n < e.length; n++)(r = e[n]).modifiers || (r.modifiers = cr), i[lr(r)] = r, r.def = Le(t.$options, "directives", r.name); return i } function lr(e) { return e.rawName || e.name + "." + Object.keys(e.modifiers || {}).join(".") } function fr(e, t, n, r, i) { var o = e.def && e.def[t]; if (o) try { o(n.elm, e, n, r, i) } catch (r) { Re(r, n.context, "directive " + e.name + " " + t + " hook") } } var pr = [er, ar]; function dr(e, r) { var i = r.componentOptions; if (!(n(i) && !1 === i.Ctor.options.inheritAttrs || t(e.data.attrs) && t(r.data.attrs))) { var o, a, s = r.elm, c = e.data.attrs || {}, u = r.data.attrs || {}; for (o in n(u.__ob__) && (u = r.data.attrs = A({}, u)), u) a = u[o], c[o] !== a && vr(s, o, a); for (o in (q || Z) && u.value !== c.value && vr(s, "value", u.value), c) t(u[o]) && (Pn(o) ? s.removeAttributeNS(Fn, Rn(o)) : Dn(o) || s.removeAttribute(o)) } } function vr(e, t, n) { e.tagName.indexOf("-") > -1 ? hr(e, t, n) : In(t) ? Hn(n) ? e.removeAttribute(t) : (n = "allowfullscreen" === t && "EMBED" === e.tagName ? "true" : t, e.setAttribute(t, n)) : Dn(t) ? e.setAttribute(t, Mn(t, n)) : Pn(t) ? Hn(n) ? e.removeAttributeNS(Fn, Rn(t)) : e.setAttributeNS(Fn, t, n) : hr(e, t, n) } function hr(e, t, n) { if (Hn(n)) e.removeAttribute(t); else { if (q && !W && "TEXTAREA" === e.tagName && "placeholder" === t && "" !== n && !e.__ieph) { var r = function (t) { t.stopImmediatePropagation(), e.removeEventListener("input", r) }; e.addEventListener("input", r), e.__ieph = !0 } e.setAttribute(t, n) } } var mr = { create: dr, update: dr }; function yr(e, r) { var i = r.elm, o = r.data, a = e.data; if (!(t(o.staticClass) && t(o.class) && (t(a) || t(a.staticClass) && t(a.class)))) { var s = Bn(r), c = i._transitionClasses; n(c) && (s = zn(s, Vn(c))), s !== i._prevClass && (i.setAttribute("class", s), i._prevClass = s) } } var gr, _r, br, $r, wr, Cr, xr = { create: yr, update: yr }, kr = /[\w).+\-_$\]]/; function Ar(e) { var t, n, r, i, o, a = !1, s = !1, c = !1, u = !1, l = 0, f = 0, p = 0, d = 0; for (r = 0; r < e.length; r++)if (n = t, t = e.charCodeAt(r), a) 39 === t && 92 !== n && (a = !1); else if (s) 34 === t && 92 !== n && (s = !1); else if (c) 96 === t && 92 !== n && (c = !1); else if (u) 47 === t && 92 !== n && (u = !1); else if (124 !== t || 124 === e.charCodeAt(r + 1) || 124 === e.charCodeAt(r - 1) || l || f || p) { switch (t) { case 34: s = !0; break; case 39: a = !0; break; case 96: c = !0; break; case 40: p++; break; case 41: p--; break; case 91: f++; break; case 93: f--; break; case 123: l++; break; case 125: l-- }if (47 === t) { for (var v = r - 1, h = void 0; v >= 0 && " " === (h = e.charAt(v)); v--); h && kr.test(h) || (u = !0) } } else void 0 === i ? (d = r + 1, i = e.slice(0, r).trim()) : m(); function m() { (o || (o = [])).push(e.slice(d, r).trim()), d = r + 1 } if (void 0 === i ? i = e.slice(0, r).trim() : 0 !== d && m(), o) for (r = 0; r < o.length; r++)i = Or(i, o[r]); return i } function Or(e, t) { var n = t.indexOf("("); if (n < 0) return '_f("' + t + '")(' + e + ")"; var r = t.slice(0, n), i = t.slice(n + 1); return '_f("' + r + '")(' + e + (")" !== i ? "," + i : i) } function Sr(e, t) { console.error("[Vue compiler]: " + e) } function Tr(e, t) { return e ? e.map(function (e) { return e[t] }).filter(function (e) { return e }) : [] } function Er(e, t, n, r, i) { (e.props || (e.props = [])).push(Rr({ name: t, value: n, dynamic: i }, r)), e.plain = !1 } function Nr(e, t, n, r, i) { (i ? e.dynamicAttrs || (e.dynamicAttrs = []) : e.attrs || (e.attrs = [])).push(Rr({ name: t, value: n, dynamic: i }, r)), e.plain = !1 } function jr(e, t, n, r) { e.attrsMap[t] = n, e.attrsList.push(Rr({ name: t, value: n }, r)) } function Dr(e, t, n, r, i, o, a, s) { (e.directives || (e.directives = [])).push(Rr({ name: t, rawName: n, value: r, arg: i, isDynamicArg: o, modifiers: a }, s)), e.plain = !1 } function Lr(e, t, n) { return n ? "_p(" + t + ',"' + e + '")' : e + t } function Mr(t, n, r, i, o, a, s, c) { var u; (i = i || e).right ? c ? n = "(" + n + ")==='click'?'contextmenu':(" + n + ")" : "click" === n && (n = "contextmenu", delete i.right) : i.middle && (c ? n = "(" + n + ")==='click'?'mouseup':(" + n + ")" : "click" === n && (n = "mouseup")), i.capture && (delete i.capture, n = Lr("!", n, c)), i.once && (delete i.once, n = Lr("~", n, c)), i.passive && (delete i.passive, n = Lr("&", n, c)), i.native ? (delete i.native, u = t.nativeEvents || (t.nativeEvents = {})) : u = t.events || (t.events = {}); var l = Rr({ value: r.trim(), dynamic: c }, s); i !== e && (l.modifiers = i); var f = u[n]; Array.isArray(f) ? o ? f.unshift(l) : f.push(l) : u[n] = f ? o ? [l, f] : [f, l] : l, t.plain = !1 } function Ir(e, t, n) { var r = Fr(e, ":" + t) || Fr(e, "v-bind:" + t); if (null != r) return Ar(r); if (!1 !== n) { var i = Fr(e, t); if (null != i) return JSON.stringify(i) } } function Fr(e, t, n) { var r; if (null != (r = e.attrsMap[t])) for (var i = e.attrsList, o = 0, a = i.length; o < a; o++)if (i[o].name === t) { i.splice(o, 1); break } return n && delete e.attrsMap[t], r } function Pr(e, t) { for (var n = e.attrsList, r = 0, i = n.length; r < i; r++) { var o = n[r]; if (t.test(o.name)) return n.splice(r, 1), o } } function Rr(e, t) { return t && (null != t.start && (e.start = t.start), null != t.end && (e.end = t.end)), e } function Hr(e, t, n) { var r = n || {}, i = r.number, o = "$$v"; r.trim && (o = "(typeof $$v === 'string'? $$v.trim(): $$v)"), i && (o = "_n(" + o + ")"); var a = Br(t, o); e.model = { value: "(" + t + ")", expression: JSON.stringify(t), callback: "function ($$v) {" + a + "}" } } function Br(e, t) { var n = function (e) { if (e = e.trim(), gr = e.length, e.indexOf("[") < 0 || e.lastIndexOf("]") < gr - 1) return ($r = e.lastIndexOf(".")) > -1 ? { exp: e.slice(0, $r), key: '"' + e.slice($r + 1) + '"' } : { exp: e, key: null }; _r = e, $r = wr = Cr = 0; for (; !zr();)Vr(br = Ur()) ? Jr(br) : 91 === br && Kr(br); return { exp: e.slice(0, wr), key: e.slice(wr + 1, Cr) } }(e); return null === n.key ? e + "=" + t : "$set(" + n.exp + ", " + n.key + ", " + t + ")" } function Ur() { return _r.charCodeAt(++$r) } function zr() { return $r >= gr } function Vr(e) { return 34 === e || 39 === e } function Kr(e) { var t = 1; for (wr = $r; !zr();)if (Vr(e = Ur())) Jr(e); else if (91 === e && t++, 93 === e && t--, 0 === t) { Cr = $r; break } } function Jr(e) { for (var t = e; !zr() && (e = Ur()) !== t;); } var qr, Wr = "__r", Zr = "__c"; function Gr(e, t, n) { var r = qr; return function i() { null !== t.apply(null, arguments) && Qr(e, i, n, r) } } var Xr = Ve && !(X && Number(X[1]) <= 53); function Yr(e, t, n, r) { if (Xr) { var i = an, o = t; t = o._wrapper = function (e) { if (e.target === e.currentTarget || e.timeStamp >= i || e.timeStamp <= 0 || e.target.ownerDocument !== document) return o.apply(this, arguments) } } qr.addEventListener(e, t, Q ? { capture: n, passive: r } : n) } function Qr(e, t, n, r) { (r || qr).removeEventListener(e, t._wrapper || t, n) } function ei(e, r) { if (!t(e.data.on) || !t(r.data.on)) { var i = r.data.on || {}, o = e.data.on || {}; qr = r.elm, function (e) { if (n(e[Wr])) { var t = q ? "change" : "input"; e[t] = [].concat(e[Wr], e[t] || []), delete e[Wr] } n(e[Zr]) && (e.change = [].concat(e[Zr], e.change || []), delete e[Zr]) }(i), rt(i, o, Yr, Qr, Gr, r.context), qr = void 0 } } var ti, ni = { create: ei, update: ei }; function ri(e, r) { if (!t(e.data.domProps) || !t(r.data.domProps)) { var i, o, a = r.elm, s = e.data.domProps || {}, c = r.data.domProps || {}; for (i in n(c.__ob__) && (c = r.data.domProps = A({}, c)), s) i in c || (a[i] = ""); for (i in c) { if (o = c[i], "textContent" === i || "innerHTML" === i) { if (r.children && (r.children.length = 0), o === s[i]) continue; 1 === a.childNodes.length && a.removeChild(a.childNodes[0]) } if ("value" === i && "PROGRESS" !== a.tagName) { a._value = o; var u = t(o) ? "" : String(o); ii(a, u) && (a.value = u) } else if ("innerHTML" === i && qn(a.tagName) && t(a.innerHTML)) { (ti = ti || document.createElement("div")).innerHTML = "<svg>" + o + "</svg>"; for (var l = ti.firstChild; a.firstChild;)a.removeChild(a.firstChild); for (; l.firstChild;)a.appendChild(l.firstChild) } else if (o !== s[i]) try { a[i] = o } catch (e) { } } } } function ii(e, t) { return !e.composing && ("OPTION" === e.tagName || function (e, t) { var n = !0; try { n = document.activeElement !== e } catch (e) { } return n && e.value !== t }(e, t) || function (e, t) { var r = e.value, i = e._vModifiers; if (n(i)) { if (i.number) return f(r) !== f(t); if (i.trim) return r.trim() !== t.trim() } return r !== t }(e, t)) } var oi = { create: ri, update: ri }, ai = g(function (e) { var t = {}, n = /:(.+)/; return e.split(/;(?![^(]*\))/g).forEach(function (e) { if (e) { var r = e.split(n); r.length > 1 && (t[r[0].trim()] = r[1].trim()) } }), t }); function si(e) { var t = ci(e.style); return e.staticStyle ? A(e.staticStyle, t) : t } function ci(e) { return Array.isArray(e) ? O(e) : "string" == typeof e ? ai(e) : e } var ui, li = /^--/, fi = /\s*!important$/, pi = function (e, t, n) { if (li.test(t)) e.style.setProperty(t, n); else if (fi.test(n)) e.style.setProperty(C(t), n.replace(fi, ""), "important"); else { var r = vi(t); if (Array.isArray(n)) for (var i = 0, o = n.length; i < o; i++)e.style[r] = n[i]; else e.style[r] = n } }, di = ["Webkit", "Moz", "ms"], vi = g(function (e) { if (ui = ui || document.createElement("div").style, "filter" !== (e = b(e)) && e in ui) return e; for (var t = e.charAt(0).toUpperCase() + e.slice(1), n = 0; n < di.length; n++) { var r = di[n] + t; if (r in ui) return r } }); function hi(e, r) { var i = r.data, o = e.data; if (!(t(i.staticStyle) && t(i.style) && t(o.staticStyle) && t(o.style))) { var a, s, c = r.elm, u = o.staticStyle, l = o.normalizedStyle || o.style || {}, f = u || l, p = ci(r.data.style) || {}; r.data.normalizedStyle = n(p.__ob__) ? A({}, p) : p; var d = function (e, t) { var n, r = {}; if (t) for (var i = e; i.componentInstance;)(i = i.componentInstance._vnode) && i.data && (n = si(i.data)) && A(r, n); (n = si(e.data)) && A(r, n); for (var o = e; o = o.parent;)o.data && (n = si(o.data)) && A(r, n); return r }(r, !0); for (s in f) t(d[s]) && pi(c, s, ""); for (s in d) (a = d[s]) !== f[s] && pi(c, s, null == a ? "" : a) } } var mi = { create: hi, update: hi }, yi = /\s+/; function gi(e, t) { if (t && (t = t.trim())) if (e.classList) t.indexOf(" ") > -1 ? t.split(yi).forEach(function (t) { return e.classList.add(t) }) : e.classList.add(t); else { var n = " " + (e.getAttribute("class") || "") + " "; n.indexOf(" " + t + " ") < 0 && e.setAttribute("class", (n + t).trim()) } } function _i(e, t) { if (t && (t = t.trim())) if (e.classList) t.indexOf(" ") > -1 ? t.split(yi).forEach(function (t) { return e.classList.remove(t) }) : e.classList.remove(t), e.classList.length || e.removeAttribute("class"); else { for (var n = " " + (e.getAttribute("class") || "") + " ", r = " " + t + " "; n.indexOf(r) >= 0;)n = n.replace(r, " "); (n = n.trim()) ? e.setAttribute("class", n) : e.removeAttribute("class") } } function bi(e) { if (e) { if ("object" == typeof e) { var t = {}; return !1 !== e.css && A(t, $i(e.name || "v")), A(t, e), t } return "string" == typeof e ? $i(e) : void 0 } } var $i = g(function (e) { return { enterClass: e + "-enter", enterToClass: e + "-enter-to", enterActiveClass: e + "-enter-active", leaveClass: e + "-leave", leaveToClass: e + "-leave-to", leaveActiveClass: e + "-leave-active" } }), wi = z && !W, Ci = "transition", xi = "animation", ki = "transition", Ai = "transitionend", Oi = "animation", Si = "animationend"; wi && (void 0 === window.ontransitionend && void 0 !== window.onwebkittransitionend && (ki = "WebkitTransition", Ai = "webkitTransitionEnd"), void 0 === window.onanimationend && void 0 !== window.onwebkitanimationend && (Oi = "WebkitAnimation", Si = "webkitAnimationEnd")); var Ti = z ? window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : setTimeout : function (e) { return e() }; function Ei(e) { Ti(function () { Ti(e) }) } function Ni(e, t) { var n = e._transitionClasses || (e._transitionClasses = []); n.indexOf(t) < 0 && (n.push(t), gi(e, t)) } function ji(e, t) { e._transitionClasses && h(e._transitionClasses, t), _i(e, t) } function Di(e, t, n) { var r = Mi(e, t), i = r.type, o = r.timeout, a = r.propCount; if (!i) return n(); var s = i === Ci ? Ai : Si, c = 0, u = function () { e.removeEventListener(s, l), n() }, l = function (t) { t.target === e && ++c >= a && u() }; setTimeout(function () { c < a && u() }, o + 1), e.addEventListener(s, l) } var Li = /\b(transform|all)(,|$)/; function Mi(e, t) { var n, r = window.getComputedStyle(e), i = (r[ki + "Delay"] || "").split(", "), o = (r[ki + "Duration"] || "").split(", "), a = Ii(i, o), s = (r[Oi + "Delay"] || "").split(", "), c = (r[Oi + "Duration"] || "").split(", "), u = Ii(s, c), l = 0, f = 0; return t === Ci ? a > 0 && (n = Ci, l = a, f = o.length) : t === xi ? u > 0 && (n = xi, l = u, f = c.length) : f = (n = (l = Math.max(a, u)) > 0 ? a > u ? Ci : xi : null) ? n === Ci ? o.length : c.length : 0, { type: n, timeout: l, propCount: f, hasTransform: n === Ci && Li.test(r[ki + "Property"]) } } function Ii(e, t) { for (; e.length < t.length;)e = e.concat(e); return Math.max.apply(null, t.map(function (t, n) { return Fi(t) + Fi(e[n]) })) } function Fi(e) { return 1e3 * Number(e.slice(0, -1).replace(",", ".")) } function Pi(e, r) { var i = e.elm; n(i._leaveCb) && (i._leaveCb.cancelled = !0, i._leaveCb()); var a = bi(e.data.transition); if (!t(a) && !n(i._enterCb) && 1 === i.nodeType) { for (var s = a.css, c = a.type, u = a.enterClass, l = a.enterToClass, p = a.enterActiveClass, d = a.appearClass, v = a.appearToClass, h = a.appearActiveClass, m = a.beforeEnter, y = a.enter, g = a.afterEnter, _ = a.enterCancelled, b = a.beforeAppear, $ = a.appear, w = a.afterAppear, C = a.appearCancelled, x = a.duration, k = Wt, A = Wt.$vnode; A && A.parent;)k = A.context, A = A.parent; var O = !k._isMounted || !e.isRootInsert; if (!O || $ || "" === $) { var S = O && d ? d : u, T = O && h ? h : p, E = O && v ? v : l, N = O && b || m, j = O && "function" == typeof $ ? $ : y, L = O && w || g, M = O && C || _, I = f(o(x) ? x.enter : x), F = !1 !== s && !W, P = Bi(j), R = i._enterCb = D(function () { F && (ji(i, E), ji(i, T)), R.cancelled ? (F && ji(i, S), M && M(i)) : L && L(i), i._enterCb = null }); e.data.show || it(e, "insert", function () { var t = i.parentNode, n = t && t._pending && t._pending[e.key]; n && n.tag === e.tag && n.elm._leaveCb && n.elm._leaveCb(), j && j(i, R) }), N && N(i), F && (Ni(i, S), Ni(i, T), Ei(function () { ji(i, S), R.cancelled || (Ni(i, E), P || (Hi(I) ? setTimeout(R, I) : Di(i, c, R))) })), e.data.show && (r && r(), j && j(i, R)), F || P || R() } } } function Ri(e, r) { var i = e.elm; n(i._enterCb) && (i._enterCb.cancelled = !0, i._enterCb()); var a = bi(e.data.transition); if (t(a) || 1 !== i.nodeType) return r(); if (!n(i._leaveCb)) { var s = a.css, c = a.type, u = a.leaveClass, l = a.leaveToClass, p = a.leaveActiveClass, d = a.beforeLeave, v = a.leave, h = a.afterLeave, m = a.leaveCancelled, y = a.delayLeave, g = a.duration, _ = !1 !== s && !W, b = Bi(v), $ = f(o(g) ? g.leave : g), w = i._leaveCb = D(function () { i.parentNode && i.parentNode._pending && (i.parentNode._pending[e.key] = null), _ && (ji(i, l), ji(i, p)), w.cancelled ? (_ && ji(i, u), m && m(i)) : (r(), h && h(i)), i._leaveCb = null }); y ? y(C) : C() } function C() { w.cancelled || (!e.data.show && i.parentNode && ((i.parentNode._pending || (i.parentNode._pending = {}))[e.key] = e), d && d(i), _ && (Ni(i, u), Ni(i, p), Ei(function () { ji(i, u), w.cancelled || (Ni(i, l), b || (Hi($) ? setTimeout(w, $) : Di(i, c, w))) })), v && v(i, w), _ || b || w()) } } function Hi(e) { return "number" == typeof e && !isNaN(e) } function Bi(e) { if (t(e)) return !1; var r = e.fns; return n(r) ? Bi(Array.isArray(r) ? r[0] : r) : (e._length || e.length) > 1 } function Ui(e, t) { !0 !== t.data.show && Pi(t) } var zi = function (e) { var o, a, s = {}, c = e.modules, u = e.nodeOps; for (o = 0; o < rr.length; ++o)for (s[rr[o]] = [], a = 0; a < c.length; ++a)n(c[a][rr[o]]) && s[rr[o]].push(c[a][rr[o]]); function l(e) { var t = u.parentNode(e); n(t) && u.removeChild(t, e) } function f(e, t, i, o, a, c, l) { if (n(e.elm) && n(c) && (e = c[l] = me(e)), e.isRootInsert = !a, !function (e, t, i, o) { var a = e.data; if (n(a)) { var c = n(e.componentInstance) && a.keepAlive; if (n(a = a.hook) && n(a = a.init) && a(e, !1), n(e.componentInstance)) return d(e, t), v(i, e.elm, o), r(c) && function (e, t, r, i) { for (var o, a = e; a.componentInstance;)if (a = a.componentInstance._vnode, n(o = a.data) && n(o = o.transition)) { for (o = 0; o < s.activate.length; ++o)s.activate[o](nr, a); t.push(a); break } v(r, e.elm, i) }(e, t, i, o), !0 } }(e, t, i, o)) { var f = e.data, p = e.children, m = e.tag; n(m) ? (e.elm = e.ns ? u.createElementNS(e.ns, m) : u.createElement(m, e), g(e), h(e, p, t), n(f) && y(e, t), v(i, e.elm, o)) : r(e.isComment) ? (e.elm = u.createComment(e.text), v(i, e.elm, o)) : (e.elm = u.createTextNode(e.text), v(i, e.elm, o)) } } function d(e, t) { n(e.data.pendingInsert) && (t.push.apply(t, e.data.pendingInsert), e.data.pendingInsert = null), e.elm = e.componentInstance.$el, m(e) ? (y(e, t), g(e)) : (tr(e), t.push(e)) } function v(e, t, r) { n(e) && (n(r) ? u.parentNode(r) === e && u.insertBefore(e, t, r) : u.appendChild(e, t)) } function h(e, t, n) { if (Array.isArray(t)) for (var r = 0; r < t.length; ++r)f(t[r], n, e.elm, null, !0, t, r); else i(e.text) && u.appendChild(e.elm, u.createTextNode(String(e.text))) } function m(e) { for (; e.componentInstance;)e = e.componentInstance._vnode; return n(e.tag) } function y(e, t) { for (var r = 0; r < s.create.length; ++r)s.create[r](nr, e); n(o = e.data.hook) && (n(o.create) && o.create(nr, e), n(o.insert) && t.push(e)) } function g(e) { var t; if (n(t = e.fnScopeId)) u.setStyleScope(e.elm, t); else for (var r = e; r;)n(t = r.context) && n(t = t.$options._scopeId) && u.setStyleScope(e.elm, t), r = r.parent; n(t = Wt) && t !== e.context && t !== e.fnContext && n(t = t.$options._scopeId) && u.setStyleScope(e.elm, t) } function _(e, t, n, r, i, o) { for (; r <= i; ++r)f(n[r], o, e, t, !1, n, r) } function b(e) { var t, r, i = e.data; if (n(i)) for (n(t = i.hook) && n(t = t.destroy) && t(e), t = 0; t < s.destroy.length; ++t)s.destroy[t](e); if (n(t = e.children)) for (r = 0; r < e.children.length; ++r)b(e.children[r]) } function $(e, t, r, i) { for (; r <= i; ++r) { var o = t[r]; n(o) && (n(o.tag) ? (w(o), b(o)) : l(o.elm)) } } function w(e, t) { if (n(t) || n(e.data)) { var r, i = s.remove.length + 1; for (n(t) ? t.listeners += i : t = function (e, t) { function n() { 0 == --n.listeners && l(e) } return n.listeners = t, n }(e.elm, i), n(r = e.componentInstance) && n(r = r._vnode) && n(r.data) && w(r, t), r = 0; r < s.remove.length; ++r)s.remove[r](e, t); n(r = e.data.hook) && n(r = r.remove) ? r(e, t) : t() } else l(e.elm) } function C(e, t, r, i) { for (var o = r; o < i; o++) { var a = t[o]; if (n(a) && ir(e, a)) return o } } function x(e, i, o, a, c, l) { if (e !== i) { n(i.elm) && n(a) && (i = a[c] = me(i)); var p = i.elm = e.elm; if (r(e.isAsyncPlaceholder)) n(i.asyncFactory.resolved) ? O(e.elm, i, o) : i.isAsyncPlaceholder = !0; else if (r(i.isStatic) && r(e.isStatic) && i.key === e.key && (r(i.isCloned) || r(i.isOnce))) i.componentInstance = e.componentInstance; else { var d, v = i.data; n(v) && n(d = v.hook) && n(d = d.prepatch) && d(e, i); var h = e.children, y = i.children; if (n(v) && m(i)) { for (d = 0; d < s.update.length; ++d)s.update[d](e, i); n(d = v.hook) && n(d = d.update) && d(e, i) } t(i.text) ? n(h) && n(y) ? h !== y && function (e, r, i, o, a) { for (var s, c, l, p = 0, d = 0, v = r.length - 1, h = r[0], m = r[v], y = i.length - 1, g = i[0], b = i[y], w = !a; p <= v && d <= y;)t(h) ? h = r[++p] : t(m) ? m = r[--v] : ir(h, g) ? (x(h, g, o, i, d), h = r[++p], g = i[++d]) : ir(m, b) ? (x(m, b, o, i, y), m = r[--v], b = i[--y]) : ir(h, b) ? (x(h, b, o, i, y), w && u.insertBefore(e, h.elm, u.nextSibling(m.elm)), h = r[++p], b = i[--y]) : ir(m, g) ? (x(m, g, o, i, d), w && u.insertBefore(e, m.elm, h.elm), m = r[--v], g = i[++d]) : (t(s) && (s = or(r, p, v)), t(c = n(g.key) ? s[g.key] : C(g, r, p, v)) ? f(g, o, e, h.elm, !1, i, d) : ir(l = r[c], g) ? (x(l, g, o, i, d), r[c] = void 0, w && u.insertBefore(e, l.elm, h.elm)) : f(g, o, e, h.elm, !1, i, d), g = i[++d]); p > v ? _(e, t(i[y + 1]) ? null : i[y + 1].elm, i, d, y, o) : d > y && $(0, r, p, v) }(p, h, y, o, l) : n(y) ? (n(e.text) && u.setTextContent(p, ""), _(p, null, y, 0, y.length - 1, o)) : n(h) ? $(0, h, 0, h.length - 1) : n(e.text) && u.setTextContent(p, "") : e.text !== i.text && u.setTextContent(p, i.text), n(v) && n(d = v.hook) && n(d = d.postpatch) && d(e, i) } } } function k(e, t, i) { if (r(i) && n(e.parent)) e.parent.data.pendingInsert = t; else for (var o = 0; o < t.length; ++o)t[o].data.hook.insert(t[o]) } var A = p("attrs,class,staticClass,staticStyle,key"); function O(e, t, i, o) { var a, s = t.tag, c = t.data, u = t.children; if (o = o || c && c.pre, t.elm = e, r(t.isComment) && n(t.asyncFactory)) return t.isAsyncPlaceholder = !0, !0; if (n(c) && (n(a = c.hook) && n(a = a.init) && a(t, !0), n(a = t.componentInstance))) return d(t, i), !0; if (n(s)) { if (n(u)) if (e.hasChildNodes()) if (n(a = c) && n(a = a.domProps) && n(a = a.innerHTML)) { if (a !== e.innerHTML) return !1 } else { for (var l = !0, f = e.firstChild, p = 0; p < u.length; p++) { if (!f || !O(f, u[p], i, o)) { l = !1; break } f = f.nextSibling } if (!l || f) return !1 } else h(t, u, i); if (n(c)) { var v = !1; for (var m in c) if (!A(m)) { v = !0, y(t, i); break } !v && c.class && et(c.class) } } else e.data !== t.text && (e.data = t.text); return !0 } return function (e, i, o, a) { if (!t(i)) { var c, l = !1, p = []; if (t(e)) l = !0, f(i, p); else { var d = n(e.nodeType); if (!d && ir(e, i)) x(e, i, p, null, null, a); else { if (d) { if (1 === e.nodeType && e.hasAttribute(L) && (e.removeAttribute(L), o = !0), r(o) && O(e, i, p)) return k(i, p, !0), e; c = e, e = new pe(u.tagName(c).toLowerCase(), {}, [], void 0, c) } var v = e.elm, h = u.parentNode(v); if (f(i, p, v._leaveCb ? null : h, u.nextSibling(v)), n(i.parent)) for (var y = i.parent, g = m(i); y;) { for (var _ = 0; _ < s.destroy.length; ++_)s.destroy[_](y); if (y.elm = i.elm, g) { for (var w = 0; w < s.create.length; ++w)s.create[w](nr, y); var C = y.data.hook.insert; if (C.merged) for (var A = 1; A < C.fns.length; A++)C.fns[A]() } else tr(y); y = y.parent } n(h) ? $(0, [e], 0, 0) : n(e.tag) && b(e) } } return k(i, p, l), i.elm } n(e) && b(e) } }({ nodeOps: Qn, modules: [mr, xr, ni, oi, mi, z ? { create: Ui, activate: Ui, remove: function (e, t) { !0 !== e.data.show ? Ri(e, t) : t() } } : {}].concat(pr) }); W && document.addEventListener("selectionchange", function () { var e = document.activeElement; e && e.vmodel && Xi(e, "input") }); var Vi = { inserted: function (e, t, n, r) { "select" === n.tag ? (r.elm && !r.elm._vOptions ? it(n, "postpatch", function () { Vi.componentUpdated(e, t, n) }) : Ki(e, t, n.context), e._vOptions = [].map.call(e.options, Wi)) : ("textarea" === n.tag || Xn(e.type)) && (e._vModifiers = t.modifiers, t.modifiers.lazy || (e.addEventListener("compositionstart", Zi), e.addEventListener("compositionend", Gi), e.addEventListener("change", Gi), W && (e.vmodel = !0))) }, componentUpdated: function (e, t, n) { if ("select" === n.tag) { Ki(e, t, n.context); var r = e._vOptions, i = e._vOptions = [].map.call(e.options, Wi); if (i.some(function (e, t) { return !N(e, r[t]) })) (e.multiple ? t.value.some(function (e) { return qi(e, i) }) : t.value !== t.oldValue && qi(t.value, i)) && Xi(e, "change") } } }; function Ki(e, t, n) { Ji(e, t, n), (q || Z) && setTimeout(function () { Ji(e, t, n) }, 0) } function Ji(e, t, n) { var r = t.value, i = e.multiple; if (!i || Array.isArray(r)) { for (var o, a, s = 0, c = e.options.length; s < c; s++)if (a = e.options[s], i) o = j(r, Wi(a)) > -1, a.selected !== o && (a.selected = o); else if (N(Wi(a), r)) return void (e.selectedIndex !== s && (e.selectedIndex = s)); i || (e.selectedIndex = -1) } } function qi(e, t) { return t.every(function (t) { return !N(t, e) }) } function Wi(e) { return "_value" in e ? e._value : e.value } function Zi(e) { e.target.composing = !0 } function Gi(e) { e.target.composing && (e.target.composing = !1, Xi(e.target, "input")) } function Xi(e, t) { var n = document.createEvent("HTMLEvents"); n.initEvent(t, !0, !0), e.dispatchEvent(n) } function Yi(e) { return !e.componentInstance || e.data && e.data.transition ? e : Yi(e.componentInstance._vnode) } var Qi = { model: Vi, show: { bind: function (e, t, n) { var r = t.value, i = (n = Yi(n)).data && n.data.transition, o = e.__vOriginalDisplay = "none" === e.style.display ? "" : e.style.display; r && i ? (n.data.show = !0, Pi(n, function () { e.style.display = o })) : e.style.display = r ? o : "none" }, update: function (e, t, n) { var r = t.value; !r != !t.oldValue && ((n = Yi(n)).data && n.data.transition ? (n.data.show = !0, r ? Pi(n, function () { e.style.display = e.__vOriginalDisplay }) : Ri(n, function () { e.style.display = "none" })) : e.style.display = r ? e.__vOriginalDisplay : "none") }, unbind: function (e, t, n, r, i) { i || (e.style.display = e.__vOriginalDisplay) } } }, eo = { name: String, appear: Boolean, css: Boolean, mode: String, type: String, enterClass: String, leaveClass: String, enterToClass: String, leaveToClass: String, enterActiveClass: String, leaveActiveClass: String, appearClass: String, appearActiveClass: String, appearToClass: String, duration: [Number, String, Object] }; function to(e) { var t = e && e.componentOptions; return t && t.Ctor.options.abstract ? to(zt(t.children)) : e } function no(e) { var t = {}, n = e.$options; for (var r in n.propsData) t[r] = e[r]; var i = n._parentListeners; for (var o in i) t[b(o)] = i[o]; return t } function ro(e, t) { if (/\d-keep-alive$/.test(t.tag)) return e("keep-alive", { props: t.componentOptions.propsData }) } var io = function (e) { return e.tag || Ut(e) }, oo = function (e) { return "show" === e.name }, ao = { name: "transition", props: eo, abstract: !0, render: function (e) { var t = this, n = this.$slots.default; if (n && (n = n.filter(io)).length) { var r = this.mode, o = n[0]; if (function (e) { for (; e = e.parent;)if (e.data.transition) return !0 }(this.$vnode)) return o; var a = to(o); if (!a) return o; if (this._leaving) return ro(e, o); var s = "__transition-" + this._uid + "-"; a.key = null == a.key ? a.isComment ? s + "comment" : s + a.tag : i(a.key) ? 0 === String(a.key).indexOf(s) ? a.key : s + a.key : a.key; var c = (a.data || (a.data = {})).transition = no(this), u = this._vnode, l = to(u); if (a.data.directives && a.data.directives.some(oo) && (a.data.show = !0), l && l.data && !function (e, t) { return t.key === e.key && t.tag === e.tag }(a, l) && !Ut(l) && (!l.componentInstance || !l.componentInstance._vnode.isComment)) { var f = l.data.transition = A({}, c); if ("out-in" === r) return this._leaving = !0, it(f, "afterLeave", function () { t._leaving = !1, t.$forceUpdate() }), ro(e, o); if ("in-out" === r) { if (Ut(a)) return u; var p, d = function () { p() }; it(c, "afterEnter", d), it(c, "enterCancelled", d), it(f, "delayLeave", function (e) { p = e }) } } return o } } }, so = A({ tag: String, moveClass: String }, eo); function co(e) { e.elm._moveCb && e.elm._moveCb(), e.elm._enterCb && e.elm._enterCb() } function uo(e) { e.data.newPos = e.elm.getBoundingClientRect() } function lo(e) { var t = e.data.pos, n = e.data.newPos, r = t.left - n.left, i = t.top - n.top; if (r || i) { e.data.moved = !0; var o = e.elm.style; o.transform = o.WebkitTransform = "translate(" + r + "px," + i + "px)", o.transitionDuration = "0s" } } delete so.mode; var fo = { Transition: ao, TransitionGroup: { props: so, beforeMount: function () { var e = this, t = this._update; this._update = function (n, r) { var i = Zt(e); e.__patch__(e._vnode, e.kept, !1, !0), e._vnode = e.kept, i(), t.call(e, n, r) } }, render: function (e) { for (var t = this.tag || this.$vnode.data.tag || "span", n = Object.create(null), r = this.prevChildren = this.children, i = this.$slots.default || [], o = this.children = [], a = no(this), s = 0; s < i.length; s++) { var c = i[s]; c.tag && null != c.key && 0 !== String(c.key).indexOf("__vlist") && (o.push(c), n[c.key] = c, (c.data || (c.data = {})).transition = a) } if (r) { for (var u = [], l = [], f = 0; f < r.length; f++) { var p = r[f]; p.data.transition = a, p.data.pos = p.elm.getBoundingClientRect(), n[p.key] ? u.push(p) : l.push(p) } this.kept = e(t, null, u), this.removed = l } return e(t, null, o) }, updated: function () { var e = this.prevChildren, t = this.moveClass || (this.name || "v") + "-move"; e.length && this.hasMove(e[0].elm, t) && (e.forEach(co), e.forEach(uo), e.forEach(lo), this._reflow = document.body.offsetHeight, e.forEach(function (e) { if (e.data.moved) { var n = e.elm, r = n.style; Ni(n, t), r.transform = r.WebkitTransform = r.transitionDuration = "", n.addEventListener(Ai, n._moveCb = function e(r) { r && r.target !== n || r && !/transform$/.test(r.propertyName) || (n.removeEventListener(Ai, e), n._moveCb = null, ji(n, t)) }) } })) }, methods: { hasMove: function (e, t) { if (!wi) return !1; if (this._hasMove) return this._hasMove; var n = e.cloneNode(); e._transitionClasses && e._transitionClasses.forEach(function (e) { _i(n, e) }), gi(n, t), n.style.display = "none", this.$el.appendChild(n); var r = Mi(n); return this.$el.removeChild(n), this._hasMove = r.hasTransform } } } }; wn.config.mustUseProp = jn, wn.config.isReservedTag = Wn, wn.config.isReservedAttr = En, wn.config.getTagNamespace = Zn, wn.config.isUnknownElement = function (e) { if (!z) return !0; if (Wn(e)) return !1; if (e = e.toLowerCase(), null != Gn[e]) return Gn[e]; var t = document.createElement(e); return e.indexOf("-") > -1 ? Gn[e] = t.constructor === window.HTMLUnknownElement || t.constructor === window.HTMLElement : Gn[e] = /HTMLUnknownElement/.test(t.toString()) }, A(wn.options.directives, Qi), A(wn.options.components, fo), wn.prototype.__patch__ = z ? zi : S, wn.prototype.$mount = function (e, t) { return function (e, t, n) { var r; return e.$el = t, e.$options.render || (e.$options.render = ve), Yt(e, "beforeMount"), r = function () { e._update(e._render(), n) }, new fn(e, r, S, { before: function () { e._isMounted && !e._isDestroyed && Yt(e, "beforeUpdate") } }, !0), n = !1, null == e.$vnode && (e._isMounted = !0, Yt(e, "mounted")), e }(this, e = e && z ? Yn(e) : void 0, t) }, z && setTimeout(function () { F.devtools && ne && ne.emit("init", wn) }, 0); var po = /\{\{((?:.|\r?\n)+?)\}\}/g, vo = /[-.*+?^${}()|[\]\/\\]/g, ho = g(function (e) { var t = e[0].replace(vo, "\\$&"), n = e[1].replace(vo, "\\$&"); return new RegExp(t + "((?:.|\\n)+?)" + n, "g") }); var mo = { staticKeys: ["staticClass"], transformNode: function (e, t) { t.warn; var n = Fr(e, "class"); n && (e.staticClass = JSON.stringify(n)); var r = Ir(e, "class", !1); r && (e.classBinding = r) }, genData: function (e) { var t = ""; return e.staticClass && (t += "staticClass:" + e.staticClass + ","), e.classBinding && (t += "class:" + e.classBinding + ","), t } }; var yo, go = { staticKeys: ["staticStyle"], transformNode: function (e, t) { t.warn; var n = Fr(e, "style"); n && (e.staticStyle = JSON.stringify(ai(n))); var r = Ir(e, "style", !1); r && (e.styleBinding = r) }, genData: function (e) { var t = ""; return e.staticStyle && (t += "staticStyle:" + e.staticStyle + ","), e.styleBinding && (t += "style:(" + e.styleBinding + "),"), t } }, _o = function (e) { return (yo = yo || document.createElement("div")).innerHTML = e, yo.textContent }, bo = p("area,base,br,col,embed,frame,hr,img,input,isindex,keygen,link,meta,param,source,track,wbr"), $o = p("colgroup,dd,dt,li,options,p,td,tfoot,th,thead,tr,source"), wo = p("address,article,aside,base,blockquote,body,caption,col,colgroup,dd,details,dialog,div,dl,dt,fieldset,figcaption,figure,footer,form,h1,h2,h3,h4,h5,h6,head,header,hgroup,hr,html,legend,li,menuitem,meta,optgroup,option,param,rp,rt,source,style,summary,tbody,td,tfoot,th,thead,title,tr,track"), Co = /^\s*([^\s"'<>\/=]+)(?:\s*(=)\s*(?:"([^"]*)"+|'([^']*)'+|([^\s"'=<>`]+)))?/, xo = /^\s*((?:v-[\w-]+:|@|:|#)\[[^=]+\][^\s"'<>\/=]*)(?:\s*(=)\s*(?:"([^"]*)"+|'([^']*)'+|([^\s"'=<>`]+)))?/, ko = "[a-zA-Z_][\\-\\.0-9_a-zA-Z" + P.source + "]*", Ao = "((?:" + ko + "\\:)?" + ko + ")", Oo = new RegExp("^<" + Ao), So = /^\s*(\/?)>/, To = new RegExp("^<\\/" + Ao + "[^>]*>"), Eo = /^<!DOCTYPE [^>]+>/i, No = /^<!\--/, jo = /^<!\[/, Do = p("script,style,textarea", !0), Lo = {}, Mo = { "&lt;": "<", "&gt;": ">", "&quot;": '"', "&amp;": "&", "&#10;": "\n", "&#9;": "\t", "&#39;": "'" }, Io = /&(?:lt|gt|quot|amp|#39);/g, Fo = /&(?:lt|gt|quot|amp|#39|#10|#9);/g, Po = p("pre,textarea", !0), Ro = function (e, t) { return e && Po(e) && "\n" === t[0] }; function Ho(e, t) { var n = t ? Fo : Io; return e.replace(n, function (e) { return Mo[e] }) } var Bo, Uo, zo, Vo, Ko, Jo, qo, Wo, Zo = /^@|^v-on:/, Go = /^v-|^@|^:/, Xo = /([\s\S]*?)\s+(?:in|of)\s+([\s\S]*)/, Yo = /,([^,\}\]]*)(?:,([^,\}\]]*))?$/, Qo = /^\(|\)$/g, ea = /^\[.*\]$/, ta = /:(.*)$/, na = /^:|^\.|^v-bind:/, ra = /\.[^.\]]+(?=[^\]]*$)/g, ia = /^v-slot(:|$)|^#/, oa = /[\r\n]/, aa = /\s+/g, sa = g(_o), ca = "_empty_"; function ua(e, t, n) { return { type: 1, tag: e, attrsList: t, attrsMap: ma(t), rawAttrsMap: {}, parent: n, children: [] } } function la(e, t) { Bo = t.warn || Sr, Jo = t.isPreTag || T, qo = t.mustUseProp || T, Wo = t.getTagNamespace || T; t.isReservedTag; zo = Tr(t.modules, "transformNode"), Vo = Tr(t.modules, "preTransformNode"), Ko = Tr(t.modules, "postTransformNode"), Uo = t.delimiters; var n, r, i = [], o = !1 !== t.preserveWhitespace, a = t.whitespace, s = !1, c = !1; function u(e) { if (l(e), s || e.processed || (e = fa(e, t)), i.length || e === n || n.if && (e.elseif || e.else) && da(n, { exp: e.elseif, block: e }), r && !e.forbidden) if (e.elseif || e.else) a = e, (u = function (e) { var t = e.length; for (; t--;) { if (1 === e[t].type) return e[t]; e.pop() } }(r.children)) && u.if && da(u, { exp: a.elseif, block: a }); else { if (e.slotScope) { var o = e.slotTarget || '"default"'; (r.scopedSlots || (r.scopedSlots = {}))[o] = e } r.children.push(e), e.parent = r } var a, u; e.children = e.children.filter(function (e) { return !e.slotScope }), l(e), e.pre && (s = !1), Jo(e.tag) && (c = !1); for (var f = 0; f < Ko.length; f++)Ko[f](e, t) } function l(e) { if (!c) for (var t; (t = e.children[e.children.length - 1]) && 3 === t.type && " " === t.text;)e.children.pop() } return function (e, t) { for (var n, r, i = [], o = t.expectHTML, a = t.isUnaryTag || T, s = t.canBeLeftOpenTag || T, c = 0; e;) { if (n = e, r && Do(r)) { var u = 0, l = r.toLowerCase(), f = Lo[l] || (Lo[l] = new RegExp("([\\s\\S]*?)(</" + l + "[^>]*>)", "i")), p = e.replace(f, function (e, n, r) { return u = r.length, Do(l) || "noscript" === l || (n = n.replace(/<!\--([\s\S]*?)--> / g, "$1").replace(/<!\[CDATA\[([\s\S]*?)]]>/g, "$1")), Ro(l, n) && (n = n.slice(1)), t.chars && t.chars(n), "" }); c += e.length - p.length, e = p, A(l, c - u, c) } else { var d = e.indexOf("<"); if (0 === d) { if (No.test(e)) { var v = e.indexOf("--\x3e"); if (v >= 0) { t.shouldKeepComment && t.comment(e.substring(4, v), c, c + v + 3), C(v + 3); continue } } if (jo.test(e)) { var h = e.indexOf("]>"); if (h >= 0) { C(h + 2); continue } } var m = e.match(Eo); if (m) { C(m[0].length); continue } var y = e.match(To); if (y) { var g = c; C(y[0].length), A(y[1], g, c); continue } var _ = x(); if (_) { k(_), Ro(_.tagName, e) && C(1); continue } } var b = void 0, $ = void 0, w = void 0; if (d >= 0) { for ($ = e.slice(d); !(To.test($) || Oo.test($) || No.test($) || jo.test($) || (w = $.indexOf("<", 1)) < 0);)d += w, $ = e.slice(d); b = e.substring(0, d) } d < 0 && (b = e), b && C(b.length), t.chars && b && t.chars(b, c - b.length, c) } if (e === n) { t.chars && t.chars(e); break } } function C(t) { c += t, e = e.substring(t) } function x() { var t = e.match(Oo); if (t) { var n, r, i = { tagName: t[1], attrs: [], start: c }; for (C(t[0].length); !(n = e.match(So)) && (r = e.match(xo) || e.match(Co));)r.start = c, C(r[0].length), r.end = c, i.attrs.push(r); if (n) return i.unarySlash = n[1], C(n[0].length), i.end = c, i } } function k(e) { var n = e.tagName, c = e.unarySlash; o && ("p" === r && wo(n) && A(r), s(n) && r === n && A(n)); for (var u = a(n) || !!c, l = e.attrs.length, f = new Array(l), p = 0; p < l; p++) { var d = e.attrs[p], v = d[3] || d[4] || d[5] || "", h = "a" === n && "href" === d[1] ? t.shouldDecodeNewlinesForHref : t.shouldDecodeNewlines; f[p] = { name: d[1], value: Ho(v, h) } } u || (i.push({ tag: n, lowerCasedTag: n.toLowerCase(), attrs: f, start: e.start, end: e.end }), r = n), t.start && t.start(n, f, u, e.start, e.end) } function A(e, n, o) { var a, s; if (null == n && (n = c), null == o && (o = c), e) for (s = e.toLowerCase(), a = i.length - 1; a >= 0 && i[a].lowerCasedTag !== s; a--); else a = 0; if (a >= 0) { for (var u = i.length - 1; u >= a; u--)t.end && t.end(i[u].tag, n, o); i.length = a, r = a && i[a - 1].tag } else "br" === s ? t.start && t.start(e, [], !0, n, o) : "p" === s && (t.start && t.start(e, [], !1, n, o), t.end && t.end(e, n, o)) } A() }(e, { warn: Bo, expectHTML: t.expectHTML, isUnaryTag: t.isUnaryTag, canBeLeftOpenTag: t.canBeLeftOpenTag, shouldDecodeNewlines: t.shouldDecodeNewlines, shouldDecodeNewlinesForHref: t.shouldDecodeNewlinesForHref, shouldKeepComment: t.comments, outputSourceRange: t.outputSourceRange, start: function (e, o, a, l, f) { var p = r && r.ns || Wo(e); q && "svg" === p && (o = function (e) { for (var t = [], n = 0; n < e.length; n++) { var r = e[n]; ya.test(r.name) || (r.name = r.name.replace(ga, ""), t.push(r)) } return t }(o)); var d, v = ua(e, o, r); p && (v.ns = p), "style" !== (d = v).tag && ("script" !== d.tag || d.attrsMap.type && "text/javascript" !== d.attrsMap.type) || te() || (v.forbidden = !0); for (var h = 0; h < Vo.length; h++)v = Vo[h](v, t) || v; s || (!function (e) { null != Fr(e, "v-pre") && (e.pre = !0) }(v), v.pre && (s = !0)), Jo(v.tag) && (c = !0), s ? function (e) { var t = e.attrsList, n = t.length; if (n) for (var r = e.attrs = new Array(n), i = 0; i < n; i++)r[i] = { name: t[i].name, value: JSON.stringify(t[i].value) }, null != t[i].start && (r[i].start = t[i].start, r[i].end = t[i].end); else e.pre || (e.plain = !0) }(v) : v.processed || (pa(v), function (e) { var t = Fr(e, "v-if"); if (t) e.if = t, da(e, { exp: t, block: e }); else { null != Fr(e, "v-else") && (e.else = !0); var n = Fr(e, "v-else-if"); n && (e.elseif = n) } }(v), function (e) { null != Fr(e, "v-once") && (e.once = !0) }(v)), n || (n = v), a ? u(v) : (r = v, i.push(v)) }, end: function (e, t, n) { var o = i[i.length - 1]; i.length -= 1, r = i[i.length - 1], u(o) }, chars: function (e, t, n) { if (r && (!q || "textarea" !== r.tag || r.attrsMap.placeholder !== e)) { var i, u, l, f = r.children; if (e = c || e.trim() ? "script" === (i = r).tag || "style" === i.tag ? e : sa(e) : f.length ? a ? "condense" === a && oa.test(e) ? "" : " " : o ? " " : "" : "") c || "condense" !== a || (e = e.replace(aa, " ")), !s && " " !== e && (u = function (e, t) { var n = t ? ho(t) : po; if (n.test(e)) { for (var r, i, o, a = [], s = [], c = n.lastIndex = 0; r = n.exec(e);) { (i = r.index) > c && (s.push(o = e.slice(c, i)), a.push(JSON.stringify(o))); var u = Ar(r[1].trim()); a.push("_s(" + u + ")"), s.push({ "@binding": u }), c = i + r[0].length } return c < e.length && (s.push(o = e.slice(c)), a.push(JSON.stringify(o))), { expression: a.join("+"), tokens: s } } }(e, Uo)) ? l = { type: 2, expression: u.expression, tokens: u.tokens, text: e } : " " === e && f.length && " " === f[f.length - 1].text || (l = { type: 3, text: e }), l && f.push(l) } }, comment: function (e, t, n) { if (r) { var i = { type: 3, text: e, isComment: !0 }; r.children.push(i) } } }), n } function fa(e, t) { var n, r; (r = Ir(n = e, "key")) && (n.key = r), e.plain = !e.key && !e.scopedSlots && !e.attrsList.length, function (e) { var t = Ir(e, "ref"); t && (e.ref = t, e.refInFor = function (e) { var t = e; for (; t;) { if (void 0 !== t.for) return !0; t = t.parent } return !1 }(e)) }(e), function (e) { var t; "template" === e.tag ? (t = Fr(e, "scope"), e.slotScope = t || Fr(e, "slot-scope")) : (t = Fr(e, "slot-scope")) && (e.slotScope = t); var n = Ir(e, "slot"); n && (e.slotTarget = '""' === n ? '"default"' : n, e.slotTargetDynamic = !(!e.attrsMap[":slot"] && !e.attrsMap["v-bind:slot"]), "template" === e.tag || e.slotScope || Nr(e, "slot", n, function (e, t) { return e.rawAttrsMap[":" + t] || e.rawAttrsMap["v-bind:" + t] || e.rawAttrsMap[t] }(e, "slot"))); if ("template" === e.tag) { var r = Pr(e, ia); if (r) { var i = va(r), o = i.name, a = i.dynamic; e.slotTarget = o, e.slotTargetDynamic = a, e.slotScope = r.value || ca } } else { var s = Pr(e, ia); if (s) { var c = e.scopedSlots || (e.scopedSlots = {}), u = va(s), l = u.name, f = u.dynamic, p = c[l] = ua("template", [], e); p.slotTarget = l, p.slotTargetDynamic = f, p.children = e.children.filter(function (e) { if (!e.slotScope) return e.parent = p, !0 }), p.slotScope = s.value || ca, e.children = [], e.plain = !1 } } }(e), function (e) { "slot" === e.tag && (e.slotName = Ir(e, "name")) }(e), function (e) { var t; (t = Ir(e, "is")) && (e.component = t); null != Fr(e, "inline-template") && (e.inlineTemplate = !0) }(e); for (var i = 0; i < zo.length; i++)e = zo[i](e, t) || e; return function (e) { var t, n, r, i, o, a, s, c, u = e.attrsList; for (t = 0, n = u.length; t < n; t++)if (r = i = u[t].name, o = u[t].value, Go.test(r)) if (e.hasBindings = !0, (a = ha(r.replace(Go, ""))) && (r = r.replace(ra, "")), na.test(r)) r = r.replace(na, ""), o = Ar(o), (c = ea.test(r)) && (r = r.slice(1, -1)), a && (a.prop && !c && "innerHtml" === (r = b(r)) && (r = "innerHTML"), a.camel && !c && (r = b(r)), a.sync && (s = Br(o, "$event"), c ? Mr(e, '"update:"+(' + r + ")", s, null, !1, 0, u[t], !0) : (Mr(e, "update:" + b(r), s, null, !1, 0, u[t]), C(r) !== b(r) && Mr(e, "update:" + C(r), s, null, !1, 0, u[t])))), a && a.prop || !e.component && qo(e.tag, e.attrsMap.type, r) ? Er(e, r, o, u[t], c) : Nr(e, r, o, u[t], c); else if (Zo.test(r)) r = r.replace(Zo, ""), (c = ea.test(r)) && (r = r.slice(1, -1)), Mr(e, r, o, a, !1, 0, u[t], c); else { var l = (r = r.replace(Go, "")).match(ta), f = l && l[1]; c = !1, f && (r = r.slice(0, -(f.length + 1)), ea.test(f) && (f = f.slice(1, -1), c = !0)), Dr(e, r, i, o, f, c, a, u[t]) } else Nr(e, r, JSON.stringify(o), u[t]), !e.component && "muted" === r && qo(e.tag, e.attrsMap.type, r) && Er(e, r, "true", u[t]) }(e), e } function pa(e) { var t; if (t = Fr(e, "v-for")) { var n = function (e) { var t = e.match(Xo); if (!t) return; var n = {}; n.for = t[2].trim(); var r = t[1].trim().replace(Qo, ""), i = r.match(Yo); i ? (n.alias = r.replace(Yo, "").trim(), n.iterator1 = i[1].trim(), i[2] && (n.iterator2 = i[2].trim())) : n.alias = r; return n }(t); n && A(e, n) } } function da(e, t) { e.ifConditions || (e.ifConditions = []), e.ifConditions.push(t) } function va(e) { var t = e.name.replace(ia, ""); return t || "#" !== e.name[0] && (t = "default"), ea.test(t) ? { name: t.slice(1, -1), dynamic: !0 } : { name: '"' + t + '"', dynamic: !1 } } function ha(e) { var t = e.match(ra); if (t) { var n = {}; return t.forEach(function (e) { n[e.slice(1)] = !0 }), n } } function ma(e) { for (var t = {}, n = 0, r = e.length; n < r; n++)t[e[n].name] = e[n].value; return t } var ya = /^xmlns:NS\d+/, ga = /^NS\d+:/; function _a(e) { return ua(e.tag, e.attrsList.slice(), e.parent) } var ba = [mo, go, { preTransformNode: function (e, t) { if ("input" === e.tag) { var n, r = e.attrsMap; if (!r["v-model"]) return; if ((r[":type"] || r["v-bind:type"]) && (n = Ir(e, "type")), r.type || n || !r["v-bind"] || (n = "(" + r["v-bind"] + ").type"), n) { var i = Fr(e, "v-if", !0), o = i ? "&&(" + i + ")" : "", a = null != Fr(e, "v-else", !0), s = Fr(e, "v-else-if", !0), c = _a(e); pa(c), jr(c, "type", "checkbox"), fa(c, t), c.processed = !0, c.if = "(" + n + ")==='checkbox'" + o, da(c, { exp: c.if, block: c }); var u = _a(e); Fr(u, "v-for", !0), jr(u, "type", "radio"), fa(u, t), da(c, { exp: "(" + n + ")==='radio'" + o, block: u }); var l = _a(e); return Fr(l, "v-for", !0), jr(l, ":type", n), fa(l, t), da(c, { exp: i, block: l }), a ? c.else = !0 : s && (c.elseif = s), c } } } }]; var $a, wa, Ca = { expectHTML: !0, modules: ba, directives: { model: function (e, t, n) { var r = t.value, i = t.modifiers, o = e.tag, a = e.attrsMap.type; if (e.component) return Hr(e, r, i), !1; if ("select" === o) !function (e, t, n) { var r = 'var $$selectedVal = Array.prototype.filter.call($event.target.options,function(o){return o.selected}).map(function(o){var val = "_value" in o ? o._value : o.value;return ' + (n && n.number ? "_n(val)" : "val") + "});"; r = r + " " + Br(t, "$event.target.multiple ? $$selectedVal : $$selectedVal[0]"), Mr(e, "change", r, null, !0) }(e, r, i); else if ("input" === o && "checkbox" === a) !function (e, t, n) { var r = n && n.number, i = Ir(e, "value") || "null", o = Ir(e, "true-value") || "true", a = Ir(e, "false-value") || "false"; Er(e, "checked", "Array.isArray(" + t + ")?_i(" + t + "," + i + ")>-1" + ("true" === o ? ":(" + t + ")" : ":_q(" + t + "," + o + ")")), Mr(e, "change", "var $$a=" + t + ",$$el=$event.target,$$c=$$el.checked?(" + o + "):(" + a + ");if(Array.isArray($$a)){var $$v=" + (r ? "_n(" + i + ")" : i) + ",$$i=_i($$a,$$v);if($$el.checked){$$i<0&&(" + Br(t, "$$a.concat([$$v])") + ")}else{$$i>-1&&(" + Br(t, "$$a.slice(0,$$i).concat($$a.slice($$i+1))") + ")}}else{" + Br(t, "$$c") + "}", null, !0) }(e, r, i); else if ("input" === o && "radio" === a) !function (e, t, n) { var r = n && n.number, i = Ir(e, "value") || "null"; Er(e, "checked", "_q(" + t + "," + (i = r ? "_n(" + i + ")" : i) + ")"), Mr(e, "change", Br(t, i), null, !0) }(e, r, i); else if ("input" === o || "textarea" === o) !function (e, t, n) { var r = e.attrsMap.type, i = n || {}, o = i.lazy, a = i.number, s = i.trim, c = !o && "range" !== r, u = o ? "change" : "range" === r ? Wr : "input", l = "$event.target.value"; s && (l = "$event.target.value.trim()"), a && (l = "_n(" + l + ")"); var f = Br(t, l); c && (f = "if($event.target.composing)return;" + f), Er(e, "value", "(" + t + ")"), Mr(e, u, f, null, !0), (s || a) && Mr(e, "blur", "$forceUpdate()") }(e, r, i); else if (!F.isReservedTag(o)) return Hr(e, r, i), !1; return !0 }, text: function (e, t) { t.value && Er(e, "textContent", "_s(" + t.value + ")", t) }, html: function (e, t) { t.value && Er(e, "innerHTML", "_s(" + t.value + ")", t) } }, isPreTag: function (e) { return "pre" === e }, isUnaryTag: bo, mustUseProp: jn, canBeLeftOpenTag: $o, isReservedTag: Wn, getTagNamespace: Zn, staticKeys: function (e) { return e.reduce(function (e, t) { return e.concat(t.staticKeys || []) }, []).join(",") }(ba) }, xa = g(function (e) { return p("type,tag,attrsList,attrsMap,plain,parent,children,attrs,start,end,rawAttrsMap" + (e ? "," + e : "")) }); function ka(e, t) { e && ($a = xa(t.staticKeys || ""), wa = t.isReservedTag || T, function e(t) { t.static = function (e) { if (2 === e.type) return !1; if (3 === e.type) return !0; return !(!e.pre && (e.hasBindings || e.if || e.for || d(e.tag) || !wa(e.tag) || function (e) { for (; e.parent;) { if ("template" !== (e = e.parent).tag) return !1; if (e.for) return !0 } return !1 }(e) || !Object.keys(e).every($a))) }(t); if (1 === t.type) { if (!wa(t.tag) && "slot" !== t.tag && null == t.attrsMap["inline-template"]) return; for (var n = 0, r = t.children.length; n < r; n++) { var i = t.children[n]; e(i), i.static || (t.static = !1) } if (t.ifConditions) for (var o = 1, a = t.ifConditions.length; o < a; o++) { var s = t.ifConditions[o].block; e(s), s.static || (t.static = !1) } } }(e), function e(t, n) { if (1 === t.type) { if ((t.static || t.once) && (t.staticInFor = n), t.static && t.children.length && (1 !== t.children.length || 3 !== t.children[0].type)) return void (t.staticRoot = !0); if (t.staticRoot = !1, t.children) for (var r = 0, i = t.children.length; r < i; r++)e(t.children[r], n || !!t.for); if (t.ifConditions) for (var o = 1, a = t.ifConditions.length; o < a; o++)e(t.ifConditions[o].block, n) } }(e, !1)) } var Aa = /^([\w$_]+|\([^)]*?\))\s*=>|^function\s*(?:[\w$]+)?\s*\(/, Oa = /\([^)]*?\);*$/, Sa = /^[A-Za-z_$][\w$]*(?:\.[A-Za-z_$][\w$]*|\['[^']*?']|\["[^"]*?"]|\[\d+]|\[[A-Za-z_$][\w$]*])*$/, Ta = { esc: 27, tab: 9, enter: 13, space: 32, up: 38, left: 37, right: 39, down: 40, delete: [8, 46] }, Ea = { esc: ["Esc", "Escape"], tab: "Tab", enter: "Enter", space: [" ", "Spacebar"], up: ["Up", "ArrowUp"], left: ["Left", "ArrowLeft"], right: ["Right", "ArrowRight"], down: ["Down", "ArrowDown"], delete: ["Backspace", "Delete", "Del"] }, Na = function (e) { return "if(" + e + ")return null;" }, ja = { stop: "$event.stopPropagation();", prevent: "$event.preventDefault();", self: Na("$event.target !== $event.currentTarget"), ctrl: Na("!$event.ctrlKey"), shift: Na("!$event.shiftKey"), alt: Na("!$event.altKey"), meta: Na("!$event.metaKey"), left: Na("'button' in $event && $event.button !== 0"), middle: Na("'button' in $event && $event.button !== 1"), right: Na("'button' in $event && $event.button !== 2") }; function Da(e, t) { var n = t ? "nativeOn:" : "on:", r = "", i = ""; for (var o in e) { var a = La(e[o]); e[o] && e[o].dynamic ? i += o + "," + a + "," : r += '"' + o + '":' + a + "," } return r = "{" + r.slice(0, -1) + "}", i ? n + "_d(" + r + ",[" + i.slice(0, -1) + "])" : n + r } function La(e) { if (!e) return "function(){}"; if (Array.isArray(e)) return "[" + e.map(function (e) { return La(e) }).join(",") + "]"; var t = Sa.test(e.value), n = Aa.test(e.value), r = Sa.test(e.value.replace(Oa, "")); if (e.modifiers) { var i = "", o = "", a = []; for (var s in e.modifiers) if (ja[s]) o += ja[s], Ta[s] && a.push(s); else if ("exact" === s) { var c = e.modifiers; o += Na(["ctrl", "shift", "alt", "meta"].filter(function (e) { return !c[e] }).map(function (e) { return "$event." + e + "Key" }).join("||")) } else a.push(s); return a.length && (i += function (e) { return "if(!$event.type.indexOf('key')&&" + e.map(Ma).join("&&") + ")return null;" }(a)), o && (i += o), "function($event){" + i + (t ? "return " + e.value + "($event)" : n ? "return (" + e.value + ")($event)" : r ? "return " + e.value : e.value) + "}" } return t || n ? e.value : "function($event){" + (r ? "return " + e.value : e.value) + "}" } function Ma(e) { var t = parseInt(e, 10); if (t) return "$event.keyCode!==" + t; var n = Ta[e], r = Ea[e]; return "_k($event.keyCode," + JSON.stringify(e) + "," + JSON.stringify(n) + ",$event.key," + JSON.stringify(r) + ")" } var Ia = { on: function (e, t) { e.wrapListeners = function (e) { return "_g(" + e + "," + t.value + ")" } }, bind: function (e, t) { e.wrapData = function (n) { return "_b(" + n + ",'" + e.tag + "'," + t.value + "," + (t.modifiers && t.modifiers.prop ? "true" : "false") + (t.modifiers && t.modifiers.sync ? ",true" : "") + ")" } }, cloak: S }, Fa = function (e) { this.options = e, this.warn = e.warn || Sr, this.transforms = Tr(e.modules, "transformCode"), this.dataGenFns = Tr(e.modules, "genData"), this.directives = A(A({}, Ia), e.directives); var t = e.isReservedTag || T; this.maybeComponent = function (e) { return !!e.component || !t(e.tag) }, this.onceId = 0, this.staticRenderFns = [], this.pre = !1 }; function Pa(e, t) { var n = new Fa(t); return { render: "with(this){return " + (e ? Ra(e, n) : '_c("div")') + "}", staticRenderFns: n.staticRenderFns } } function Ra(e, t) { if (e.parent && (e.pre = e.pre || e.parent.pre), e.staticRoot && !e.staticProcessed) return Ha(e, t); if (e.once && !e.onceProcessed) return Ba(e, t); if (e.for && !e.forProcessed) return za(e, t); if (e.if && !e.ifProcessed) return Ua(e, t); if ("template" !== e.tag || e.slotTarget || t.pre) { if ("slot" === e.tag) return function (e, t) { var n = e.slotName || '"default"', r = qa(e, t), i = "_t(" + n + (r ? "," + r : ""), o = e.attrs || e.dynamicAttrs ? Ga((e.attrs || []).concat(e.dynamicAttrs || []).map(function (e) { return { name: b(e.name), value: e.value, dynamic: e.dynamic } })) : null, a = e.attrsMap["v-bind"]; !o && !a || r || (i += ",null"); o && (i += "," + o); a && (i += (o ? "" : ",null") + "," + a); return i + ")" }(e, t); var n; if (e.component) n = function (e, t, n) { var r = t.inlineTemplate ? null : qa(t, n, !0); return "_c(" + e + "," + Va(t, n) + (r ? "," + r : "") + ")" }(e.component, e, t); else { var r; (!e.plain || e.pre && t.maybeComponent(e)) && (r = Va(e, t)); var i = e.inlineTemplate ? null : qa(e, t, !0); n = "_c('" + e.tag + "'" + (r ? "," + r : "") + (i ? "," + i : "") + ")" } for (var o = 0; o < t.transforms.length; o++)n = t.transforms[o](e, n); return n } return qa(e, t) || "void 0" } function Ha(e, t) { e.staticProcessed = !0; var n = t.pre; return e.pre && (t.pre = e.pre), t.staticRenderFns.push("with(this){return " + Ra(e, t) + "}"), t.pre = n, "_m(" + (t.staticRenderFns.length - 1) + (e.staticInFor ? ",true" : "") + ")" } function Ba(e, t) { if (e.onceProcessed = !0, e.if && !e.ifProcessed) return Ua(e, t); if (e.staticInFor) { for (var n = "", r = e.parent; r;) { if (r.for) { n = r.key; break } r = r.parent } return n ? "_o(" + Ra(e, t) + "," + t.onceId++ + "," + n + ")" : Ra(e, t) } return Ha(e, t) } function Ua(e, t, n, r) { return e.ifProcessed = !0, function e(t, n, r, i) { if (!t.length) return i || "_e()"; var o = t.shift(); return o.exp ? "(" + o.exp + ")?" + a(o.block) + ":" + e(t, n, r, i) : "" + a(o.block); function a(e) { return r ? r(e, n) : e.once ? Ba(e, n) : Ra(e, n) } }(e.ifConditions.slice(), t, n, r) } function za(e, t, n, r) { var i = e.for, o = e.alias, a = e.iterator1 ? "," + e.iterator1 : "", s = e.iterator2 ? "," + e.iterator2 : ""; return e.forProcessed = !0, (r || "_l") + "((" + i + "),function(" + o + a + s + "){return " + (n || Ra)(e, t) + "})" } function Va(e, t) { var n = "{", r = function (e, t) { var n = e.directives; if (!n) return; var r, i, o, a, s = "directives:[", c = !1; for (r = 0, i = n.length; r < i; r++) { o = n[r], a = !0; var u = t.directives[o.name]; u && (a = !!u(e, o, t.warn)), a && (c = !0, s += '{name:"' + o.name + '",rawName:"' + o.rawName + '"' + (o.value ? ",value:(" + o.value + "),expression:" + JSON.stringify(o.value) : "") + (o.arg ? ",arg:" + (o.isDynamicArg ? o.arg : '"' + o.arg + '"') : "") + (o.modifiers ? ",modifiers:" + JSON.stringify(o.modifiers) : "") + "},") } if (c) return s.slice(0, -1) + "]" }(e, t); r && (n += r + ","), e.key && (n += "key:" + e.key + ","), e.ref && (n += "ref:" + e.ref + ","), e.refInFor && (n += "refInFor:true,"), e.pre && (n += "pre:true,"), e.component && (n += 'tag:"' + e.tag + '",'); for (var i = 0; i < t.dataGenFns.length; i++)n += t.dataGenFns[i](e); if (e.attrs && (n += "attrs:" + Ga(e.attrs) + ","), e.props && (n += "domProps:" + Ga(e.props) + ","), e.events && (n += Da(e.events, !1) + ","), e.nativeEvents && (n += Da(e.nativeEvents, !0) + ","), e.slotTarget && !e.slotScope && (n += "slot:" + e.slotTarget + ","), e.scopedSlots && (n += function (e, t, n) { var r = e.for || Object.keys(t).some(function (e) { var n = t[e]; return n.slotTargetDynamic || n.if || n.for || Ka(n) }), i = !!e.if; if (!r) for (var o = e.parent; o;) { if (o.slotScope && o.slotScope !== ca || o.for) { r = !0; break } o.if && (i = !0), o = o.parent } var a = Object.keys(t).map(function (e) { return Ja(t[e], n) }).join(","); return "scopedSlots:_u([" + a + "]" + (r ? ",null,true" : "") + (!r && i ? ",null,false," + function (e) { var t = 5381, n = e.length; for (; n;)t = 33 * t ^ e.charCodeAt(--n); return t >>> 0 }(a) : "") + ")" }(e, e.scopedSlots, t) + ","), e.model && (n += "model:{value:" + e.model.value + ",callback:" + e.model.callback + ",expression:" + e.model.expression + "},"), e.inlineTemplate) { var o = function (e, t) { var n = e.children[0]; if (n && 1 === n.type) { var r = Pa(n, t.options); return "inlineTemplate:{render:function(){" + r.render + "},staticRenderFns:[" + r.staticRenderFns.map(function (e) { return "function(){" + e + "}" }).join(",") + "]}" } }(e, t); o && (n += o + ",") } return n = n.replace(/,$/, "") + "}", e.dynamicAttrs && (n = "_b(" + n + ',"' + e.tag + '",' + Ga(e.dynamicAttrs) + ")"), e.wrapData && (n = e.wrapData(n)), e.wrapListeners && (n = e.wrapListeners(n)), n } function Ka(e) { return 1 === e.type && ("slot" === e.tag || e.children.some(Ka)) } function Ja(e, t) { var n = e.attrsMap["slot-scope"]; if (e.if && !e.ifProcessed && !n) return Ua(e, t, Ja, "null"); if (e.for && !e.forProcessed) return za(e, t, Ja); var r = e.slotScope === ca ? "" : String(e.slotScope), i = "function(" + r + "){return " + ("template" === e.tag ? e.if && n ? "(" + e.if + ")?" + (qa(e, t) || "undefined") + ":undefined" : qa(e, t) || "undefined" : Ra(e, t)) + "}", o = r ? "" : ",proxy:true"; return "{key:" + (e.slotTarget || '"default"') + ",fn:" + i + o + "}" } function qa(e, t, n, r, i) { var o = e.children; if (o.length) { var a = o[0]; if (1 === o.length && a.for && "template" !== a.tag && "slot" !== a.tag) { var s = n ? t.maybeComponent(a) ? ",1" : ",0" : ""; return "" + (r || Ra)(a, t) + s } var c = n ? function (e, t) { for (var n = 0, r = 0; r < e.length; r++) { var i = e[r]; if (1 === i.type) { if (Wa(i) || i.ifConditions && i.ifConditions.some(function (e) { return Wa(e.block) })) { n = 2; break } (t(i) || i.ifConditions && i.ifConditions.some(function (e) { return t(e.block) })) && (n = 1) } } return n }(o, t.maybeComponent) : 0, u = i || Za; return "[" + o.map(function (e) { return u(e, t) }).join(",") + "]" + (c ? "," + c : "") } } function Wa(e) { return void 0 !== e.for || "template" === e.tag || "slot" === e.tag } function Za(e, t) { return 1 === e.type ? Ra(e, t) : 3 === e.type && e.isComment ? (r = e, "_e(" + JSON.stringify(r.text) + ")") : "_v(" + (2 === (n = e).type ? n.expression : Xa(JSON.stringify(n.text))) + ")"; var n, r } function Ga(e) { for (var t = "", n = "", r = 0; r < e.length; r++) { var i = e[r], o = Xa(i.value); i.dynamic ? n += i.name + "," + o + "," : t += '"' + i.name + '":' + o + "," } return t = "{" + t.slice(0, -1) + "}", n ? "_d(" + t + ",[" + n.slice(0, -1) + "])" : t } function Xa(e) { return e.replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029") } new RegExp("\\b" + "do,if,for,let,new,try,var,case,else,with,await,break,catch,class,const,super,throw,while,yield,delete,export,import,return,switch,default,extends,finally,continue,debugger,function,arguments".split(",").join("\\b|\\b") + "\\b"); function Ya(e, t) { try { return new Function(e) } catch (n) { return t.push({ err: n, code: e }), S } } function Qa(e) { var t = Object.create(null); return function (n, r, i) { (r = A({}, r)).warn; delete r.warn; var o = r.delimiters ? String(r.delimiters) + n : n; if (t[o]) return t[o]; var a = e(n, r), s = {}, c = []; return s.render = Ya(a.render, c), s.staticRenderFns = a.staticRenderFns.map(function (e) { return Ya(e, c) }), t[o] = s } } var es, ts, ns = (es = function (e, t) { var n = la(e.trim(), t); !1 !== t.optimize && ka(n, t); var r = Pa(n, t); return { ast: n, render: r.render, staticRenderFns: r.staticRenderFns } }, function (e) { function t(t, n) { var r = Object.create(e), i = [], o = []; if (n) for (var a in n.modules && (r.modules = (e.modules || []).concat(n.modules)), n.directives && (r.directives = A(Object.create(e.directives || null), n.directives)), n) "modules" !== a && "directives" !== a && (r[a] = n[a]); r.warn = function (e, t, n) { (n ? o : i).push(e) }; var s = es(t.trim(), r); return s.errors = i, s.tips = o, s } return { compile: t, compileToFunctions: Qa(t) } })(Ca), rs = (ns.compile, ns.compileToFunctions); function is(e) { return (ts = ts || document.createElement("div")).innerHTML = e ? '<a href="\n"/>' : '<div a="\n"/>', ts.innerHTML.indexOf("&#10;") > 0 } var os = !!z && is(!1), as = !!z && is(!0), ss = g(function (e) { var t = Yn(e); return t && t.innerHTML }), cs = wn.prototype.$mount; return wn.prototype.$mount = function (e, t) { if ((e = e && Yn(e)) === document.body || e === document.documentElement) return this; var n = this.$options; if (!n.render) { var r = n.template; if (r) if ("string" == typeof r) "#" === r.charAt(0) && (r = ss(r)); else { if (!r.nodeType) return this; r = r.innerHTML } else e && (r = function (e) { if (e.outerHTML) return e.outerHTML; var t = document.createElement("div"); return t.appendChild(e.cloneNode(!0)), t.innerHTML }(e)); if (r) { var i = rs(r, { outputSourceRange: !1, shouldDecodeNewlines: os, shouldDecodeNewlinesForHref: as, delimiters: n.delimiters, comments: n.comments }, this), o = i.render, a = i.staticRenderFns; n.render = o, n.staticRenderFns = a } } return cs.call(this, e, t) }, wn.compile = rs, wn });

</script>

<script>
  document.getElementById('loading') && document.getElementById('loading').remove()
  new Vue({
    el: '#m-app',

    data() {
      return {
        playbackRateIndex: 2, // 播放倍度索引
        playbackRateList: [0.5, 0.75, 1, 1.25, 1.5, 1.75, 2, 2.5, 3], // 播放倍度
        isPlay: false, // 是否输入完资料，进行播放
        mediaSource: null,
        videoFileName: '',
        audioFileName: '',
        videoSourceBuffer: null,
        audioSourceBuffer: null,
        videoArrayBuffer: null,
        audioArrayBuffer: null,
      }
    },

    mounted() {
      this.mediaSource = new MediaSource
      this.$refs.player.src = URL.createObjectURL(this.mediaSource)
    },

    methods: {
      // 上传资源
      loadSource(event, type) {
        const file = event.target.files[0]
        this[`${type}FileName`] = file.name
        let reader = new FileReader();
        reader.onloadend = (loadEvent) => {
          this[`${type}ArrayBuffer`] = loadEvent.target.result
          this.getMime(this[`${type}ArrayBuffer`]).then((mime) => {
            mime = mime.replace(/,rtp/g, '')
            console.log(this[`${type}ArrayBuffer`], mime, MediaSource.isTypeSupported(mime))
            this[`${type}SourceBuffer`] = this.mediaSource.addSourceBuffer(mime)
          })
        }
        reader.readAsArrayBuffer(file);
      },

      // 获取媒体格式
      getMime(arrayBuffer) {
        return new Promise((resolve) => {
          const mp4boxfile = MP4Box.createFile()
          arrayBuffer.fileStart = 0
          mp4boxfile.onReady = (info) => resolve(info.mime)
          mp4boxfile.appendBuffer(arrayBuffer)
        })
      },

      // 播放
      play() {
        this.isPlay = true
        this.videoSourceBuffer && this.videoArrayBuffer && this.videoSourceBuffer.appendBuffer(this.videoArrayBuffer)
        this.audioSourceBuffer && this.audioArrayBuffer && this.audioSourceBuffer.appendBuffer(this.audioArrayBuffer)
      },

      // 设置播放倍数
      setRate(index) {
        this.playbackRateIndex = index
        this.$refs.player.playbackRate = this.playbackRateList[index]
      },
    }
  })

</script>

</html>